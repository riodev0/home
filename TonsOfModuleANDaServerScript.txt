ModuleScript: FrameworkTypes
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return {};
ModuleScript: T
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v7 = {
    type = function(v0) --[[ Line: 9 ]] --[[ Name: type ]]
        return function(v1) --[[ Line: 10 ]]
            -- upvalues: v0 (copy)
            local v2 = type(v1);
            if v2 == v0 then
                return true;
            else
                return false, string.format("%s expected, got %s", v0, v2);
            end;
        end;
    end, 
    typeof = function(v3) --[[ Line: 20 ]] --[[ Name: typeof ]]
        return function(v4) --[[ Line: 21 ]]
            -- upvalues: v3 (copy)
            local v5 = typeof(v4);
            if v5 == v3 then
                return true;
            else
                return false, string.format("%s expected, got %s", v3, v5);
            end;
        end;
    end, 
    any = function(v6) --[[ Line: 38 ]] --[[ Name: any ]]
        if v6 ~= nil then
            return true;
        else
            return false, "any expected, got nil";
        end;
    end
};
v7.boolean = v7.typeof("boolean");
v7.thread = v7.typeof("thread");
v7.callback = v7.typeof("function");
v7["function"] = v7.callback;
v7.none = v7.typeof("nil");
v7["nil"] = v7.none;
v7.string = v7.typeof("string");
v7.table = v7.typeof("table");
v7.userdata = v7.type("userdata");
v7.number = function(v8) --[[ Line: 120 ]] --[[ Name: number ]]
    local v9 = typeof(v8);
    if v9 == "number" then
        if v8 == v8 then
            return true;
        else
            return false, "unexpected NaN value";
        end;
    else
        return false, string.format("number expected, got %s", v9);
    end;
end;
v7.nan = function(v10) --[[ Line: 140 ]] --[[ Name: nan ]]
    local v11 = typeof(v10);
    if v11 == "number" then
        if v10 ~= v10 then
            return true;
        else
            return false, "unexpected non-NaN value";
        end;
    else
        return false, string.format("number expected, got %s", v11);
    end;
end;
v7.Axes = v7.typeof("Axes");
v7.BrickColor = v7.typeof("BrickColor");
v7.CatalogSearchParams = v7.typeof("CatalogSearchParams");
v7.CFrame = v7.typeof("CFrame");
v7.Color3 = v7.typeof("Color3");
v7.ColorSequence = v7.typeof("ColorSequence");
v7.ColorSequenceKeypoint = v7.typeof("ColorSequenceKeypoint");
v7.DateTime = v7.typeof("DateTime");
v7.DockWidgetPluginGuiInfo = v7.typeof("DockWidgetPluginGuiInfo");
v7.Enum = v7.typeof("Enum");
v7.EnumItem = v7.typeof("EnumItem");
v7.Enums = v7.typeof("Enums");
v7.Faces = v7.typeof("Faces");
v7.Instance = v7.typeof("Instance");
v7.NumberRange = v7.typeof("NumberRange");
v7.NumberSequence = v7.typeof("NumberSequence");
v7.NumberSequenceKeypoint = v7.typeof("NumberSequenceKeypoint");
v7.PathWaypoint = v7.typeof("PathWaypoint");
v7.PhysicalProperties = v7.typeof("PhysicalProperties");
v7.Random = v7.typeof("Random");
v7.Ray = v7.typeof("Ray");
v7.RaycastParams = v7.typeof("RaycastParams");
v7.RaycastResult = v7.typeof("RaycastResult");
v7.RBXScriptConnection = v7.typeof("RBXScriptConnection");
v7.RBXScriptSignal = v7.typeof("RBXScriptSignal");
v7.Rect = v7.typeof("Rect");
v7.Region3 = v7.typeof("Region3");
v7.Region3int16 = v7.typeof("Region3int16");
v7.TweenInfo = v7.typeof("TweenInfo");
v7.UDim = v7.typeof("UDim");
v7.UDim2 = v7.typeof("UDim2");
v7.Vector2 = v7.typeof("Vector2");
v7.Vector2int16 = v7.typeof("Vector2int16");
v7.Vector3 = v7.typeof("Vector3");
v7.Vector3int16 = v7.typeof("Vector3int16");
v7.literal = function(...) --[[ Line: 477 ]] --[[ Name: literal ]]
    -- upvalues: v7 (copy)
    local v12 = select("#", ...);
    if v12 == 1 then
        local v13 = ...;
        return function(v14) --[[ Line: 481 ]]
            -- upvalues: v13 (copy)
            if v14 ~= v13 then
                return false, string.format("expected %s, got %s", tostring(v13), (tostring(v14)));
            else
                return true;
            end;
        end;
    else
        local v15 = {};
        for v16 = 1, v12 do
            local v17 = select(v16, ...);
            v15[v16] = v7.literal(v17);
        end;
        return v7.union(table.unpack(v15, 1, v12));
    end;
end;
v7.exactly = v7.literal;
v7.keyOf = function(v18) --[[ Line: 512 ]] --[[ Name: keyOf ]]
    -- upvalues: v7 (copy)
    local v19 = {};
    local v20 = 0;
    for v21 in pairs(v18) do
        v20 = v20 + 1;
        v19[v20] = v21;
    end;
    return v7.literal(table.unpack(v19, 1, v20));
end;
v7.valueOf = function(v22) --[[ Line: 530 ]] --[[ Name: valueOf ]]
    -- upvalues: v7 (copy)
    local v23 = {};
    local v24 = 0;
    for _, v26 in pairs(v22) do
        v24 = v24 + 1;
        v23[v24] = v26;
    end;
    return v7.literal(table.unpack(v23, 1, v24));
end;
v7.integer = function(v27) --[[ Line: 548 ]] --[[ Name: integer ]]
    -- upvalues: v7 (copy)
    local v28, v29 = v7.number(v27);
    if not v28 then
        return false, v29 or "";
    elseif v27 % 1 == 0 then
        return true;
    else
        return false, string.format("integer expected, got %s", v27);
    end;
end;
v7.numberMin = function(v30) --[[ Line: 568 ]] --[[ Name: numberMin ]]
    -- upvalues: v7 (copy)
    return function(v31) --[[ Line: 569 ]]
        -- upvalues: v7 (ref), v30 (copy)
        local v32, v33 = v7.number(v31);
        if not v32 then
            return false, v33 or "";
        elseif v30 <= v31 then
            return true;
        else
            return false, string.format("number >= %s expected, got %s", v30, v31);
        end;
    end;
end;
v7.numberMax = function(v34) --[[ Line: 590 ]] --[[ Name: numberMax ]]
    -- upvalues: v7 (copy)
    return function(v35) --[[ Line: 591 ]]
        -- upvalues: v7 (ref), v34 (copy)
        local v36, v37 = v7.number(v35);
        if not v36 then
            return false, v37;
        elseif v35 <= v34 then
            return true;
        else
            return false, string.format("number <= %s expected, got %s", v34, v35);
        end;
    end;
end;
v7.numberMinExclusive = function(v38) --[[ Line: 612 ]] --[[ Name: numberMinExclusive ]]
    -- upvalues: v7 (copy)
    return function(v39) --[[ Line: 613 ]]
        -- upvalues: v7 (ref), v38 (copy)
        local v40, v41 = v7.number(v39);
        if not v40 then
            return false, v41 or "";
        elseif v38 < v39 then
            return true;
        else
            return false, string.format("number > %s expected, got %s", v38, v39);
        end;
    end;
end;
v7.numberMaxExclusive = function(v42) --[[ Line: 634 ]] --[[ Name: numberMaxExclusive ]]
    -- upvalues: v7 (copy)
    return function(v43) --[[ Line: 635 ]]
        -- upvalues: v7 (ref), v42 (copy)
        local v44, v45 = v7.number(v43);
        if not v44 then
            return false, v45 or "";
        elseif v43 < v42 then
            return true;
        else
            return false, string.format("number < %s expected, got %s", v42, v43);
        end;
    end;
end;
v7.numberPositive = v7.numberMinExclusive(0);
v7.numberNegative = v7.numberMaxExclusive(0);
v7.numberConstrained = function(v46, v47) --[[ Line: 671 ]] --[[ Name: numberConstrained ]]
    -- upvalues: v7 (copy)
    assert(v7.number(v46));
    assert(v7.number(v47));
    local v48 = v7.numberMin(v46);
    local v49 = v7.numberMax(v47);
    return function(v50) --[[ Line: 677 ]]
        -- upvalues: v48 (copy), v49 (copy)
        local v51, v52 = v48(v50);
        if not v51 then
            return false, v52 or "";
        else
            local v53, v54 = v49(v50);
            if not v53 then
                return false, v54 or "";
            else
                return true;
            end;
        end;
    end;
end;
v7.numberConstrainedExclusive = function(v55, v56) --[[ Line: 700 ]] --[[ Name: numberConstrainedExclusive ]]
    -- upvalues: v7 (copy)
    assert(v7.number(v55));
    assert(v7.number(v56));
    local v57 = v7.numberMinExclusive(v55);
    local v58 = v7.numberMaxExclusive(v56);
    return function(v59) --[[ Line: 706 ]]
        -- upvalues: v57 (copy), v58 (copy)
        local v60, v61 = v57(v59);
        if not v60 then
            return false, v61 or "";
        else
            local v62, v63 = v58(v59);
            if not v62 then
                return false, v63 or "";
            else
                return true;
            end;
        end;
    end;
end;
v7.match = function(v64) --[[ Line: 728 ]] --[[ Name: match ]]
    -- upvalues: v7 (copy)
    assert(v7.string(v64));
    return function(v65) --[[ Line: 730 ]]
        -- upvalues: v7 (ref), v64 (copy)
        local v66, v67 = v7.string(v65);
        if not v66 then
            return false, v67;
        elseif string.match(v65, v64) == nil then
            return false, string.format("%q failed to match pattern %q", v65, v64);
        else
            return true;
        end;
    end;
end;
v7.optional = function(v68) --[[ Line: 751 ]] --[[ Name: optional ]]
    -- upvalues: v7 (copy)
    assert(v7.callback(v68));
    return function(v69) --[[ Line: 753 ]]
        -- upvalues: v68 (copy)
        if v69 == nil then
            return true;
        else
            local v70, v71 = v68(v69);
            if v70 then
                return true;
            else
                return false, string.format("(optional) %s", v71 or "");
            end;
        end;
    end;
end;
v7.tuple = function(...) --[[ Line: 774 ]] --[[ Name: tuple ]]
    local v72 = {
        ...
    };
    return function(...) --[[ Line: 776 ]]
        -- upvalues: v72 (copy)
        local v73 = {
            ...
        };
        for v74, v75 in ipairs(v72) do
            local v76, v77 = v75(v73[v74]);
            if v76 == false then
                return false, string.format("Bad tuple index #%s:\n\t%s", v74, v77 or "");
            end;
        end;
        return true;
    end;
end;
v7.keys = function(v78) --[[ Line: 796 ]] --[[ Name: keys ]]
    -- upvalues: v7 (copy)
    assert(v7.callback(v78));
    return function(v79) --[[ Line: 798 ]]
        -- upvalues: v7 (ref), v78 (copy)
        local v80, v81 = v7.table(v79);
        if v80 == false then
            return false, v81 or "";
        else
            for v82 in pairs(v79) do
                local v83, v84 = v78(v82);
                if v83 == false then
                    return false, string.format("bad key %s:\n\t%s", tostring(v82), v84 or "");
                end;
            end;
            return true;
        end;
    end;
end;
v7.values = function(v85) --[[ Line: 822 ]] --[[ Name: values ]]
    -- upvalues: v7 (copy)
    assert(v7.callback(v85));
    return function(v86) --[[ Line: 824 ]]
        -- upvalues: v7 (ref), v85 (copy)
        local v87, v88 = v7.table(v86);
        if v87 == false then
            return false, v88 or "";
        else
            for v89, v90 in pairs(v86) do
                local v91, v92 = v85(v90);
                if v91 == false then
                    return false, string.format("bad value for key %s:\n\t%s", tostring(v89), v92 or "");
                end;
            end;
            return true;
        end;
    end;
end;
v7.map = function(v93, v94) --[[ Line: 849 ]] --[[ Name: map ]]
    -- upvalues: v7 (copy)
    assert(v7.callback(v93));
    assert(v7.callback(v94));
    local v95 = v7.keys(v93);
    local v96 = v7.values(v94);
    return function(v97) --[[ Line: 855 ]]
        -- upvalues: v95 (copy), v96 (copy)
        local v98, v99 = v95(v97);
        if not v98 then
            return false, v99 or "";
        else
            local v100, v101 = v96(v97);
            if not v100 then
                return false, v101 or "";
            else
                return true;
            end;
        end;
    end;
end;
v7.set = function(v102) --[[ Line: 877 ]] --[[ Name: set ]]
    -- upvalues: v7 (copy)
    return v7.map(v102, v7.literal(true));
end;
local v103 = v7.keys(v7.integer);
local l_v103_0 = v103 --[[ copy: 1 -> 2 ]];
v7.array = function(v105) --[[ Line: 890 ]] --[[ Name: array ]]
    -- upvalues: v7 (copy), l_v103_0 (copy)
    assert(v7.callback(v105));
    local v106 = v7.values(v105);
    return function(v107) --[[ Line: 894 ]]
        -- upvalues: l_v103_0 (ref), v106 (copy)
        local v108, v109 = l_v103_0(v107);
        if v108 == false then
            return false, string.format("[array] %s", v109 or "");
        else
            local v110 = 0;
            for _ in ipairs(v107) do
                v110 = v110 + 1;
            end;
            for v112 in pairs(v107) do
                if v112 < 1 or v110 < v112 then
                    return false, string.format("[array] key %s must be sequential", (tostring(v112)));
                end;
            end;
            local v113, v114 = v106(v107);
            if not v113 then
                return false, string.format("[array] %s", v114 or "");
            else
                return true;
            end;
        end;
    end;
end;
v7.strictArray = function(...) --[[ Line: 930 ]] --[[ Name: strictArray ]]
    -- upvalues: v7 (copy), l_v103_0 (copy)
    local v115 = {
        ...
    };
    assert(v7.array(v7.callback)(v115));
    return function(v116) --[[ Line: 934 ]]
        -- upvalues: l_v103_0 (ref), v115 (copy)
        local v117, v118 = l_v103_0(v116);
        if v117 == false then
            return false, string.format("[strictArray] %s", v118 or "");
        elseif #v115 < #v116 then
            return false, string.format("[strictArray] Array size exceeds limit of %d", #v115);
        else
            for v119, v120 in pairs(v115) do
                local v121, v122 = v120(v116[v119]);
                if not v121 then
                    return false, string.format("[strictArray] Array index #%d - %s", v119, v122);
                end;
            end;
            return true;
        end;
    end;
end;
v103 = v7.array(v7.callback);
local l_v103_1 = v103 --[[ copy: 1 -> 3 ]];
v7.union = function(...) --[[ Line: 966 ]] --[[ Name: union ]]
    -- upvalues: l_v103_1 (copy)
    local v124 = {
        ...
    };
    assert(l_v103_1(v124));
    return function(v125) --[[ Line: 970 ]]
        -- upvalues: v124 (copy)
        for _, v127 in ipairs(v124) do
            if v127(v125) then
                return true;
            end;
        end;
        return false, "bad type for union";
    end;
end;
v7.some = v7.union;
v7.intersection = function(...) --[[ Line: 993 ]] --[[ Name: intersection ]]
    -- upvalues: l_v103_1 (copy)
    local v128 = {
        ...
    };
    assert(l_v103_1(v128));
    return function(v129) --[[ Line: 997 ]]
        -- upvalues: v128 (copy)
        for _, v131 in ipairs(v128) do
            local v132, v133 = v131(v129);
            if not v132 then
                return false, v133 or "";
            end;
        end;
        return true;
    end;
end;
v7.every = v7.intersection;
v103 = v7.map(v7.any, v7.callback);
local l_v103_2 = v103 --[[ copy: 1 -> 4 ]];
v7.interface = function(v135) --[[ Line: 1024 ]] --[[ Name: interface ]]
    -- upvalues: l_v103_2 (copy), v7 (copy)
    assert(l_v103_2(v135));
    return function(v136) --[[ Line: 1026 ]]
        -- upvalues: v7 (ref), v135 (copy)
        local v137, v138 = v7.table(v136);
        if v137 == false then
            return false, v138 or "";
        else
            for v139, v140 in pairs(v135) do
                local v141, v142 = v140(v136[v139]);
                if v141 == false then
                    return false, string.format("[interface] bad value for %s:\n\t%s", tostring(v139), v142 or "");
                end;
            end;
            return true;
        end;
    end;
end;
v7.strictInterface = function(v143) --[[ Line: 1050 ]] --[[ Name: strictInterface ]]
    -- upvalues: l_v103_2 (copy), v7 (copy)
    assert(l_v103_2(v143));
    return function(v144) --[[ Line: 1052 ]]
        -- upvalues: v7 (ref), v143 (copy)
        local v145, v146 = v7.table(v144);
        if v145 == false then
            return false, v146 or "";
        else
            for v147, v148 in pairs(v143) do
                local v149, v150 = v148(v144[v147]);
                if v149 == false then
                    return false, string.format("[interface] bad value for %s:\n\t%s", tostring(v147), v150 or "");
                end;
            end;
            for v151 in pairs(v144) do
                if not v143[v151] then
                    return false, string.format("[interface] unexpected field %q", (tostring(v151)));
                end;
            end;
            return true;
        end;
    end;
end;
v7.instanceOf = function(v152, v153) --[[ Line: 1083 ]] --[[ Name: instanceOf ]]
    -- upvalues: v7 (copy)
    assert(v7.string(v152));
    local v154 = nil;
    if v153 ~= nil then
        v154 = v7.children(v153);
    end;
    return function(v155) --[[ Line: 1091 ]]
        -- upvalues: v7 (ref), v152 (copy), v154 (ref)
        local v156, v157 = v7.Instance(v155);
        if not v156 then
            return false, v157 or "";
        elseif v155.ClassName ~= v152 then
            return false, string.format("%s expected, got %s", v152, v155.ClassName);
        else
            if v154 then
                local v158, v159 = v154(v155);
                if not v158 then
                    return false, v159;
                end;
            end;
            return true;
        end;
    end;
end;
v7.instance = v7.instanceOf;
v7.instanceIsA = function(v160, v161) --[[ Line: 1121 ]] --[[ Name: instanceIsA ]]
    -- upvalues: v7 (copy)
    assert(v7.string(v160));
    local v162 = nil;
    if v161 ~= nil then
        v162 = v7.children(v161);
    end;
    return function(v163) --[[ Line: 1129 ]]
        -- upvalues: v7 (ref), v160 (copy), v162 (ref)
        local v164, v165 = v7.Instance(v163);
        if not v164 then
            return false, v165 or "";
        elseif not v163:IsA(v160) then
            return false, string.format("%s expected, got %s", v160, v163.ClassName);
        else
            if v162 then
                local v166, v167 = v162(v163);
                if not v166 then
                    return false, v167;
                end;
            end;
            return true;
        end;
    end;
end;
v7.enum = function(v168) --[[ Line: 1157 ]] --[[ Name: enum ]]
    -- upvalues: v7 (copy)
    assert(v7.Enum(v168));
    return function(v169) --[[ Line: 1159 ]]
        -- upvalues: v7 (ref), v168 (copy)
        local v170, v171 = v7.EnumItem(v169);
        if not v170 then
            return false, v171;
        elseif v169.EnumType == v168 then
            return true;
        else
            return false, string.format("enum of %s expected, got enum of %s", tostring(v168), (tostring(v169.EnumType)));
        end;
    end;
end;
v103 = v7.tuple(v7.callback, v7.callback);
local l_v103_3 = v103 --[[ copy: 1 -> 5 ]];
v7.wrap = function(v173, v174) --[[ Line: 1184 ]] --[[ Name: wrap ]]
    -- upvalues: l_v103_3 (copy)
    assert(l_v103_3(v173, v174));
    return function(...) --[[ Line: 1186 ]]
        -- upvalues: v174 (copy), v173 (copy)
        assert(v174(...));
        return v173(...);
    end;
end;
v7.strict = function(v175) --[[ Line: 1200 ]] --[[ Name: strict ]]
    return function(...) --[[ Line: 1201 ]]
        -- upvalues: v175 (copy)
        assert(v175(...));
    end;
end;
v103 = v7.map(v7.string, v7.callback);
v7.children = function(v176) --[[ Line: 1220 ]] --[[ Name: children ]]
    -- upvalues: v103 (copy), v7 (copy)
    assert(v103(v176));
    return function(v177) --[[ Line: 1223 ]]
        -- upvalues: v7 (ref), v176 (copy)
        local v178, v179 = v7.Instance(v177);
        if not v178 then
            return false, v179 or "";
        else
            local v180 = {};
            for _, v182 in ipairs(v177:GetChildren()) do
                local l_Name_0 = v182.Name;
                if v176[l_Name_0] then
                    if v180[l_Name_0] then
                        return false, string.format("Cannot process multiple children with the same name %q", l_Name_0);
                    else
                        v180[l_Name_0] = v182;
                    end;
                end;
            end;
            for v184, v185 in pairs(v176) do
                local v186, v187 = v185(v180[v184]);
                if not v186 then
                    return false, string.format("[%s.%s] %s", v177:GetFullName(), v184, v187 or "");
                end;
            end;
            return true;
        end;
    end;
end;
return v7;
ModuleScript: Bucket
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_RunService_0 = game:GetService("RunService");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v3 = {};
v3.__index = v3;
local v4 = v2.strictInterface({
    MaxTime = v2.numberMin(0), 
    MaxSize = v2.numberMin(0)
});
v3.new = function(v5, v6) --[[ Line: 53 ]] --[[ Name: new ]]
    -- upvalues: v2 (copy), v4 (copy), v3 (copy), l_RunService_0 (copy)
    assert(v2.callback(v5));
    assert(v4(v6));
    local v7 = setmetatable({}, v3);
    v7._callback = v5;
    v7._config = v6;
    v7._items = {};
    v7._lastWhen = nil;
    v7._connection = l_RunService_0.Heartbeat:Connect(function() --[[ Line: 63 ]]
        -- upvalues: v7 (copy)
        v7:_step();
    end);
    return v7;
end;
v3._step = function(v8) --[[ Line: 71 ]] --[[ Name: _step ]]
    local v9 = os.clock();
    local l__items_0 = v8._items;
    while l__items_0[1] do
        local v11 = l__items_0[1];
        if v9 >= v11.when then
            table.remove(l__items_0, 1);
            task.spawn(v8._callback, v11.value);
        else
            break;
        end;
    end;
end;
v3.Add = function(v12, v13, v14) --[[ Line: 87 ]] --[[ Name: Add ]]
    -- upvalues: v2 (copy)
    assert(v2.numberMin(0)(v13));
    local v15 = os.clock();
    local l__items_1 = v12._items;
    local l_v15_0 = v15;
    if v12._lastWhen then
        l_v15_0 = math.max(v12._lastWhen + v13, v15);
    end;
    if l_v15_0 - v15 > v12._config.MaxTime then
        return false;
    elseif #l__items_1 >= v12._config.MaxSize then
        return false;
    else
        table.insert(l__items_1, {
            when = l_v15_0, 
            value = v14
        });
        v12._lastWhen = l_v15_0;
        v12:_step();
        return true;
    end;
end;
v3.Clear = function(v18) --[[ Line: 115 ]] --[[ Name: Clear ]]
    table.clear(v18._items);
    v18._lastWhen = nil;
end;
v3.Destroy = function(v19) --[[ Line: 121 ]] --[[ Name: Destroy ]]
    v19._connection:Disconnect();
    v19:Clear();
end;
return v3;
ModuleScript: Debounce
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v2 = {};
v2.__index = v2;
v2.new = function(v3) --[[ Line: 25 ]] --[[ Name: new ]]
    -- upvalues: v1 (copy), v2 (copy)
    assert(v1.numberPositive(v3));
    return (setmetatable({
        _duration = v3, 
        _threads = {}
    }, v2));
end;
v2.Has = function(v4, v5) --[[ Line: 33 ]] --[[ Name: Has ]]
    return v4._threads[v5] ~= nil;
end;
v2.Add = function(v6, v7) --[[ Line: 37 ]] --[[ Name: Add ]]
    local v8 = v6._threads[v7];
    if v8 then
        task.cancel(v8);
    end;
    v6._threads[v7] = task.delay(v6._duration, function() --[[ Line: 42 ]]
        -- upvalues: v6 (copy), v7 (copy)
        v6._threads[v7] = nil;
    end);
end;
v2.Remove = function(v9, v10) --[[ Line: 47 ]] --[[ Name: Remove ]]
    local v11 = v9._threads[v10];
    if v11 then
        task.cancel(v11);
        v9._threads[v10] = nil;
    end;
end;
v2.Destroy = function(v12) --[[ Line: 55 ]] --[[ Name: Destroy ]]
    for _, v14 in v12._threads do
        task.cancel(v14);
    end;
    table.clear(v12._threads);
end;
return v2;
ModuleScript: Emitter
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_RunService_0 = game:GetService("RunService");
local l_HttpService_0 = game:GetService("HttpService");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.SequenceUtil);
local v4 = require(l_ReplicatedStorage_0.Client.LowDetail);
local v5 = {};
v5.__index = v5;
local v6 = {
    Enabled = true, 
    Texture = "rbxasset://textures/particles/sparkles_main.dds", 
    Transparency = NumberSequence.new(0), 
    Rate = 10, 
    Lifetime = NumberRange.new(1, 2), 
    Size = NumberSequence.new(50), 
    EmissionDirection = Vector2.new(0, -1), 
    Speed = NumberRange.new(50, 100), 
    Acceleration = Vector2.new(0, 0), 
    Color = ColorSequence.new(Color3.fromRGB(255, 255, 255)), 
    Drag = 0, 
    SpreadAngle = 0, 
    Rotation = NumberRange.new(0), 
    RotSpeed = NumberRange.new(0), 
    ZIndex = 1
};
v5.new = function() --[[ Line: 90 ]] --[[ Name: new ]]
    -- upvalues: v6 (copy), v5 (copy), l_RunService_0 (copy)
    local v7 = setmetatable(table.clone(v6), v5);
    v7._connection = l_RunService_0.Heartbeat:Connect(function(v8) --[[ Line: 93 ]]
        -- upvalues: v7 (copy)
        v7:_update(v8);
    end);
    v7._particles = {};
    v7._buffer = 0;
    v7._rng = Random.new();
    v7.Active = 0;
    local l_Frame_0 = Instance.new("Frame");
    l_Frame_0.Name = "Particles";
    l_Frame_0.Active = false;
    l_Frame_0.Selectable = false;
    l_Frame_0.BackgroundTransparency = 1;
    l_Frame_0.Size = UDim2.fromScale(1, 1);
    v7._holder = l_Frame_0;
    return v7;
end;
local v10 = {
    [Enum.NormalId.Top] = Vector2.new(0, -1), 
    [Enum.NormalId.Bottom] = Vector2.new(0, 1), 
    [Enum.NormalId.Left] = Vector2.new(-1, 0), 
    [Enum.NormalId.Right] = Vector2.new(1, 0), 
    [Enum.NormalId.Front] = Vector2.new(0, -1), 
    [Enum.NormalId.Back] = Vector2.new(0, -1)
};
v5.fromEmitter = function(v11, v12) --[[ Line: 128 ]] --[[ Name: fromEmitter ]]
    -- upvalues: v5 (copy), v10 (copy)
    local v13 = v5.new();
    v13.Enabled = v11.Enabled;
    v13.Texture = v11.Texture;
    v13.Rate = v11.Rate;
    v13.Color = v11.Color;
    v13.EmissionDirection = v10[v11.EmissionDirection];
    v13.Lifetime = v11.Lifetime;
    v13.RotSpeed = v11.RotSpeed;
    v13.Rotation = v11.Rotation;
    v13.Acceleration = Vector2.new(v11.Acceleration.X, -v11.Acceleration.Y) * 65;
    v13.Drag = v11.Drag;
    local v14 = {};
    for v15, v16 in v11.Size.Keypoints do
        v14[v15] = NumberSequenceKeypoint.new(v16.Time, v16.Value * (v12 or 85), v16.Envelope * (v12 or 85));
    end;
    v13.Size = NumberSequence.new(v14);
    v13.Speed = NumberRange.new(v11.Speed.Min * 65, v11.Speed.Max * 65);
    v13.SpreadAngle = (v11.SpreadAngle.X + v11.SpreadAngle.Y) * 0.5;
    v13.Transparency = v11.Transparency;
    v13.ZIndex = v11.ZOffset + 1;
    return v13;
end;
v5._update = function(v17, v18) --[[ Line: 161 ]] --[[ Name: _update ]]
    -- upvalues: l_HttpService_0 (copy), v3 (copy)
    local v19 = os.clock();
    if v17.Parent and v17.Parent:IsDescendantOf(game) then
        v17._holder.Parent = v17.Parent;
        v17._holder.ZIndex = v17.ZIndex;
    end;
    if v17.Enabled then
        local v20 = v17._buffer + v18 * v17.Rate;
        for _ = 1, math.floor(v20) do
            local v22 = l_HttpService_0:GenerateGUID(false);
            local l_ImageLabel_0 = Instance.new("ImageLabel");
            l_ImageLabel_0.AnchorPoint = Vector2.new(0.5, 0.5);
            l_ImageLabel_0.BackgroundTransparency = 1;
            local l_EmissionDirection_0 = v17.EmissionDirection;
            local v25 = math.rad((v17._rng:NextNumber(-v17.SpreadAngle, v17.SpreadAngle)));
            l_EmissionDirection_0 = Vector2.new(math.cos(v25) * l_EmissionDirection_0.X - math.sin(v25) * l_EmissionDirection_0.Y, math.sin(v25) * l_EmissionDirection_0.X + math.cos(v25) * l_EmissionDirection_0.Y);
            v17.Active = v17.Active + 1;
            v17._particles[v22] = {
                Began = v19, 
                Lifetime = v17._rng:NextNumber(v17.Lifetime.Min, v17.Lifetime.Max), 
                Offset = UDim2.fromScale(v17._rng:NextNumber(), v17._rng:NextNumber()), 
                Direction = l_EmissionDirection_0, 
                Speed = v17._rng:NextNumber(v17.Speed.Min, v17.Speed.Max), 
                Acceleration = v17.Acceleration, 
                Drag = v17.Drag, 
                Rotation = v17._rng:NextNumber(v17.Rotation.Min, v17.Rotation.Max), 
                RotSpeed = v17._rng:NextNumber(v17.RotSpeed.Min, v17.RotSpeed.Max), 
                Instance = l_ImageLabel_0
            };
        end;
        v17._buffer = v20 % 1;
    end;
    for v26, v27 in v17._particles do
        local v28 = v19 - v27.Began;
        local l_Instance_0 = v27.Instance;
        if v27.Lifetime <= v28 then
            l_Instance_0:Destroy();
            v17.Active = v17.Active - 1;
            v17._particles[v26] = nil;
        else
            local v30 = v27.Direction * v27.Speed;
            local l_Acceleration_0 = v27.Acceleration;
            local l_Drag_0 = v27.Drag;
            local v33 = v30 * v28 + 0.5 * l_Acceleration_0 * v28 ^ 2;
            if l_Drag_0 ~= 0 then
                v33 = (1 - 2 ^ (-(v28 * l_Drag_0))) * v30 / l_Drag_0 / 0.6931471805599453 + 0.5 * l_Acceleration_0 * v28 ^ 2;
            end;
            l_Instance_0.Position = v27.Offset + UDim2.fromOffset(v33.X, v33.Y);
            l_Instance_0.Rotation = v27.Rotation + v27.RotSpeed * v28;
            local v34 = v28 / v27.Lifetime;
            local v35 = v3.getNumberSequenceValue(v17.Size, v34);
            l_Instance_0.Size = UDim2.fromOffset(v35, v35);
            l_Instance_0.Image = v17.Texture;
            l_Instance_0.ImageTransparency = v3.getNumberSequenceValue(v17.Transparency, v34);
            l_Instance_0.ImageColor3 = v3.getColorSequenceValue(v17.Color, v34);
            l_Instance_0.Parent = v17._holder;
        end;
    end;
end;
v5.SetScale = function(v36, v37) --[[ Line: 240 ]] --[[ Name: SetScale ]]
    local v38 = {};
    for v39, v40 in v36.Size.Keypoints do
        v38[v39] = NumberSequenceKeypoint.new(v40.Time, v40.Value * v37, v40.Envelope * v37);
    end;
    v36.Size = NumberSequence.new(v38);
end;
v5.Emit = function(v41, v42) --[[ Line: 253 ]] --[[ Name: Emit ]]
    -- upvalues: v4 (copy)
    if v4.Enabled then
        return;
    else
        v41._buffer = v41._buffer + v42;
        v41:_update(0);
        return;
    end;
end;
v5.Clear = function(v43) --[[ Line: 262 ]] --[[ Name: Clear ]]
    for _, v45 in v43._particles do
        v45.Instance:Destroy();
    end;
    table.clear(v43._particles);
end;
v5.Destroy = function(v46) --[[ Line: 270 ]] --[[ Name: Destroy ]]
    v46._connection:Disconnect();
    v46._holder:Destroy();
    v46:Clear();
end;
return v5;
ModuleScript: HeightMap
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_Workspace_0 = game:GetService("Workspace");
local v1 = {};
v1.__index = v1;
v1.new = function(v2, v3) --[[ Line: 38 ]] --[[ Name: new ]]
    -- upvalues: v1 (copy)
    local v4 = {
        _scale = v2, 
        _cache = {}
    };
    local v5 = RaycastParams.new();
    v5.FilterDescendantsInstances = v3;
    v5.FilterType = Enum.RaycastFilterType.Include;
    v4._params = v5;
    return (setmetatable(v4, v1));
end;
v1._sample = function(v6, v7, v8) --[[ Line: 52 ]] --[[ Name: _sample ]]
    -- upvalues: l_Workspace_0 (copy)
    local v9 = Vector3.new(v7, 0, v8);
    local v10 = v6._cache[v9];
    if v10 == nil then
        local v11 = l_Workspace_0:Raycast(Vector3.new(v7 * v6._scale, 300, v8 * v6._scale), Vector3.new(0, -300, 0, 0), v6._params);
        v10 = {
            Height = if v11 then v11.Position.Y else 0
        };
        v6._cache[v9] = v10;
    end;
    return v10.Height;
end;
v1.GetHeight = function(v12, v13) --[[ Line: 72 ]] --[[ Name: GetHeight ]]
    local l__scale_0 = v12._scale;
    return v12:_sample(math.round(v13.X / l__scale_0), (math.round(v13.Z / l__scale_0)));
end;
v1.GetSmoothHeight = function(v15, v16) --[[ Line: 82 ]] --[[ Name: GetSmoothHeight ]]
    local l__scale_1 = v15._scale;
    local v18 = math.floor(v16.X / l__scale_1);
    local v19 = math.floor(v16.Z / l__scale_1);
    local v20 = v15:_sample(v18, v19);
    local v21 = v15:_sample(v18, v19 + 1);
    local v22 = v15:_sample(v18 + 1, v19);
    local v23 = v15:_sample(v18 + 1, v19 + 1);
    local v24 = v16.X % l__scale_1 / l__scale_1;
    local v25 = v16.Z % l__scale_1 / l__scale_1;
    local v26 = v20 + v25 * (v21 - v20);
    return v26 + v24 * (v22 + v25 * (v23 - v22) - v26);
end;
return v1;
ModuleScript: Maid
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {};
v0.__index = v0;
local function v2(v1) --[[ Line: 20 ]] --[[ Name: clean ]]
    if typeof(v1) == "RBXScriptConnection" then
        v1:Disconnect();
        return;
    elseif type(v1) == "function" then
        v1();
        return;
    elseif typeof(v1) == "Instance" then
        v1:Destroy();
        return;
    else
        v1:Cleanup();
        return;
    end;
end;
v0.new = function() --[[ Line: 32 ]] --[[ Name: new ]]
    -- upvalues: v0 (copy)
    return (setmetatable({
        _items = {}
    }, v0));
end;
v0.clean = v2;
v0.Add = function(v3, v4) --[[ Line: 40 ]] --[[ Name: Add ]]
    table.insert(v3._items, v4);
    return #v3._items;
end;
v0.Remove = function(v5, v6) --[[ Line: 45 ]] --[[ Name: Remove ]]
    -- upvalues: v2 (copy)
    for v7 = #v5._items, 1, -1 do
        if v5._items[v7] == v6 then
            table.remove(v5._items, v7);
            v2(v6);
            return;
        end;
    end;
end;
v0.Cleanup = function(v8) --[[ Line: 55 ]] --[[ Name: Cleanup ]]
    -- upvalues: v2 (copy)
    for _, v10 in v8._items do
        v2(v10);
    end;
    table.clear(v8._items);
end;
return v0;
ModuleScript: Pool
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v2 = {};
v2.__index = v2;
local function v3() --[[ Line: 55 ]]

end;
local v4 = v1.optional(v1.string);
v2.new = function(v5, v6) --[[ Line: 59 ]] --[[ Name: new ]]
    -- upvalues: v1 (copy), v3 (copy), v2 (copy)
    assert(v1.callback(v5));
    assert(v1.optional(v1.callback)(v6));
    return (setmetatable({
        _destroyed = false, 
        _constructor = v5, 
        _destructor = v6 or v3, 
        _index = 1, 
        _prevIndex = 0, 
        _unkeyed = {}, 
        _keyed = {}, 
        _usedKeys = {}, 
        _prevUsedKeys = {}, 
        _debugId = nil
    }, v2));
end;
v2.Get = function(v7, v8) --[[ Line: 81 ]] --[[ Name: Get ]]
    -- upvalues: v4 (copy)
    assert(v4(v8));
    assert(not v7._destroyed, "Pool was destroyed");
    local v9 = nil;
    local v10 = nil;
    if v8 == nil then
        v9 = v7._unkeyed[v7._index];
        v10 = v9 == nil;
        if v10 then
            v9 = v7._constructor();
            v7._unkeyed[v7._index] = v9;
        end;
        v7._index = v7._index + 1;
        return v9, v10;
    else
        v9 = v7._keyed[v8];
        v10 = v9 == nil;
        if v10 then
            v9 = v7._constructor();
            v7._keyed[v8] = v9;
        end;
        v7._usedKeys[v8] = true;
        return v9, v10;
    end;
end;
v2._setDebugId = function(v11, v12) --[[ Line: 124 ]] --[[ Name: _setDebugId ]]
    v11._debugId = v12;
end;
v2.Done = function(v13) --[[ Line: 130 ]] --[[ Name: Done ]]
    assert(not v13._destroyed, "Pool was destroyed");
    for v14 = v13._index, v13._prevIndex do
        local v15 = v13._unkeyed[v14];
        v13._destructor(v15);
        v15.Parent = nil;
    end;
    v13._prevIndex = v13._index - 1;
    v13._index = 1;
    for v16, v17 in v13._keyed do
        if not v13._usedKeys[v16] and v13._prevUsedKeys[v16] then
            v13._destructor(v17);
            v17.Parent = nil;
        end;
    end;
    v13._prevUsedKeys = table.clone(v13._usedKeys);
    table.clear(v13._usedKeys);
end;
v2.Destroy = function(v18) --[[ Line: 164 ]] --[[ Name: Destroy ]]
    assert(not v18._destroyed, "Pool was destroyed");
    for v19, v20 in v18._unkeyed do
        if v19 <= v18._prevIndex then
            v18._destructor(v20);
        end;
        v20:Destroy();
    end;
    for v21, v22 in v18._keyed do
        if v18._prevUsedKeys[v21] then
            v18._destructor(v22);
        end;
        v22:Destroy();
    end;
    table.clear(v18._unkeyed);
    table.clear(v18._keyed);
    table.clear(v18._usedKeys);
    table.clear(v18._prevUsedKeys);
    v18._destroyed = true;
end;
return v2;
ModuleScript: Queue
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.every);
local v2 = {};
v2.__index = v2;
v2.new = function() --[[ Line: 34 ]] --[[ Name: new ]]
    -- upvalues: v2 (copy), v1 (copy)
    local v3 = setmetatable({
        _queue = {}, 
        _id = 0, 
        HasActive = false
    }, v2);
    v3._connection = v1(0.15, function() --[[ Line: 41 ]]
        -- upvalues: v3 (copy)
        v3:Pop();
    end);
    return v3;
end;
v2.Push = function(v4, v5, v6) --[[ Line: 49 ]] --[[ Name: Push ]]
    table.insert(v4._queue, {
        Duration = v5, 
        Callback = v6
    });
    v4:Pop();
end;
v2.Pop = function(v7) --[[ Line: 58 ]] --[[ Name: Pop ]]
    if v7.HasActive or #v7._queue == 0 then
        return;
    else
        local v8 = table.remove(v7._queue, 1);
        if not v8 then
            return;
        else
            local v9 = v7._id + 1;
            v7._id = v9;
            v7.HasActive = true;
            task.defer(function() --[[ Line: 69 ]]
                -- upvalues: v8 (copy)
                local v10 = v8.Callback();
                task.wait(v8.Duration);
                if v10 then
                    v10();
                end;
            end);
            task.delay(v8.Duration, function() --[[ Line: 76 ]]
                -- upvalues: v7 (copy), v9 (copy)
                if v7._id == v9 then
                    v7.HasActive = false;
                end;
            end);
            return;
        end;
    end;
end;
v2.Next = function(v11) --[[ Line: 83 ]] --[[ Name: Next ]]
    v11._id = v11._id + 1;
    v11.HasActive = false;
    v11:Pop();
end;
v2.Clear = function(v12) --[[ Line: 90 ]] --[[ Name: Clear ]]
    table.clear(v12._queue);
end;
v2.Destroy = function(v13) --[[ Line: 95 ]] --[[ Name: Destroy ]]
    v13:Clear();
    v13._connection:Disconnect();
end;
return v2;
ModuleScript: Signal
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {};
v0.__index = v0;
v0.new = function() --[[ Line: 22 ]] --[[ Name: new ]]
    -- upvalues: v0 (copy)
    return (setmetatable({
        _bindable = Instance.new("BindableEvent")
    }, v0));
end;
v0.Connect = function(v1, v2) --[[ Line: 28 ]] --[[ Name: Connect ]]
    return v1._bindable.Event:Connect(v2);
end;
v0.Once = function(v3, v4) --[[ Line: 32 ]] --[[ Name: Once ]]
    return v3._bindable.Event:Once(v4);
end;
v0.Fire = function(v5, ...) --[[ Line: 36 ]] --[[ Name: Fire ]]
    v5._bindable:Fire(...);
end;
v0.Destroy = function(v6) --[[ Line: 40 ]] --[[ Name: Destroy ]]
    v6._bindable:Destroy();
end;
v0.Clear = function(v7) --[[ Line: 44 ]] --[[ Name: Clear ]]
    v7._bindable:Destroy();
    v7._bindable = Instance.new("BindableEvent");
end;
return v0;
ModuleScript: Spring
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_Heartbeat_0 = game:GetService("RunService").Heartbeat;
local v1 = {};
v1.__index = v1;
v1.new = function(v2) --[[ Line: 36 ]] --[[ Name: new ]]
    -- upvalues: v1 (copy), l_Heartbeat_0 (copy)
    v2 = v2 or Vector3.new();
    local v3 = setmetatable({
        Friction = 1, 
        Stiffness = 4, 
        Target = v2, 
        Value = v2, 
        Velocity = v2 * 0
    }, v1);
    v3._connection = l_Heartbeat_0:Connect(function(v4) --[[ Line: 47 ]]
        -- upvalues: v3 (copy)
        v3:_update(v4);
    end);
    return v3;
end;
v1._update = function(v5, v6) --[[ Line: 54 ]] --[[ Name: _update ]]
    local l_Friction_0 = v5.Friction;
    local v8 = v5.Stiffness * 2 * 3.141592653589793;
    local l_Target_0 = v5.Target;
    local l_Value_0 = v5.Value;
    local l_Velocity_0 = v5.Velocity;
    local v12 = l_Value_0 - l_Target_0;
    local v13 = math.exp(-l_Friction_0 * v8 * v6);
    local v14 = nil;
    local v15 = nil;
    if l_Friction_0 == 1 then
        v14 = (v12 * (1 + v8 * v6) + l_Velocity_0 * v6) * v13 + l_Target_0;
        v15 = (l_Velocity_0 * (1 - v8 * v6) - v12 * (v8 * v8 * v6)) * v13;
    elseif l_Friction_0 < 1 then
        local v16 = math.sqrt(1 - l_Friction_0 * l_Friction_0);
        local v17 = math.cos(v8 * v16 * v6);
        local v18 = math.sin(v8 * v16 * v6);
        local v19 = nil;
        if v16 > 1.0E-4 then
            v19 = v18 / v16;
        else
            local v20 = v6 * v8;
            v19 = v20 + (v20 * v20 * (v16 * v16) * (v16 * v16) / 20 - v16 * v16) * (v20 * v20 * v20) / 6;
        end;
        local v21 = nil;
        if v8 * v16 > 1.0E-4 then
            v21 = v18 / (v8 * v16);
        else
            local v22 = v8 * v16;
            v21 = v6 + (v6 * v6 * (v22 * v22) * (v22 * v22) / 20 - v22 * v22) * (v6 * v6 * v6) / 6;
        end;
        v14 = (v12 * (v17 + l_Friction_0 * v19) + l_Velocity_0 * v21) * v13 + l_Target_0;
        v15 = (l_Velocity_0 * (v17 - v19 * l_Friction_0) - v12 * (v19 * v8)) * v13;
    else
        local v23 = math.sqrt(l_Friction_0 * l_Friction_0 - 1);
        local v24 = -v8 * (l_Friction_0 - v23);
        local v25 = -v8 * (l_Friction_0 + v23);
        local v26 = (l_Velocity_0 - v12 * v24) / (2 * v8 * v23);
        local v27 = (v12 - v26) * math.exp(v24 * v6);
        local v28 = v26 * math.exp(v25 * v6);
        v14 = v27 + v28 + l_Target_0;
        v15 = v27 * v24 + v28 * v25;
    end;
    v5.Value = v14;
    v5.Velocity = v15;
end;
v1.Clone = function(v29) --[[ Line: 116 ]] --[[ Name: Clone ]]
    -- upvalues: v1 (copy)
    local v30 = v1.new(v29.Value);
    v30.Friction = v29.Friction;
    v30.Stiffness = v29.Stiffness;
    v30.Target = v29.Target;
    v30.Value = v29.Value;
    v30.Velocity = v29.Velocity;
    return v30;
end;
v1.Destroy = function(v31) --[[ Line: 126 ]] --[[ Name: Destroy ]]
    v31._connection:Disconnect();
end;
return v1;
ModuleScript:WorldEmitter
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_Workspace_0 = game:GetService("Workspace");
local l_RunService_0 = game:GetService("RunService");
local l_HttpService_0 = game:GetService("HttpService");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = game:GetService("PhysicsService");
local v5 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.SequenceUtil);
local v6 = require(l_ReplicatedStorage_0.Client.LowDetail);
local l_Folder_0 = Instance.new("Folder");
l_Folder_0.Name = "WorldEmitters";
if l_RunService_0:IsServer() then
    l_Folder_0.Parent = l_Workspace_0;
else
    local l_WorldEmitters_0 = l_Workspace_0:FindFirstChild("WorldEmitters");
    if l_WorldEmitters_0 ~= nil then
        l_Folder_0 = l_WorldEmitters_0;
    else
        local v9 = nil;
        do
            local l_v9_0 = v9;
            l_v9_0 = l_Workspace_0.ChildAdded:Connect(function(v11) --[[ Line: 29 ]]
                -- upvalues: l_Folder_0 (ref), l_v9_0 (ref)
                if v11:IsA("Folder") and v11.Name == "WorldEmitters" then
                    for _, v13 in l_Folder_0:GetChildren() do
                        v13.Parent = v11;
                    end;
                    l_Folder_0 = v11;
                    l_v9_0:Disconnect();
                end;
            end);
        end;
    end;
end;
local v14 = {};
v14.__index = v14;
local v15 = {
    Enabled = true, 
    Origin = CFrame.new(), 
    Lifetime = NumberRange.new(1, 2), 
    Rate = 10, 
    Radius = NumberRange.new(0), 
    Speed = NumberRange.new(25, 50), 
    SpreadAngle = 0, 
    GravityMultiplier = NumberRange.new(1)
};
v14.CollisionGroupName = "Particles";
v14.new = function(v16) --[[ Line: 109 ]] --[[ Name: new ]]
    -- upvalues: v15 (copy), v14 (copy), l_RunService_0 (copy), l_Folder_0 (ref)
    local v17 = setmetatable(table.clone(v15), v14);
    v17._connection = l_RunService_0.Heartbeat:Connect(function(v18) --[[ Line: 112 ]]
        -- upvalues: v17 (copy)
        v17:_update(v18);
    end);
    v17._particles = {};
    v17._buffer = 0;
    v17._rng = Random.new();
    local v19 = v16:Clone();
    if v19:IsA("Model") then
        for _, v21 in v19:GetDescendants() do
            if v21:IsA("BasePart") then
                v21.CollisionGroup = "Particles";
            end;
        end;
    else
        v19.CollisionGroup = "Particles";
    end;
    local l_Folder_1 = Instance.new("Folder");
    l_Folder_1.Name = "Emitter";
    l_Folder_1.Parent = l_Folder_0;
    v17._folder = l_Folder_1;
    v17._template = v19;
    return v17;
end;
v14._updateParticleTransparency = function(v23, v24, v25) --[[ Line: 141 ]] --[[ Name: _updateParticleTransparency ]]
    -- upvalues: v5 (copy)
    local v26 = math.clamp(v25 / v24.Lifetime, 0, 1);
    if v23.Transparency then
        local v27 = v5.getNumberSequenceValue(v23.Transparency, v26);
        for v28, v29 in v24.BaseParts do
            v28.Transparency = 1 - (1 - v29.Transparency) * (1 - v27);
        end;
        for v30, v31 in v24.Trails do
            local l_Keypoints_0 = v31.Transparency.Keypoints;
            for v33, v34 in l_Keypoints_0 do
                l_Keypoints_0[v33] = NumberSequenceKeypoint.new(v34.Time, 1 - (1 - v34.Value) * (1 - v27), v34.Envelope);
            end;
            v30.Transparency = NumberSequence.new(l_Keypoints_0);
        end;
    end;
end;
v14._update = function(v35, v36) --[[ Line: 168 ]] --[[ Name: _update ]]
    -- upvalues: l_HttpService_0 (copy), l_Workspace_0 (copy)
    local v37 = os.clock();
    if v35.Enabled then
        local v38 = v35._buffer + v36 * v35.Rate;
        for _ = 1, math.floor(v38) do
            local v40 = l_HttpService_0:GenerateGUID(false);
            local v41 = v35._template:Clone();
            local v42 = nil;
            if v41:IsA("Model") then
                for _, v44 in v41:GetDescendants() do
                    if v44:IsA("BasePart") then
                        v42 = v44:GetRootPart();
                        break;
                    end;
                end;
            else
                v42 = v41;
            end;
            assert(v42 ~= nil, string.format("WorldEmitter template '%s' has no assembly root", v35._template.Name));
            if v42:CanSetNetworkOwnership() then
                v42:SetNetworkOwner(nil);
            end;
            local l_Origin_0 = v35.Origin;
            local v46 = v35._rng:NextNumber() * (v35.Radius.Max - v35.Radius.Min) + v35.Radius.Min;
            local v47 = v35._rng:NextNumber() * 3.141592653589793 * 2;
            l_Origin_0 = l_Origin_0 * CFrame.Angles(0, 0, v35._rng:NextNumber(0, 6.283185307179586)) * CFrame.Angles(math.rad((v35._rng:NextNumber(-v35.SpreadAngle, v35.SpreadAngle))), 0, 0) + Vector3.new(math.sin(v47) * v46, 0, math.cos(v47) * v46);
            v41:PivotTo(l_Origin_0);
            local v48 = v35._rng:NextNumber(v35.GravityMultiplier.Min, v35.GravityMultiplier.Max);
            if v48 ~= 1 then
                local v49 = l_Workspace_0.Gravity * v42.AssemblyMass * (1 - v48);
                local l_Attachment_0 = Instance.new("Attachment");
                l_Attachment_0.Parent = v42;
                local l_VectorForce_0 = Instance.new("VectorForce");
                l_VectorForce_0.Attachment0 = l_Attachment_0;
                l_VectorForce_0.RelativeTo = Enum.ActuatorRelativeTo.World;
                l_VectorForce_0.ApplyAtCenterOfMass = true;
                l_VectorForce_0.Force = Vector3.new(0, v49, 0);
                l_VectorForce_0.Parent = v42;
            end;
            local l_v41_Descendants_0 = v41:GetDescendants();
            table.insert(l_v41_Descendants_0, v41);
            local v53 = {};
            local v54 = {};
            for _, v56 in l_v41_Descendants_0 do
                if v56:IsA("BasePart") then
                    v53[v56] = {
                        Transparency = v56.Transparency
                    };
                elseif v56:IsA("Trail") then
                    v54[v56] = {
                        Transparency = v56.Transparency
                    };
                end;
            end;
            local v57 = {
                Instance = v41, 
                BaseParts = v53, 
                Trails = v54, 
                Root = v42, 
                Began = v37, 
                Lifetime = v35._rng:NextNumber(v35.Lifetime.Min, v35.Lifetime.Max)
            };
            v35:_updateParticleTransparency(v57, 0);
            v41.Parent = v35._folder;
            local v58 = v35._rng:NextNumber(v35.Speed.Min, v35.Speed.Max);
            v42.AssemblyLinearVelocity = l_Origin_0.LookVector * v58;
            v35._particles[v40] = v57;
        end;
        v35._buffer = v38 % 1;
    end;
    for v59, v60 in v35._particles do
        local v61 = v37 - v60.Began;
        local l_Instance_0 = v60.Instance;
        if v60.Lifetime <= v61 then
            l_Instance_0:Destroy();
            v35._particles[v59] = nil;
        else
            v35:_updateParticleTransparency(v60, v61);
        end;
    end;
end;
v14.Emit = function(v63, v64) --[[ Line: 269 ]] --[[ Name: Emit ]]
    -- upvalues: v6 (copy)
    if v6.Enabled then
        return;
    else
        v63._buffer = v63._buffer + v64;
        v63:_update(0);
        return;
    end;
end;
v14.Clear = function(v65) --[[ Line: 279 ]] --[[ Name: Clear ]]
    for _, v67 in v65._particles do
        v67.Instance:Destroy();
    end;
    table.clear(v65._particles);
end;
v14.Destroy = function(v68) --[[ Line: 287 ]] --[[ Name: Destroy ]]
    v68._connection:Disconnect();
    v68._folder:Destroy();
    v68:Clear();
end;
return v14;
ModuleScript: Zone 
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.PolygonGeometry);
local v2 = {};
v2.__index = v2;
local function v12(v3) --[[ Line: 42 ]] --[[ Name: new ]]
    -- upvalues: v1 (copy), v2 (copy)
    local v4 = v1.flatten(v3);
    local v5 = v1.orderCCW(v4);
    assert(v1.isSimple(v5), "zone region is self-intersecting");
    local v6 = v1.isConvex(v5);
    local v7 = if v6 then v1.triangulateFan(v5) else v1.triangulateEarClip(v5);
    local v8 = table.create(#v7);
    for v9, v10 in v7 do
        local v11 = v1.getTriangleArea(unpack(v10));
        v8[v9] = {
            Points = v10, 
            Area = v11
        };
    end;
    return (setmetatable({
        Height = v3[1].Y, 
        _random = Random.new(), 
        _points = v5, 
        _convex = v6, 
        _triangles = v8
    }, v2));
end;
v2.fromOrderedPoints = function(v13) --[[ Line: 71 ]] --[[ Name: fromOrderedPoints ]]
    -- upvalues: v12 (copy)
    return (v12(table.clone(v13)));
end;
v2.fromUnorderedPoints = function(v14) --[[ Line: 76 ]] --[[ Name: fromUnorderedPoints ]]
    -- upvalues: v12 (copy), v1 (copy)
    return (v12(v1.getConvexHull(v14)));
end;
local function _(v15) --[[ Line: 80 ]] --[[ Name: hidePart ]]
    v15.Transparency = 1;
    v15.CastShadow = false;
    v15.CanCollide = false;
    v15.CanTouch = false;
    v15.CanQuery = false;
end;
v2.fromPointsFolder = function(v17) --[[ Line: 88 ]] --[[ Name: fromPointsFolder ]]
    -- upvalues: v2 (copy)
    local v18 = {};
    for _, v20 in v17:GetChildren() do
        if v20:IsA("BasePart") and string.match(v20.Name, "^%d+$") then
            table.insert(v18, {
                part = v20, 
                index = tonumber(v20.Name)
            });
        end;
    end;
    table.sort(v18, function(v21, v22) --[[ Line: 99 ]]
        return v21.index < v22.index;
    end);
    assert(#v18 >= 3, (("not enough parts (%*)"):format((v17:GetFullName()))));
    local v23 = {};
    for v24, v25 in v18 do
        assert(v25.index == v24, (("malformed zone points (%*"):format((v17:GetFullName()))));
        local l_part_0 = v25.part;
        l_part_0.Transparency = 1;
        l_part_0.CastShadow = false;
        l_part_0.CanCollide = false;
        l_part_0.CanTouch = false;
        l_part_0.CanQuery = false;
        v23[v24] = l_part_0.Position - Vector3.new(0, 1, 0, 0) * l_part_0.Size.Y / 2;
    end;
    return v2.fromOrderedPoints(v23);
end;
v2.fromPart = function(v27) --[[ Line: 118 ]] --[[ Name: fromPart ]]
    -- upvalues: v12 (copy)
    local l_CFrame_0 = v27.CFrame;
    local v29 = v27.Size / 2;
    v27.Transparency = 1;
    v27.CastShadow = false;
    v27.CanCollide = false;
    v27.CanTouch = false;
    v27.CanQuery = false;
    return (v12({
        l_CFrame_0 * Vector3.new(v29.X, 0, v29.Z), 
        l_CFrame_0 * Vector3.new(v29.X, 0, -v29.Z), 
        l_CFrame_0 * Vector3.new(-v29.X, 0, -v29.Z), 
        l_CFrame_0 * Vector3.new(-v29.X, 0, v29.Z)
    }));
end;
v2.IsPointInside = function(v30, v31) --[[ Line: 133 ]] --[[ Name: IsPointInside ]]
    -- upvalues: v1 (copy)
    local v32 = v31 * Vector3.new(1, 0, 1, 0);
    if v30._convex then
        return (v1.testPointHull(v30._points, v32));
    else
        return (v1.testPointPolygon(v30._points, v32));
    end;
end;
v2.GetTriangles = function(v33) --[[ Line: 142 ]] --[[ Name: GetTriangles ]]
    local v34 = {};
    for v35, v36 in v33._triangles do
        v34[v35] = table.clone(v36.Points);
    end;
    return v34;
end;
v2.GetDistanceToPoint = function(v37, v38) --[[ Line: 152 ]] --[[ Name: GetDistanceToPoint ]]
    -- upvalues: v1 (copy)
    local v39 = v38 * Vector3.new(1, 0, 1, 0);
    if v37:IsPointInside(v39) then
        return 0;
    else
        local v40 = 1e999;
        for v41, v42 in v37._points do
            local v43 = v37._points[v41 % #v37._points + 1];
            local v44 = v1.getSegmentPointDistance(v42, v43, v39);
            if v44 < v40 then
                v40 = v44;
            end;
        end;
        return v40;
    end;
end;
v2.GetRandomPoint = function(v45) --[[ Line: 171 ]] --[[ Name: GetRandomPoint ]]
    local v46 = 0;
    for _, v48 in v45._triangles do
        v46 = v46 + v48.Area;
    end;
    local v49 = v45._random:NextNumber(0, v46);
    local v50 = v45._triangles[1];
    for _, v52 in v45._triangles do
        if v49 < v52.Area then
            v50 = v52;
            break;
        else
            v49 = v49 - v52.Area;
        end;
    end;
    local v53, v54, v55 = unpack(v50.Points);
    local v56 = v45._random:NextNumber(0, 1);
    local v57 = v45._random:NextNumber(0, 1);
    if v56 + v57 > 1 then
        v56 = 1 - v56;
        v57 = 1 - v57;
    end;
    return v53 + (v54 - v53) * v56 + (v55 - v53) * v57;
end;
v2.GetRandomPointInCircle = function(v58, v59, v60) --[[ Line: 199 ]] --[[ Name: GetRandomPointInCircle ]]
    local v61 = nil;
    repeat
        local v62 = v58._random:NextNumber(0, 6.283185307179586);
        v61 = v59 + v60 * Vector3.new(math.sin(v62), 0, (math.cos(v62)));
    until v58:IsPointInside(v61);
    return v61;
end;
local function _(v63, v64, v65) --[[ Line: 211 ]] --[[ Name: closestPointSegment ]]
    local v66 = v64 - v63;
    return v63 + math.clamp((v65 - v63):Dot(v66) / v66:Dot(v66), 0, 1) * v66;
end;
local function v78(v68, v69) --[[ Line: 218 ]] --[[ Name: getClosestEdgePoint ]]
    local v70 = nil;
    local v71 = nil;
    local v72 = 1e999;
    for v73 = 1, #v68._points do
        local v74 = v68._points[v73];
        local v75 = v68._points[v73 % #v68._points + 1];
        local v76 = v75 - v74;
        local v77 = v74 + math.clamp((v69 - v74):Dot(v76) / v76:Dot(v76), 0, 1) * v76;
        v76 = (v77 - v69).Magnitude;
        if v76 < v72 then
            v70 = v77;
            v71 = v75 - v74;
            v72 = v76;
        end;
    end;
    if not v70 then
        v70 = v68._points[1];
        v71 = v68._points[2] - v68._points[1];
    end;
    return v70 + Vector3.new(0, v68.Height, 0), v71;
end;
v2.GetClosestPoint = function(v79, v80) --[[ Line: 243 ]] --[[ Name: GetClosestPoint ]]
    -- upvalues: v78 (copy)
    if v79:IsPointInside(v80) then
        return v80 * Vector3.new(1, 0, 1, 0) + Vector3.new(0, v79.Height, 0);
    else
        return (v78(v79, v80));
    end;
end;
v2.GetClosestEdgePoint = function(v81, v82) --[[ Line: 250 ]] --[[ Name: GetClosestEdgePoint ]]
    -- upvalues: v78 (copy)
    return v78(v81, v82);
end;
return v2;
ModuleScript: Bindable
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Signal);
local v3 = {
    Signals = {}, 
    Functions = {}
};
v3.Event = function(v4) --[[ Line: 24 ]] --[[ Name: Event ]]
    -- upvalues: v1 (copy), v3 (copy), v2 (copy)
    assert(v1.string(v4));
    local v5 = v3.Signals[v4];
    if not v5 then
        v5 = v2.new();
        v3.Signals[v4] = v5;
    end;
    return v5;
end;
v3.Function = function(v6, v7) --[[ Line: 40 ]] --[[ Name: Function ]]
    -- upvalues: v1 (copy), v3 (copy)
    assert(v1.string(v6));
    assert(v1.callback(v7));
    assert(v3.Functions[v6] == nil, (("function already bound to '%*'"):format(v6)));
    v3.Functions[v6] = v7;
end;
v3.Fire = function(_, v9, ...) --[[ Line: 56 ]] --[[ Name: Fire ]]
    -- upvalues: v1 (copy), v3 (copy)
    assert(v1.string(v9));
    assert(v3.Signals[v9], (("no event signal for action '%*'"):format(v9)));
    v3.Signals[v9]:Fire(...);
end;
v3.Invoke = function(_, v11, ...) --[[ Line: 71 ]] --[[ Name: Invoke ]]
    -- upvalues: v1 (copy), v3 (copy)
    assert(v1.string(v11));
    assert(v3.Functions[v11], (("no function bound to '%*'"):format(v11)));
    return v3.Functions[v11](...);
end;
v3.WaitForFunction = function(_, v13, v14) --[[ Line: 88 ]] --[[ Name: WaitForFunction ]]
    -- upvalues: v3 (copy)
    local v15 = os.time();
    if not v3.Functions[v13] then
        repeat
            task.wait();
        until os.time() - v15 > (v14 or 10) or v3.Functions[v13];
    end;
    if v3.Functions[v13] == nil then
        warn((("Bindable exhausted while waiting for %* after %* seconds"):format(v13, (math.round(os.time() - v15)))));
        return nil;
    else
        return v3.Functions[v13];
    end;
end;
return v3;
ModuleScript: Remote
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_RunService_0 = game:GetService("RunService");
local _ = game:GetService("Players");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = game:GetService("ServerScriptService");
local v4 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v5 = v4.instanceOf("Player");
local v6 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Signal);
local l_Event_0 = script.Event;
local l_Function_0 = script.Function;
local v9 = {};
local v10 = {};
local v11 = {};
v9.Event = function(v12) --[[ Line: 21 ]] --[[ Name: Event ]]
    -- upvalues: v4 (copy), v10 (copy), v6 (copy), l_RunService_0 (copy), l_Event_0 (copy)
    assert(v4.string(v12));
    local v13 = v10[v12];
    if not v13 then
        v13 = v6.new();
        v10[v12] = v13;
        if l_RunService_0:IsServer() then
            l_Event_0.OnServerEvent:Connect(function(v14, v15, ...) --[[ Line: 29 ]]
                -- upvalues: v12 (copy), v13 (ref)
                if v12 == v15 then
                    v13:Fire(v14, ...);
                end;
            end);
        else
            l_Event_0.OnClientEvent:Connect(function(v16, ...) --[[ Line: 35 ]]
                -- upvalues: v12 (copy), v13 (ref)
                if v12 == v16 then
                    v13:Fire(...);
                end;
            end);
        end;
    end;
    return v13;
end;
v9.Function = function(v17, v18) --[[ Line: 46 ]] --[[ Name: Function ]]
    -- upvalues: v4 (copy), v11 (copy), l_RunService_0 (copy)
    assert(v4.string(v17));
    assert(v4.callback(v18));
    assert(v11[v17] == nil, (("%* network binding for job '%*' already exists"):format(l_RunService_0:IsServer() and "server" or "client", v17)));
    v11[v17] = v18;
end;
v9.FireServer = function(_, v20, ...) --[[ Line: 57 ]] --[[ Name: FireServer ]]
    -- upvalues: v4 (copy), l_Event_0 (copy)
    assert(v4.string(v20));
    l_Event_0:FireServer(v20, ...);
end;
v9.FireClient = function(_, v22, v23, ...) --[[ Line: 66 ]] --[[ Name: FireClient ]]
    -- upvalues: v5 (copy), v4 (copy), l_Event_0 (copy)
    assert(v5(v22));
    assert(v4.string(v23));
    l_Event_0:FireClient(v22, v23, ...);
end;
v9.FireAllClients = function(_, v25, ...) --[[ Line: 77 ]] --[[ Name: FireAllClients ]]
    -- upvalues: v4 (copy), l_Event_0 (copy)
    assert(v4.string(v25));
    l_Event_0:FireAllClients(v25, ...);
end;
v9.InvokeServer = function(_, v27, ...) --[[ Line: 85 ]] --[[ Name: InvokeServer ]]
    -- upvalues: v4 (copy), l_Function_0 (copy)
    assert(v4.string(v27));
    return l_Function_0:InvokeServer(v27, ...);
end;
v9.InvokeClient = function(_, v29, v30, ...) --[[ Line: 94 ]] --[[ Name: InvokeClient ]]
    -- upvalues: v5 (copy), v4 (copy), l_Function_0 (copy)
    assert(v5(v29));
    assert(v4.string(v30));
    return l_Function_0:InvokeClient(v29, v30, ...);
end;
if l_RunService_0:IsServer() then
    local _ = game:GetService("ServerScriptService");
    l_Function_0.OnServerInvoke = function(v32, v33, ...) --[[ Line: 126 ]]
        -- upvalues: v11 (copy)
        if type(v33) == "string" then
            local v34 = v11[v33];
            if v34 == nil then
                warn((("no server '%*' binding"):format(v33)));
                return;
            else
                return v34(v32, ...);
            end;
        else
            return;
        end;
    end;
    return v9;
else
    l_Function_0.OnClientInvoke = function(v35, ...) --[[ Line: 138 ]]
        -- upvalues: v11 (copy)
        if type(v35) == "string" then
            local v36 = v11[v35];
            if v36 == nil then
                warn((("no client '%*' binding"):format(v35)));
                return;
            else
                return v36(...);
            end;
        else
            return;
        end;
    end;
    return v9;
end;
ModuleScript: CollisionGroup
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_Players_0 = game:GetService("Players");
local l_RunService_0 = game:GetService("RunService");
local l_PhysicsService_0 = game:GetService("PhysicsService");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v4 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v5 = v4.instanceIsA("Model");
local v6 = v4.instanceIsA("Folder");
local v7 = v4.instanceIsA("BasePart");
local v32 = {
    Groups = {}, 
    Create = function(v8, v9) --[[ Line: 24 ]] --[[ Name: Create ]]
        -- upvalues: v4 (copy), l_PhysicsService_0 (copy)
        assert(v4.string(v9));
        assert(v8.Groups[v9] == nil, string.format("CollisionGroup of name '%s' already exists", v9));
        l_PhysicsService_0:RegisterCollisionGroup(v9);
        v8.Groups[v9] = true;
    end, 
    AddModel = function(v10, v11, v12) --[[ Line: 35 ]] --[[ Name: AddModel ]]
        -- upvalues: v5 (copy), v6 (copy), v4 (copy)
        assert(v5(v11) or v6(v11));
        assert(v4.string(v12));
        assert(v10.Groups[v12] ~= nil, string.format("CollisionGroup of name '%s' not found", v12));
        for _, v14 in v11:GetDescendants() do
            if v14:IsA("BasePart") then
                v14.CollisionGroup = v12;
            end;
        end;
        local v15 = nil;
        local v17 = v11.DescendantAdded:Connect(function(v16) --[[ Line: 51 ]]
            -- upvalues: v12 (copy)
            if v16:IsA("BasePart") then
                v16.CollisionGroup = v12;
            end;
        end);
        v15 = v11.AncestryChanged:Connect(function(_, v19) --[[ Line: 56 ]]
            -- upvalues: v15 (ref), v17 (copy)
            if v19 == nil then
                v15:Disconnect();
                v17:Disconnect();
            end;
        end);
    end, 
    AddBasePart = function(v20, v21, v22) --[[ Line: 65 ]] --[[ Name: AddBasePart ]]
        -- upvalues: v7 (copy), v4 (copy)
        assert(v7(v21));
        assert(v4.string(v22));
        assert(v20.Groups[v22] ~= nil, string.format("CollisionGroup of name '%s' not found", v22));
        v21.CollisionGroup = v22;
    end, 
    SetGroupCollidable = function(v23, v24, v25, v26) --[[ Line: 79 ]] --[[ Name: SetGroupCollidable ]]
        -- upvalues: v4 (copy), l_PhysicsService_0 (copy)
        assert(v4.string(v24));
        assert(v4.string(v25));
        assert(v4.boolean(v26));
        assert(v23.Groups[v24] ~= nil, string.format("CollisionGroup of name '%s' not found", v24));
        assert(v23.Groups[v25] ~= nil, string.format("CollisionGroup of name '%s' not found", v25));
        l_PhysicsService_0:CollisionGroupSetCollidable(v24, v25, v26);
    end, 
    SetGroupsCollidable = function(v27, v28, v29, v30) --[[ Line: 98 ]] --[[ Name: SetGroupsCollidable ]]
        -- upvalues: v4 (copy), l_PhysicsService_0 (copy)
        assert(v4.string(v28));
        assert(v4.table(v29));
        assert(v4.boolean(v30));
        assert(v27.Groups[v28] ~= nil, string.format("CollisionGroup of name '%s' not found", v28));
        for v31 = 1, #v29 do
            assert(v27.Groups[v29[v31]] ~= nil, string.format("CollisionGroup of name '%s' not found", v29[v31]));
            l_PhysicsService_0:CollisionGroupSetCollidable(v28, v29[v31], v30);
        end;
    end, 
    CharactersGroupName = "Characters"
};
if l_RunService_0:IsServer() then
    local v33 = {};
    v32:Create("Characters");
    v32:SetGroupCollidable("Characters", "Characters", false);
    local function v36(v34) --[[ Line: 128 ]] --[[ Name: playerAdded ]]
        -- upvalues: v32 (copy), v33 (copy)
        if v34.Character then
            v32:AddModel(v34.Character, "Characters");
        end;
        v33[v34] = v34.CharacterAdded:Connect(function(v35) --[[ Line: 132 ]]
            -- upvalues: v32 (ref)
            v32:AddModel(v35, "Characters");
        end);
    end;
    local function v38(v37) --[[ Line: 137 ]] --[[ Name: playerRemoving ]]
        -- upvalues: v33 (copy)
        if v33[v37] then
            v33[v37]:Disconnect();
            v33[v37] = nil;
        end;
    end;
    for _, v40 in l_Players_0:GetPlayers() do
        if v40.Character then
            v32:AddModel(v40.Character, "Characters");
        end;
        v33[v40] = v40.CharacterAdded:Connect(function(v41) --[[ Line: 132 ]]
            -- upvalues: v32 (copy)
            v32:AddModel(v41, "Characters");
        end);
    end;
    l_Players_0.PlayerAdded:Connect(v36);
    l_Players_0.PlayerRemoving:Connect(v38);
    return v32;
else
    for _, v43 in l_PhysicsService_0:GetRegisteredCollisionGroups() do
        v32.Groups[v43.name] = true;
    end;
    return v32;
end;
ModuleScript: Cache
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0) --[[ Line: 3 ]] --[[ Name: Cache ]]
    local v1 = {};
    return function(v2) --[[ Line: 6 ]]
        -- upvalues: v1 (copy), v0 (copy)
        local v3 = v1[v2];
        if v3 ~= nil then
            return v3;
        else
            local v4 = v0(v2);
            v1[v2] = v4;
            return v4;
        end;
    end;
end;
ModuleScript: CharacterUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v6 = {
    IsAlive = function(_, v1) --[[ Line: 6 ]] --[[ Name: IsAlive ]]
        if not v1.Parent then
            return false;
        else
            local l_Character_0 = v1.Character;
            if not l_Character_0 then
                return false;
            elseif not l_Character_0:FindFirstChild("HumanoidRootPart") then
                return false;
            else
                local l_Humanoid_0 = l_Character_0:FindFirstChild("Humanoid");
                if not l_Humanoid_0 or l_Humanoid_0.Health <= 0 then
                    return false;
                else
                    return true;
                end;
            end;
        end;
    end, 
    GetCharacter = function(_, v5) --[[ Line: 29 ]] --[[ Name: GetCharacter ]]
        if not v5.Parent then
            return nil;
        else
            return v5.Character;
        end;
    end
};
local v7 = {
    "Head", 
    "UpperTorso", 
    "LowerTorso", 
    "HumanoidRootPart", 
    "LeftUpperArm", 
    "LeftLowerArm", 
    "LeftHand", 
    "RightUpperArm", 
    "RightLowerArm", 
    "RightHand", 
    "LeftUpperLeg", 
    "LeftLowerLeg", 
    "LeftFoot", 
    "RightUpperLeg", 
    "RightLowerLeg", 
    "RightFoot"
};
v6.GetRig = function(_, v9) --[[ Line: 64 ]] --[[ Name: GetRig ]]
    -- upvalues: v6 (copy), v7 (copy)
    local l_v6_Character_0 = v6:GetCharacter(v9);
    if not l_v6_Character_0 then
        return nil;
    else
        for _, v12 in v7 do
            local l_l_v6_Character_0_FirstChild_0 = l_v6_Character_0:FindFirstChild(v12);
            if not l_l_v6_Character_0_FirstChild_0 or not l_l_v6_Character_0_FirstChild_0:IsA("BasePart") then
                return nil;
            end;
        end;
        if not v6:GetHumanoid(v9) then
            return nil;
        else
            return l_v6_Character_0;
        end;
    end;
end;
v6.GetRootPart = function(_, v15) --[[ Line: 85 ]] --[[ Name: GetRootPart ]]
    -- upvalues: v6 (copy)
    local l_v6_Character_1 = v6:GetCharacter(v15);
    if not l_v6_Character_1 then
        return nil;
    else
        local l_HumanoidRootPart_0 = l_v6_Character_1:FindFirstChild("HumanoidRootPart");
        if not l_HumanoidRootPart_0 or not l_HumanoidRootPart_0:IsA("BasePart") then
            return nil;
        else
            return l_HumanoidRootPart_0;
        end;
    end;
end;
v6.GetHumanoid = function(_, v19) --[[ Line: 99 ]] --[[ Name: GetHumanoid ]]
    -- upvalues: v6 (copy)
    local l_v6_Character_2 = v6:GetCharacter(v19);
    if not l_v6_Character_2 then
        return nil;
    else
        local l_Humanoid_1 = l_v6_Character_2:FindFirstChild("Humanoid");
        if not l_Humanoid_1 or not l_Humanoid_1:IsA("Humanoid") then
            return nil;
        else
            return l_Humanoid_1;
        end;
    end;
end;
v6.GetAnimator = function(_, v23) --[[ Line: 113 ]] --[[ Name: GetAnimator ]]
    -- upvalues: v6 (copy)
    local l_v6_Humanoid_0 = v6:GetHumanoid(v23);
    if not l_v6_Humanoid_0 then
        return nil;
    else
        local l_Animator_0 = l_v6_Humanoid_0:FindFirstChild("Animator");
        if not l_Animator_0 or not l_Animator_0:IsA("Animator") then
            return nil;
        else
            return l_Animator_0;
        end;
    end;
end;
return v6;
ModuleScript: CreatePLayerBuckets
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local l_Players_0 = game:GetService("Players");
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Bucket);
return function(v3, v4) --[[ Line: 8 ]] --[[ Name: CreatePlayerBuckets ]]
    -- upvalues: v2 (copy), l_Players_0 (copy)
    local v5 = {};
    local function v7(v6) --[[ Line: 14 ]] --[[ Name: addPlayer ]]
        -- upvalues: v5 (copy), v2 (ref), v3 (copy), v4 (copy)
        v5[v6] = v2.new(v3(v6), v4);
    end;
    for _, v9 in l_Players_0:GetPlayers() do
        v5[v9] = v2.new(v3(v9), v4);
    end;
    l_Players_0.PlayerAdded:Connect(v7);
    l_Players_0.PlayerRemoving:Connect(function(v10) --[[ Line: 23 ]]
        -- upvalues: v5 (copy)
        if v5[v10] then
            v5[v10]:Destroy();
            v5[v10] = nil;
        end;
    end);
    return v5;
end;
ModuleScript: DeferredCallback
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0) --[[ Line: 7 ]] --[[ Name: DeferredCallback ]]
    local v1 = false;
    local function v2() --[[ Line: 9 ]] --[[ Name: deferred ]]
        -- upvalues: v1 (ref), v0 (copy)
        v1 = false;
        v0();
    end;
    return function() --[[ Line: 14 ]]
        -- upvalues: v1 (ref), v2 (copy)
        if v1 then
            return;
        else
            v1 = true;
            task.defer(v2);
            return;
        end;
    end;
end;
ModuleScript: EmitParticleAtPosition
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Client.LowDetail);
local function v2(v3, v4, v5) --[[ Line: 7 ]] --[[ Name: EmitParticleAtPosition ]]
    -- upvalues: v1 (copy), v2 (copy)
    if v1.Enabled then
        return;
    elseif v4:IsA("Folder") then
        for _, v7 in v4:GetChildren() do
            v2(v3, v7, v5);
        end;
        return;
    else
        local l_Part_0 = Instance.new("Part");
        l_Part_0.Anchored = true;
        l_Part_0.CanCollide = false;
        l_Part_0.Size = Vector3.new(1, 1, 1, 0);
        l_Part_0.Transparency = 1;
        l_Part_0.CFrame = CFrame.new(v3);
        l_Part_0.Parent = workspace.Rendered.Generic;
        local l_Attachment_0 = Instance.new("Attachment");
        l_Attachment_0.Parent = l_Part_0;
        local v10 = v4:Clone();
        v10.Enabled = false;
        v10.Parent = l_Attachment_0;
        v10:Emit(v5);
        task.delay(v10.Lifetime.Max, function() --[[ Line: 38 ]]
            -- upvalues: l_Part_0 (copy)
            l_Part_0:Destroy();
        end);
        return;
    end;
end;
return v2;
ModuleScript: FuzzySearch
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

GetFuzzyScore = function(v0, v1) --[[ Line: 10 ]] --[[ Name: GetFuzzyScore ]]
    local v2 = 0;
    local v3 = 1;
    for v4 = 1, #v1 do
        local v5 = v0:find(v1:sub(v4, v4), v3, true);
        if not v5 then
            return 0;
        else
            v2 = v2 + 1;
            v3 = v5 + 1;
        end;
    end;
    return v2 / math.max(#v1, #v0);
end;
FuzzySearch = function(v6, v7) --[[ Line: 33 ]] --[[ Name: FuzzySearch ]]
    local v8 = {};
    for v9, v10 in pairs(v6) do
        local v11 = GetFuzzyScore(string.lower(v9), string.lower(v7));
        if v11 > 0 then
            table.insert(v8, {
                Score = v11, 
                Index = v9, 
                Value = v10
            });
        end;
    end;
    table.sort(v8, function(v12, v13) --[[ Line: 49 ]]
        return v12.Score > v13.Score;
    end);
    local v14 = {};
    for _, v16 in ipairs(v8) do
        table.insert(v14, v16);
    end;
    return v14;
end;
return FuzzySearch;
ModuleScript: ProductInfo
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local l_MarketplaceService_0 = game:GetService("MarketplaceService");
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Signal);
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.every);
local v4 = {};
local v5 = {};
local function v13(v6, v7, v8) --[[ Line: 37 ]] --[[ Name: updateCache ]]
    -- upvalues: v5 (copy), v2 (copy)
    local v9 = tostring(v6);
    local v10 = os.clock();
    local v11 = v5[v9];
    if not v11 then
        local v12 = v2.new();
        v12:Fire(v8);
        v5[v9] = {
            Id = v6, 
            Type = v7, 
            Expiry = v10 + 600, 
            Data = v8, 
            Signal = v12
        };
        return;
    else
        if v11.Expiry <= v10 then
            v11.Expiry = v10 + 600;
            v11.Data = v8;
            v11.Signal:Fire(v8);
        end;
        return;
    end;
end;
local function _(v14, v15, v16) --[[ Line: 59 ]] --[[ Name: updateProductInfo ]]
    -- upvalues: l_MarketplaceService_0 (copy), v13 (copy)
    local v17 = 0;
    task.defer(function() --[[ Line: 65 ]]
        -- upvalues: l_MarketplaceService_0 (ref), v14 (copy), v15 (copy), v17 (ref), v16 (copy), v13 (ref)
        local v18 = nil;
        while true do
            local l_status_0, l_result_0 = pcall(function() --[[ Line: 68 ]]
                -- upvalues: l_MarketplaceService_0 (ref), v14 (ref), v15 (ref)
                return l_MarketplaceService_0:GetProductInfo(v14, v15);
            end);
            if l_status_0 and l_result_0 then
                v18 = l_result_0;
                break;
            elseif v17 <= 50 then
                v17 = v17 + 1;
                task.wait(0.1);
            else
                break;
            end;
        end;
        if v18 then
            if v16 then
                v16(v18);
            end;
            v13(v14, v15, v18);
        end;
    end);
end;
local function v38(v22, v23, v24, v25) --[[ Line: 92 ]] --[[ Name: hookSignal ]]
    -- upvalues: v5 (copy), l_MarketplaceService_0 (copy), v13 (copy)
    local v26 = tostring(v22);
    local v27 = v5[v26];
    local function _(v28) --[[ Line: 101 ]] --[[ Name: connect ]]
        -- upvalues: v24 (copy), v25 (copy)
        if v24 == "Once" then
            v28:Once(v25);
            return;
        else
            v28:Connect(v25);
            return;
        end;
    end;
    if v27 and os.clock() < v27.Expiry then
        v25(v27.Data);
        local l_Signal_0 = v27.Signal;
        if v24 == "Once" then
            l_Signal_0:Once(v25);
            return;
        else
            l_Signal_0:Connect(v25);
            return;
        end;
    else
        local function v33(v31) --[[ Line: 113 ]]
            -- upvalues: v25 (copy), v5 (ref), v26 (copy), v24 (copy)
            v25(v31);
            task.defer(function() --[[ Line: 115 ]]
                -- upvalues: v5 (ref), v26 (ref), v24 (ref), v25 (ref)
                if v5[v26] then
                    local l_Signal_1 = v5[v26].Signal;
                    if v24 == "Once" then
                        l_Signal_1:Once(v25);
                        return;
                    else
                        l_Signal_1:Connect(v25);
                    end;
                end;
            end);
        end;
        local v34 = 0;
        task.defer(function() --[[ Line: 65 ]]
            -- upvalues: l_MarketplaceService_0 (ref), v22 (copy), v23 (copy), v34 (ref), v33 (copy), v13 (ref)
            local v35 = nil;
            while true do
                local l_status_1, l_result_1 = pcall(function() --[[ Line: 68 ]]
                    -- upvalues: l_MarketplaceService_0 (ref), v22 (ref), v23 (ref)
                    return l_MarketplaceService_0:GetProductInfo(v22, v23);
                end);
                if l_status_1 and l_result_1 then
                    v35 = l_result_1;
                    break;
                elseif v34 <= 50 then
                    v34 = v34 + 1;
                    task.wait(0.1);
                else
                    break;
                end;
            end;
            if v35 then
                if v33 then
                    v33(v35);
                end;
                v13(v22, v23, v35);
            end;
        end);
        return;
    end;
end;
v4.ConnectGamepassChanged = function(_, v40, v41) --[[ Line: 126 ]] --[[ Name: ConnectGamepassChanged ]]
    -- upvalues: v38 (copy)
    v38(v40, Enum.InfoType.GamePass, "Connect", v41);
end;
v4.ConnectProductChanged = function(_, v43, v44) --[[ Line: 131 ]] --[[ Name: ConnectProductChanged ]]
    -- upvalues: v38 (copy)
    v38(v43, Enum.InfoType.Product, "Connect", v44);
end;
v4.fromGamepass = function(v45, v46) --[[ Line: 136 ]] --[[ Name: fromGamepass ]]
    -- upvalues: v38 (copy)
    v38(v45, Enum.InfoType.GamePass, "Once", v46);
end;
v4.fromProduct = function(v47, v48) --[[ Line: 141 ]] --[[ Name: fromProduct ]]
    -- upvalues: v38 (copy)
    v38(v47, Enum.InfoType.Product, "Once", v48);
end;
v3(600, function() --[[ Line: 146 ]]
    -- upvalues: v5 (copy), l_MarketplaceService_0 (copy), v13 (copy)
    local v49 = os.clock();
    for _, v51 in v5 do
        if v49 >= v51.Expiry then
            local l_Id_0 = v51.Id;
            local l_Type_0 = v51.Type;
            local v54 = 0;
            local l_defer_0 = task.defer;
            local v56 = nil;
            do
                local l_v54_0 = v54;
                l_defer_0(function() --[[ Line: 65 ]]
                    -- upvalues: l_MarketplaceService_0 (ref), l_Id_0 (copy), l_Type_0 (copy), l_v54_0 (ref), v56 (copy), v13 (ref)
                    local v58 = nil;
                    while true do
                        local l_status_2, l_result_2 = pcall(function() --[[ Line: 68 ]]
                            -- upvalues: l_MarketplaceService_0 (ref), l_Id_0 (ref), l_Type_0 (ref)
                            return l_MarketplaceService_0:GetProductInfo(l_Id_0, l_Type_0);
                        end);
                        if l_status_2 and l_result_2 then
                            v58 = l_result_2;
                            break;
                        elseif l_v54_0 <= 50 then
                            l_v54_0 = l_v54_0 + 1;
                            task.wait(0.1);
                        else
                            break;
                        end;
                    end;
                    if v58 then
                        if v56 then
                            v56(v58);
                        end;
                        v13(l_Id_0, l_Type_0, v58);
                    end;
                end);
            end;
        end;
    end;
end);
return v4;
ModuleScript: SendSystemMessage
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_TextChatService_0 = game:GetService("TextChatService");
local l_RunService_0 = game:GetService("RunService");
local _ = game:GetService("Players");
local l_RemoteEvent_0 = script.RemoteEvent;
local function v9(v4, v5, v6) --[[ Line: 9 ]] --[[ Name: SendSystemMessage ]]
    -- upvalues: l_RunService_0 (copy), l_RemoteEvent_0 (copy)
    assert(l_RunService_0:IsServer(), "SendSystemMessage can only be called on the server");
    if v5 then
        for _, v8 in v5 do
            l_RemoteEvent_0:FireClient(v8, v4, v6);
        end;
        return;
    else
        l_RemoteEvent_0:FireAllClients(v4, v6);
        return;
    end;
end;
if l_RunService_0:IsClient() then
    local v10 = require(game:GetService("ReplicatedStorage").Client.Framework.Services.LocalData);
    task.spawn(function() --[[ Line: 24 ]]
        -- upvalues: l_TextChatService_0 (copy), l_RemoteEvent_0 (copy), v10 (copy)
        local l_RBXGeneral_0 = l_TextChatService_0:WaitForChild("TextChannels"):WaitForChild("RBXGeneral");
        l_RemoteEvent_0.OnClientEvent:Connect(function(v12, v13) --[[ Line: 27 ]]
            -- upvalues: v10 (ref), l_RBXGeneral_0 (copy)
            if v13 == "GlobalHatch" then
                local v14 = v10:Get();
                if not v14 or v14.Settings["Hide Global Secret Messages"] == true then
                    return;
                end;
            end;
            l_RBXGeneral_0:DisplaySystemMessage(v12);
        end);
    end);
end;
return v9;
LocalScript: ClientLoader
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

require(script.Parent);
ModuleScript: SequenceUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local function v9(v2, v3) --[[ Line: 5 ]] --[[ Name: getNumberSequenceValue ]]
    -- upvalues: v1 (copy)
    assert(v1.NumberSequence, v2);
    assert(v1.numberConstrained(0, 1), v3);
    local l_Keypoints_0 = v2.Keypoints;
    for v5 = 1, #l_Keypoints_0 - 1 do
        local v6 = l_Keypoints_0[v5];
        local v7 = l_Keypoints_0[v5 + 1];
        if v6.Time <= v3 and v3 < v7.Time then
            local v8 = (v3 - v6.Time) / (v7.Time - v6.Time);
            return v6.Value + (v7.Value - v6.Value) * v8, v6.Envelope + (v7.Envelope - v6.Envelope) * v8;
        end;
    end;
    return 0, 0;
end;
local function v17(v10, v11) --[[ Line: 24 ]] --[[ Name: getColorSequenceValue ]]
    -- upvalues: v1 (copy)
    assert(v1.ColorSequence, v10);
    assert(v1.numberConstrained(0, 1), v11);
    local l_Keypoints_1 = v10.Keypoints;
    for v13 = 1, #l_Keypoints_1 - 1 do
        local v14 = l_Keypoints_1[v13];
        local v15 = l_Keypoints_1[v13 + 1];
        if v14.Time <= v11 and v11 < v15.Time then
            local v16 = (v11 - v14.Time) / (v15.Time - v14.Time);
            return v14.Value:Lerp(v15.Value, v16);
        end;
    end;
    return Color3.new();
end;
local function v23(v18, v19) --[[ Line: 41 ]] --[[ Name: transformNumberSequence ]]
    -- upvalues: v1 (copy)
    assert(v1.NumberSequence, v18);
    assert(v1.callback, v19);
    local l_Keypoints_2 = v18.Keypoints;
    for v21, v22 in l_Keypoints_2 do
        l_Keypoints_2[v21] = v19(v22, v21);
    end;
    return NumberSequence.new(l_Keypoints_2);
end;
return {
    getNumberSequenceValue = v9, 
    getColorSequenceValue = v17, 
    transformNumberSequence = v23, 
    multiplyTransparencySequence = function(v24, v25) --[[ Line: 56 ]] --[[ Name: multiplyTransparencySequence ]]
        -- upvalues: v23 (copy)
        return v23(v24, function(v26) --[[ Line: 60 ]]
            -- upvalues: v25 (copy)
            return NumberSequenceKeypoint.new(v26.Time, 1 - (1 - v26.Value) * (1 - v25), v26.Envelope);
        end);
    end
};
ModuleScript: Statue 
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_Players_0 = game:GetService("Players");
local l_InsertService_0 = game:GetService("InsertService");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = game:GetService("ServerScriptService");
local v4 = require(script.Parent.Cache);
local v5 = require(l_ReplicatedStorage_0.Shared.Framework.Services.CollisionGroup);
local l_Rig_0 = script:FindFirstChild("Rig");
local l_HumanoidDescription_0 = script:FindFirstChild("HumanoidDescription");
local l_Animation_0 = script:FindFirstChild("Animation");
local v12 = v4(function(v9) --[[ Line: 15 ]] --[[ Name: fetchDescription ]]
    -- upvalues: l_Players_0 (copy)
    local l_status_0, l_result_0 = pcall(function() --[[ Line: 16 ]]
        -- upvalues: l_Players_0 (ref), v9 (copy)
        return l_Players_0:GetHumanoidDescriptionFromUserId(v9);
    end);
    if l_status_0 then
        return l_result_0;
    else
        return nil;
    end;
end);
local v19 = v4(function(v13) --[[ Line: 24 ]] --[[ Name: fetchIdleAnimation ]]
    -- upvalues: l_HumanoidDescription_0 (copy), l_Animation_0 (copy), l_InsertService_0 (copy)
    local l_IdleAnimation_0 = v13.IdleAnimation;
    if l_IdleAnimation_0 == 0 or v13 == l_HumanoidDescription_0 then
        return l_Animation_0;
    else
        local l_status_1, l_result_1 = pcall(function() --[[ Line: 30 ]]
            -- upvalues: l_InsertService_0 (ref), l_IdleAnimation_0 (copy)
            return l_InsertService_0:LoadAsset(l_IdleAnimation_0);
        end);
        if not l_status_1 then
            return nil;
        else
            local l_R15Anim_0 = l_result_1:FindFirstChild("R15Anim");
            if not l_R15Anim_0 then
                return nil;
            else
                local l_idle_0 = l_R15Anim_0:FindFirstChild("idle");
                if not l_idle_0 then
                    return nil;
                else
                    return l_idle_0:FindFirstChild("Animation") or l_idle_0:FindFirstChild("Animation1") or l_idle_0:FindFirstChildOfClass("Animation");
                end;
            end;
        end;
    end;
end);
local function _(v20, v21) --[[ Line: 53 ]] --[[ Name: getRigCFrame ]]
    return v20 * CFrame.new(0, v21.Humanoid.HipHeight + v21.HumanoidRootPart.Size.Y / 2, 0);
end;
return function(v23, v24) --[[ Line: 60 ]] --[[ Name: Statue ]]
    -- upvalues: l_Rig_0 (copy), v5 (copy), v12 (ref), l_HumanoidDescription_0 (copy), v19 (ref), l_Animation_0 (copy)
    local v25 = l_Rig_0:Clone();
    v25:PivotTo(v23 * CFrame.new(0, v25.Humanoid.HipHeight + v25.HumanoidRootPart.Size.Y / 2, 0));
    v5:AddModel(v25, v5.CharactersGroupName);
    local l_Humanoid_0 = v25.Humanoid;
    for _, v28 in Enum.HumanoidStateType:GetEnumItems() do
        if v28 ~= Enum.HumanoidStateType.None then
            l_Humanoid_0:SetStateEnabled(v28, false);
        end;
    end;
    local v29 = true;
    local v30 = nil;
    return {
        updateAsync = function(v31) --[[ Line: 75 ]] --[[ Name: updateAsync ]]
            -- upvalues: v12 (ref), l_HumanoidDescription_0 (ref), v19 (ref), l_Animation_0 (ref), v30 (ref), v29 (ref), l_Humanoid_0 (copy), v25 (copy), v23 (copy)
            local v32 = v12(v31) or l_HumanoidDescription_0;
            local v33 = v19(v32) or l_Animation_0;
            if v30 then
                v30:Stop();
                v30:Destroy();
            end;
            local _ = pcall(function() --[[ Line: 84 ]]
                -- upvalues: v29 (ref), l_Humanoid_0 (ref), v32 (copy)
                if v29 then
                    l_Humanoid_0:ApplyDescriptionReset(v32);
                    return;
                else
                    l_Humanoid_0:ApplyDescription(v32);
                    return;
                end;
            end);
            local l_v25_0 = v25;
            local l_v23_0 = v23;
            local l_v25_1 = v25;
            l_v25_0:PivotTo(l_v23_0 * CFrame.new(0, l_v25_1.Humanoid.HipHeight + l_v25_1.HumanoidRootPart.Size.Y / 2, 0));
            v29 = false;
            pcall(function() --[[ Line: 94 ]]
                -- upvalues: l_Humanoid_0 (ref), v33 (copy), v30 (ref)
                local v38 = l_Humanoid_0.Animator:LoadAnimation(v33);
                v38.Looped = true;
                v38:Play();
                v30 = v38;
            end);
        end, 
        setVisible = function(v39) --[[ Line: 102 ]] --[[ Name: setVisible ]]
            -- upvalues: v25 (copy), v24 (copy)
            if v39 then
                v25.Parent = v24;
                return;
            else
                v25.Parent = nil;
                return;
            end;
        end
    };
end;
ModuleScript: every
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_RunService_0 = game:GetService("RunService");
return function(v1, v2) --[[ Line: 5 ]] --[[ Name: every ]]
    -- upvalues: l_RunService_0 (copy)
    task.spawn(v2);
    local v3 = os.clock() + v1;
    return l_RunService_0.Heartbeat:Connect(function() --[[ Line: 10 ]]
        -- upvalues: v3 (ref), v1 (copy), v2 (copy)
        local v4 = os.clock();
        if v3 <= v4 then
            v3 = math.max(v4, v3 + v1);
            task.spawn(v2);
        end;
    end);
end;
ModuleScript: FindAbsoluteParent
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1) --[[ Line: 3 ]] --[[ Name: FindAbsoluteParent ]]
    local l_v0_0 = v0;
    while true do
        if l_v0_0 then
            local l_Parent_0 = l_v0_0.Parent;
            if l_Parent_0 and (l_Parent_0 == v1 or l_Parent_0 == game) then
                return l_v0_0;
            else
                l_v0_0 = l_Parent_0;
            end;
        else
            return nil;
        end;
    end;
end;
ModuleScript: ScaleModel
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1) --[[ Line: 3 ]] --[[ Name: ScaleModel ]]
    local l_v0_Pivot_0 = v0:GetPivot();
    for _, v4 in v0:GetDescendants() do
        if v4:IsA("BasePart") then
            local v5 = l_v0_Pivot_0:ToObjectSpace(v4.CFrame);
            v4.CFrame = l_v0_Pivot_0 * CFrame.new(v5.Position * v1) * v5.Rotation;
            v4.Size = v4.Size * v1;
        end;
    end;
end;
ModuleScript: Triangle
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_WedgePart_0 = Instance.new("WedgePart");
l_WedgePart_0.Anchored = true;
l_WedgePart_0.Material = Enum.Material.SmoothPlastic;
l_WedgePart_0.TopSurface = Enum.SurfaceType.Smooth;
l_WedgePart_0.BottomSurface = Enum.SurfaceType.Smooth;
l_WedgePart_0.Locked = true;
local l_SpecialMesh_0 = Instance.new("SpecialMesh");
l_SpecialMesh_0.MeshType = Enum.MeshType.Wedge;
l_SpecialMesh_0.Scale = Vector3.new(0, 1, 1, 0);
l_SpecialMesh_0.Parent = l_WedgePart_0;
local l_Dot_0 = Vector3.new().Dot;
local l_Cross_0 = Vector3.new().Cross;
local v4 = {};
v4.draw = function(v5, v6, v7) --[[ Line: 27 ]] --[[ Name: draw ]]
    -- upvalues: l_WedgePart_0 (copy), v4 (copy)
    local l_Model_0 = Instance.new("Model");
    local v9 = l_WedgePart_0:Clone();
    local v10 = l_WedgePart_0:Clone();
    v9.Name = "Wedge0";
    v10.Name = "Wedge1";
    v9.Parent = l_Model_0;
    v10.Parent = l_Model_0;
    v4.update(l_Model_0, v5, v6, v7);
    return l_Model_0;
end;
v4.update = function(v11, v12, v13, v14) --[[ Line: 44 ]] --[[ Name: update ]]
    -- upvalues: l_Dot_0 (copy), l_Cross_0 (copy)
    local l_Wedge0_0 = v11.Wedge0;
    local l_Wedge1_0 = v11.Wedge1;
    local v17 = v13 - v12;
    local v18 = v14 - v12;
    local v19 = v14 - v13;
    local v20 = l_Dot_0(v17, v17);
    local v21 = l_Dot_0(v18, v18);
    local v22 = l_Dot_0(v19, v19);
    if v21 < v20 and v22 < v20 then
        local l_v13_0 = v13;
        v13 = v14;
        v14 = v12;
        v12 = l_v13_0;
        l_v13_0 = v19;
        local v24 = -v17;
        v19 = -v18;
        v17 = l_v13_0;
        v18 = v24;
        v20 = v22;
    elseif v21 < v22 and v20 < v22 then
        local l_v14_0 = v14;
        local l_v12_0 = v12;
        v14 = v13;
        v12 = l_v14_0;
        v13 = l_v12_0;
        l_v14_0 = -v18;
        v18 = -v19;
        v19 = v17;
        v17 = l_v14_0;
        v20 = v21;
    end;
    local l_Unit_0 = v18.Unit;
    local v28 = l_Dot_0(v17, l_Unit_0);
    local v29 = (v20 - v28 * v28) ^ 0.5;
    local v30 = (v17 - l_Unit_0 * v28) / v29;
    local v31 = l_Cross_0(v30, l_Unit_0);
    l_Wedge0_0.Size = Vector3.new(0, v29 + 0.001, v28 + 0.001);
    l_Wedge0_0.CFrame = CFrame.new(0, 0, 0, v31.X, v30.X, l_Unit_0.X, v31.Y, v30.Y, l_Unit_0.Y, v31.Z, v30.Z, l_Unit_0.Z) + (v12 + v13) * 0.5;
    l_Wedge1_0.Size = Vector3.new(0, v29, l_Dot_0(v19, l_Unit_0));
    l_Wedge1_0.CFrame = CFrame.new(0, 0, 0, -v31.X, v30.X, -l_Unit_0.X, -v31.Y, v30.Y, -l_Unit_0.Y, -v31.Z, v30.Z, -l_Unit_0.Z) + (v13 + v14) * 0.5;
end;
return v4;
ModuleScript: Bilerp
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1, v2, v3, v4, v5) --[[ Line: 3 ]] --[[ Name: bilerp ]]
    local v6 = v0 + (v1 - v0) * v4;
    return v6 + (v2 + (v3 - v2) * v4 - v6) * v5;
end;
ModuleScript: Curve
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local _ = game:GetService("ReplicatedStorage");
local l_TweenService_0 = game:GetService("TweenService");
local v2 = {};
v2.__index = v2;
v2.new = function() --[[ Line: 37 ]] --[[ Name: new ]]
    -- upvalues: v2 (copy)
    return (setmetatable({
        MaxValue = 0, 
        _segments = {}
    }, v2));
end;
v2.Add = function(v3, v4) --[[ Line: 44 ]] --[[ Name: Add ]]
    local v5 = v3._segments[#v3._segments];
    local v6 = v5 and v5.Length.Max or 0;
    local v7 = v5 and v5.Value.Max or 0;
    table.insert(v3._segments, {
        Length = NumberRange.new(v6, v6 + v4.Length), 
        Value = NumberRange.new(v7, v4.Value), 
        Style = v4.Style or Enum.EasingStyle.Linear, 
        Direction = v4.Direction or Enum.EasingDirection.Out
    });
    v3.MaxValue = math.max(v3.MaxValue, v4.Value);
    return v3;
end;
v2.Get = function(v8, v9, v10) --[[ Line: 59 ]] --[[ Name: Get ]]
    -- upvalues: l_TweenService_0 (copy)
    if #v8._segments == 0 then
        return 0;
    else
        local v11 = v10 or 1;
        local v12 = nil;
        local v13 = nil;
        for _, v15 in v8._segments do
            if v9 <= v15.Length.Max * v11 then
                v12 = v15;
                break;
            else
                v13 = v15;
            end;
        end;
        if not v12 then
            return v8._segments[#v8._segments].Value.Max;
        elseif v9 == v12.Length.Max then
            return v12.Value.Max;
        elseif v9 < v8._segments[1].Length.Min then
            return 0;
        elseif v13 and v9 < v12.Length.Min then
            return v13.Value.Max;
        else
            local v16 = v12.Length.Min * v11;
            local v17 = v12.Length.Max * v11;
            local v18 = math.clamp((v9 - v16) / (v17 - v16), 0, 1);
            local l_l_TweenService_0_Value_0 = l_TweenService_0:GetValue(v18, v12.Style, v12.Direction);
            return v12.Value.Min + (v12.Value.Max - v12.Value.Min) * l_l_TweenService_0_Value_0;
        end;
    end;
end;
return v2;
ModuleScript: GetAngleBetweenVectors
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1) --[[ Line: 7 ]] --[[ Name: GetAngleBetweenVectors ]]
    local v2 = v0 - v1;
    if v2.Magnitude == 0 then
        return 0;
    else
        local l_Unit_0 = v2.Unit;
        return math.atan2(-l_Unit_0.Z, l_Unit_0.X) - 1.5707963267948966;
    end;
end;
ModuleScript: GetDistancePointSegment
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1, v2) --[[ Line: 3 ]] --[[ Name: distancePointSegment ]]
    local v3 = v2 - v0;
    local v4 = v1 - v0;
    local v5 = v3:Dot(v4.Unit);
    if v5 <= 0 then
        return v3.Magnitude;
    elseif v4.Magnitude <= v5 then
        return (v1 - v2).Magnitude;
    else
        return (v0 + v4.Unit * v5 - v2).Magnitude;
    end;
end;
ModuleScript: GetPositionOnArc
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

GetPositionOnArc = function(v0, v1, v2, v3) --[[ Line: 3 ]] --[[ Name: GetPositionOnArc ]]
    return (Vector3.new(v0.X + (v1.X - v0.X) * v3, v2 * 4 * v3 * (1 - v3) + v0.Y + (v1.Y - v0.Y) * v3, v0.Z + (v1.Z - v0.Z) * v3));
end;
return GetPositionOnArc;
ModuleScript: GetRandomWeightedItem
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = Random.new();
return function(v1, v2) --[[ Line: 21 ]] --[[ Name: GetRandomWeightedItem ]]
    -- upvalues: v0 (copy)
    local v3 = 0;
    for _, v5 in v1 do
        v3 = v3 + v5.Chance;
    end;
    local v6 = (v2 or v0):NextNumber(0, v3);
    for _, v8 in v1 do
        v3 = v3 - v8.Chance;
        if v3 < v6 then
            return v8.Item;
        end;
    end;
    return nil;
end;
ModuleScript: GetValueOnCurve
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1, v2, v3) --[[ Line: 18 ]] --[[ Name: GetValueOnCurve ]]
    return (math.clamp(v1 + (v2 - v1) * v0 ^ v3, v1, v2));
end;
ModuleScript: InverseCDFAttempts
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = Random.new();
return function(v1, v2) --[[ Line: 5 ]] --[[ Name: InverseCDFAttempts ]]
    -- upvalues: v0 (copy)
    local v3 = false;
    local _ = 0;
    local v5 = math.ceil(math.log(1 - v0:NextNumber()) / math.log(1 - v2));
    if v5 <= v1 then
        return true, v5;
    else
        return v3, v1;
    end;
end;
ModuleScript: Lerp
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1, v2) --[[ Line: 3 ]] --[[ Name: lerp ]]
    return v0 + (v1 - v0) * v2;
end;
ModuleScript: PointIntersectsPart
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1, v2) --[[ Line: 8 ]] --[[ Name: PointIntersectsPart ]]
    local v3 = v1.CFrame:PointToObjectSpace(v0);
    local v4 = v1.Size / 2;
    local v5 = math.abs(v3.X) <= v4.X;
    local v6 = math.abs(v3.Y) <= v4.Y;
    local v7 = math.abs(v3.Z) <= v4.Z;
    return v2 and v5 and v7 or v5 and v6 and v7;
end;
ModuleScript: PolygonGeometry
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local function v3(v0, v1, v2) --[[ Line: 15 ]] --[[ Name: wind ]]
    return (v1.X - v0.X) * (v2.Z - v0.Z) - (v2.X - v0.X) * (v1.Z - v0.Z);
end;
local function v12(v4, v5, v6, v7) --[[ Line: 20 ]] --[[ Name: isInTriangle ]]
    local v8 = math.sign((v5.X - v4.X) * (v7.Z - v4.Z) - (v7.X - v4.X) * (v5.Z - v4.Z));
    local v9 = math.sign((v6.X - v5.X) * (v7.Z - v5.Z) - (v7.X - v5.X) * (v6.Z - v5.Z));
    local v10 = math.sign((v4.X - v6.X) * (v7.Z - v6.Z) - (v7.X - v6.X) * (v4.Z - v6.Z));
    local v11 = false;
    if v8 == v9 then
        v11 = v9 == v10;
    end;
    return v11;
end;
local function v20(v13) --[[ Line: 29 ]] --[[ Name: isConvex ]]
    local v14 = nil;
    for v15, v16 in v13 do
        local v17 = v13[v15 % #v13 + 1];
        local v18 = v13[(v15 + 1) % #v13 + 1];
        local v19 = math.sign((v17.X - v16.X) * (v18.Z - v16.Z) - (v18.X - v16.X) * (v17.Z - v16.Z));
        if v14 and v14 ~= v19 then
            return false;
        else
            v14 = v19;
        end;
    end;
    return true;
end;
local function v28(v21, v22, v23, v24) --[[ Line: 45 ]] --[[ Name: testSegmentSegment ]]
    local v25 = (v22.X - v21.X) * (v24.Z - v21.Z) - (v24.X - v21.X) * (v22.Z - v21.Z);
    local v26 = (v22.X - v21.X) * (v23.Z - v21.Z) - (v23.X - v21.X) * (v22.Z - v21.Z);
    if v25 * v26 < 0 then
        local v27 = (v24.X - v23.X) * (v21.Z - v23.Z) - (v21.X - v23.X) * (v24.Z - v23.Z);
        if v27 * (v27 + v26 - v25) < 0 then
            return true;
        end;
    end;
    return false;
end;
local function v42(v29) --[[ Line: 62 ]] --[[ Name: isSimple ]]
    local v30 = false;
    local v31 = #v29;
    if v31 <= 3 then
        return true;
    else
        for v32, v33 in v29 do
            local v34 = v29[v32 % v31 + 1];
            for v35, v36 in v29 do
                local v37 = v29[v35 % v31 + 1];
                if v33 ~= v36 and v33 ~= v37 and v34 ~= v36 and v34 ~= v37 then
                    local v38 = (v34.X - v33.X) * (v37.Z - v33.Z) - (v37.X - v33.X) * (v34.Z - v33.Z);
                    local v39 = (v34.X - v33.X) * (v36.Z - v33.Z) - (v36.X - v33.X) * (v34.Z - v33.Z);
                    local v40;
                    if v38 * v39 < 0 then
                        local v41 = (v37.X - v36.X) * (v33.Z - v36.Z) - (v33.X - v36.X) * (v37.Z - v36.Z);
                        if v41 * (v41 + v39 - v38) < 0 then
                            v40 = true;
                            v30 = true;
                        end;
                    end;
                    if not v30 then
                        v40 = false;
                    end;
                    v30 = false;
                    if v40 then
                        print(v33, "to", v34);
                        print(v36, "to", v37);
                        return false;
                    end;
                end;
            end;
        end;
        return true;
    end;
end;
local function v55(v43) --[[ Line: 87 ]] --[[ Name: orderCCW ]]
    local v44 = 0;
    local v45 = #v43;
    for v46, v47 in v43 do
        local v48 = v43[v46 % v45 + 1];
        local v49 = v43[(v46 + 1) % v45 + 1];
        v44 = v44 + ((v48.X - v47.X) * (v49.Z - v47.Z) - (v49.X - v47.X) * (v48.Z - v47.Z));
    end;
    local v50 = table.clone(v43);
    if v44 < 0 then
        for v51 = 1, math.floor(v45 / 2) do
            local v52 = v45 - v51 + 1;
            local v53 = v50[v52];
            local v54 = v50[v51];
            v50[v51] = v53;
            v50[v52] = v54;
        end;
    end;
    return v50;
end;
local function v60(v56) --[[ Line: 108 ]] --[[ Name: flatten ]]
    local v57 = table.create(#v56);
    for v58, v59 in v56 do
        v57[v58] = v59 * Vector3.new(1, 0, 1, 0);
    end;
    return v57;
end;
local function v68(v61) --[[ Line: 118 ]] --[[ Name: getAABB ]]
    local v62 = 1e999;
    local v63 = -1e999;
    local v64 = 1e999;
    local v65 = -1e999;
    for _, v67 in v61 do
        if v67.X < v62 then
            v62 = v67.X;
        end;
        if v63 < v67.X then
            v63 = v67.X;
        end;
        if v67.Z < v64 then
            v64 = v67.Z;
        end;
        if v65 < v67.Z then
            v65 = v67.Z;
        end;
    end;
    return {
        Min = Vector3.new(v62, 0, v64), 
        Max = Vector3.new(v63, 0, v65)
    };
end;
local function v74(v69) --[[ Line: 135 ]] --[[ Name: getArea ]]
    local v70 = 0;
    for v71, v72 in v69 do
        local v73 = v69[v71 % #v69 + 1];
        v70 = v70 + (v72.X * v73.Z - v73.X - v72.Z);
    end;
    return math.abs(v70) / 2;
end;
local function v82(v75, v76, v77) --[[ Line: 147 ]] --[[ Name: getTriangleArea ]]
    local l_Magnitude_0 = (v76 - v75).Magnitude;
    local l_Magnitude_1 = (v77 - v76).Magnitude;
    local l_Magnitude_2 = (v75 - v77).Magnitude;
    local v81 = (l_Magnitude_0 + l_Magnitude_1 + l_Magnitude_2) / 2;
    return (math.sqrt(v81 * (v81 - l_Magnitude_0) * (v81 - l_Magnitude_1) * (v81 - l_Magnitude_2)));
end;
local function v91(v83, v84, v85) --[[ Line: 158 ]] --[[ Name: getSegmentPointDistance ]]
    local v86 = v84 - v83;
    local v87 = v85 - v83;
    local v88 = v85 - v84;
    local v89 = v87:Dot(v86);
    if v89 <= 0 then
        return v87.Magnitude;
    else
        local v90 = v86:Dot(v86);
        if v90 <= v89 then
            return v88.Magnitude;
        else
            return (math.sqrt(v87:Dot(v87) - v89 * v89 / v90));
        end;
    end;
end;
return {
    wind = v3, 
    isInTriangle = v12, 
    isConvex = v20, 
    isSimple = v42, 
    orderCCW = v55, 
    flatten = v60, 
    getAABB = v68, 
    getArea = v74, 
    getTriangleArea = v82, 
    getSegmentPointDistance = v91, 
    getTrianglePointDistance = function(v92, v93, v94, v95) --[[ Line: 178 ]] --[[ Name: getTrianglePointDistance ]]
        -- upvalues: v91 (copy)
        local v96 = math.sign((v93.X - v92.X) * (v95.Z - v92.Z) - (v95.X - v92.X) * (v93.Z - v92.Z));
        local v97 = math.sign((v94.X - v93.X) * (v95.Z - v93.Z) - (v95.X - v93.X) * (v94.Z - v93.Z));
        local v98 = math.sign((v92.X - v94.X) * (v95.Z - v94.Z) - (v95.X - v94.X) * (v92.Z - v94.Z));
        local v99 = false;
        if v96 == v97 then
            v99 = v97 == v98;
        end;
        if v99 then
            return 0;
        else
            return (math.min(v91(v92, v93, v95), v91(v93, v94, v95), (v91(v94, v92, v95))));
        end;
    end, 
    getConvexHull = function(v100) --[[ Line: 191 ]] --[[ Name: getConvexHull ]]
        if #v100 < 4 then
            return table.clone(v100);
        else
            local v101 = {};
            local v102 = 1;
            for v103 = 2, #v100 do
                if v100[v103].X < v100[v102].X then
                    v102 = v103;
                end;
            end;
            local l_v102_0 = v102;
            repeat
                table.insert(v101, v100[l_v102_0]);
                local v105 = l_v102_0 % #v100 + 1;
                for v106, _ in v100 do
                    local v108 = v100[l_v102_0];
                    local v109 = v100[v106];
                    local v110 = v100[v105];
                    if (v109.X - v108.X) * (v110.Z - v108.Z) - (v110.X - v108.X) * (v109.Z - v108.Z) > 0 then
                        v105 = v106;
                    end;
                end;
                l_v102_0 = v105;
            until l_v102_0 == v102;
            return v101;
        end;
    end, 
    triangulateEarClip = function(v111) --[[ Line: 220 ]] --[[ Name: triangulateEarClip ]]
        -- upvalues: v55 (copy)
        local v112 = #v111;
        local v113 = table.create(v112);
        local v114 = table.create(v112);
        for v115 = 1, v112 do
            v113[v115] = if v115 == 1 then v112 else v115 - 1;
            v114[v115] = v115 == v112 and 1 or v115 + 1;
        end;
        local v116 = {};
        v111 = v55(v111);
        local v117 = 1;
        while v112 >= 3 do
            local v118 = true;
            local v119 = v111[v113[v117]];
            local v120 = v111[v117];
            local v121 = v111[v114[v117]];
            if (v120.X - v119.X) * (v121.Z - v119.Z) - (v121.X - v119.X) * (v120.Z - v119.Z) >= 0 then
                v119 = v114[v114[v117]];
                while true do
                    v121 = v111[v113[v117]];
                    local v122 = v111[v117];
                    local v123 = v111[v114[v117]];
                    local v124 = v111[v119];
                    local v125 = math.sign((v122.X - v121.X) * (v124.Z - v121.Z) - (v124.X - v121.X) * (v122.Z - v121.Z));
                    local v126 = math.sign((v123.X - v122.X) * (v124.Z - v122.Z) - (v124.X - v122.X) * (v123.Z - v122.Z));
                    local v127 = math.sign((v121.X - v123.X) * (v124.Z - v123.Z) - (v124.X - v123.X) * (v121.Z - v123.Z));
                    v120 = false;
                    if v125 == v126 then
                        v120 = v126 == v127;
                    end;
                    if v120 then
                        v118 = false;
                        break;
                    else
                        v119 = v114[v119];
                        if v119 == v113[v117] then
                            break;
                        end;
                    end;
                end;
            else
                v118 = false;
            end;
            if v118 then
                table.insert(v116, {
                    v111[v117], 
                    v111[v113[v117]], 
                    v111[v114[v117]]
                });
                v114[v113[v117]] = v114[v117];
                v113[v114[v117]] = v113[v117];
                v112 = v112 - 1;
                v117 = v113[v117];
            else
                v117 = v114[v117];
            end;
        end;
        return v116;
    end, 
    triangulateFan = function(v128) --[[ Line: 268 ]] --[[ Name: triangulateFan ]]
        -- upvalues: v68 (copy)
        local v129 = v68(v128);
        local v130 = (v129.Min + v129.Max) / 2;
        local v131 = #v128;
        local v132 = table.create(v131);
        for v133, v134 in v128 do
            v132[v133] = {
                v134, 
                v128[v133 % v131 + 1], 
                v130
            };
        end;
        return v132;
    end, 
    testSegmentSegment = v28, 
    testPointPolygon = function(v135, v136) --[[ Line: 283 ]] --[[ Name: testPointPolygon ]]
        local v137 = 0;
        for v138, v139 in v135 do
            local v140 = v135[v138 % #v135 + 1];
            if v139.Z <= v136.Z then
                if v140.Z > v136.Z and (v140.X - v139.X) * (v136.Z - v139.Z) - (v136.X - v139.X) * (v140.Z - v139.Z) > 0 then
                    v137 = v137 + 1;
                end;
            elseif v140.Z <= v136.Z and (v140.X - v139.X) * (v136.Z - v139.Z) - (v136.X - v139.X) * (v140.Z - v139.Z) <= 0 then
                v137 = v137 - 1;
            end;
        end;
        return v137 ~= 0;
    end, 
    testPointHull = function(v141, v142) --[[ Line: 302 ]] --[[ Name: testPointHull ]]
        local v143 = nil;
        for v144, v145 in v141 do
            local v146 = v141[v144 % #v141 + 1];
            local v147 = (v146.X - v145.X) * (v142.Z - v145.Z) - (v142.X - v145.X) * (v146.Z - v145.Z) > 0 and 1 or -1;
            if not v143 then
                v143 = v147;
            elseif v143 ~= v147 then
                return false;
            end;
        end;
        return true;
    end
};
ModuleScript: RandomNormalDistribution
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v2 = Random.new();
return function(v3, v4, v5) --[[ Line: 14 ]] --[[ Name: RandomNormalDistribution ]]
    -- upvalues: v1 (copy), v2 (copy)
    assert(v1.number(v3));
    assert(v1.number(v4));
    assert(v1.number(v5));
    local v6 = v2:NextNumber();
    local v7 = v2:NextNumber();
    local v8 = math.sqrt(math.log(v6) * -2) * math.cos(6.283185307179586 * v7);
    return (v4 - v3) / 2 + v3 + v8 * v5;
end;
ModuleScript: RoundFloatingPoint
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
return function(v2) --[[ Line: 7 ]] --[[ Name: RoundFloatingPoint ]]
    -- upvalues: v1 (copy)
    assert(v1.number(v2));
    local v3, v4 = math.modf(v2);
    if math.abs(v4) < 1.0E-6 or math.abs(v4 - 1) < 1.0E-6 then
        return v3;
    else
        local v5 = math.floor(v2 * 100000 + 0.5) / 100000;
        return tonumber(string.format("%.5f", v5)) or 0;
    end;
end;
ModuleScriptL SolveIK
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local function _(v0, v1, v2) --[[ Line: 3 ]] --[[ Name: trig ]]
    return (math.acos((v0 * v0 + v1 * v1 - v2 * v2) / (v0 * 2 * v1)));
end;
local function v18(v4, v5, v6, v7) --[[ Line: 12 ]] --[[ Name: inverseKinematics ]]
    local v8 = v4:PointToObjectSpace(v5);
    local v9 = -math.atan2(v8.X, -v8.Z);
    local v10 = math.atan2(v8.Y, (math.sqrt(v8.X ^ 2 + v8.Z ^ 2)));
    local _ = CFrame.Angles(0, v9, 0) * CFrame.Angles(v10, 0, 0);
    local l_Magnitude_0 = v8.Magnitude;
    local v13 = 0;
    local v14 = 0;
    if v6 + v7 < l_Magnitude_0 then
        l_Magnitude_0 = v6 + v7;
        v8 = v8.Unit * l_Magnitude_0;
    else
        local v15 = -1;
        local l_l_Magnitude_0_0 = l_Magnitude_0;
        v13 = v15 * math.acos((v6 * v6 + l_l_Magnitude_0_0 * l_l_Magnitude_0_0 - v7 * v7) / (v6 * 2 * l_l_Magnitude_0_0));
        local l_l_Magnitude_0_1 = l_Magnitude_0;
        v14 = 3.141592653589793 - math.acos((v6 * v6 + v7 * v7 - l_l_Magnitude_0_1 * l_l_Magnitude_0_1) / (v6 * 2 * v7));
    end;
    return v13, v14, v8, v9, v10;
end;
return function(v19, v20, v21, v22, v23) --[[ Line: 38 ]] --[[ Name: SolveIK ]]
    -- upvalues: v18 (copy)
    local v24, v25, v26, v27, v28 = v18(v19, v20, v21, v22);
    local v29 = CFrame.fromAxisAngle(v26, (math.rad(v23 or 0))) * CFrame.Angles(0, v27, 0) * CFrame.Angles(v28, 0, 0);
    return v19 * v29 * CFrame.Angles(v24, 0, 0) * CFrame.new(0, 0, -v21 * 0.5), v19 * v29 * CFrame.Angles(v24, 0, 0) * CFrame.new(0, 0, -v21) * CFrame.Angles(v25, 0, 0) * CFrame.new(0, 0, -v22 * 0.5);
end;
ModuleScript: Time
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatOrdinal);
local v2 = {
    "January", 
    "February", 
    "March", 
    "April", 
    "May", 
    "June", 
    "July", 
    "August", 
    "September", 
    "October", 
    "November", 
    "December"
};
local function v3() --[[ Line: 37 ]] --[[ Name: now ]]
    return workspace:GetServerTimeNow();
end;
local function v5(v4) --[[ Line: 41 ]] --[[ Name: fromTable ]]
    return DateTime.fromUniversalTime(v4.year, v4.month or 1, v4.day or 1, v4.hour or 0, v4.minute or 0, v4.second or 0).UnixTimestamp;
end;
local function v8(v6) --[[ Line: 59 ]] --[[ Name: toTable ]]
    local v7 = DateTime.fromUnixTimestamp(v6):ToUniversalTime();
    return {
        year = v7.Year, 
        month = v7.Month, 
        day = v7.Day, 
        hour = v7.Hour, 
        minute = v7.Minute, 
        second = v7.Second
    };
end;
local function v10(v9) --[[ Line: 72 ]] --[[ Name: formatDate ]]
    -- upvalues: v2 (copy), v1 (copy)
    return (("%* %*, %*"):format(v2[v9.month], v1(v9.day), v9.year));
end;
local function v14(v11, v12) --[[ Line: 77 ]] --[[ Name: format12HourTime ]]
    local v13 = "AM";
    if v11 >= 12 then
        v13 = "PM";
    end;
    if v11 == 0 then
        v11 = 12;
    elseif v11 > 12 then
        v11 = v11 - 12;
    end;
    return string.format("%d:%02d %s", v11, v12, v13);
end;
local function v18(_, v16) --[[ Line: 96 ]] --[[ Name: toLocalTime ]]
    -- upvalues: v14 (copy)
    local v17 = DateTime.fromUnixTimestamp(v16):ToLocalTime();
    return v14(v17.Hour, v17.Minute);
end;
local function v20(v19) --[[ Line: 106 ]] --[[ Name: getAbsoluteHour ]]
    return (math.floor((v19 or workspace:GetServerTimeNow()) / 3600));
end;
local function v22(v21) --[[ Line: 111 ]] --[[ Name: getAbsoluteDay ]]
    return (math.floor((v21 or workspace:GetServerTimeNow()) / 86400));
end;
local function v25(v23) --[[ Line: 117 ]] --[[ Name: untilMidnight ]]
    local v24 = v23 or workspace:GetServerTimeNow();
    return (math.floor((v24 or workspace:GetServerTimeNow()) / 86400) + 1) * 86400 - v24;
end;
local function v33(v26, v27) --[[ Line: 129 ]] --[[ Name: formatTime ]]
    local v28 = math.floor(v26 / 86400);
    local v29 = math.floor(v26 % 86400 / 3600);
    local v30 = math.floor(v26 % 3600 / 60);
    local v31 = v26 % 60;
    if v28 > 0 then
        local v32 = v28 == 1 and "day" or "days";
        if v27 then
            return string.format("%i %s", v28, v32);
        else
            return string.format("%i %s, %i:%02i:%02i", v28, v32, v29, v30, v31);
        end;
    elseif v26 >= 3600 then
        return string.format("%i:%02i:%02i", v29, v30, v31);
    elseif v26 >= 60 then
        return string.format("%i:%02i", v30, v31);
    else
        return string.format("%is", v31);
    end;
end;
local function v43(v34) --[[ Line: 149 ]] --[[ Name: formatRealTime ]]
    local v35 = math.floor(v34 / 86400);
    local v36 = math.floor(v34 % 86400 / 3600);
    local v37 = math.floor(v34 % 3600 / 60);
    local v38 = math.floor(v34) % 60;
    if v35 > 0 then
        local v39 = v35 == 1 and "day" or "days";
        return string.format("%i %s", v35, v39);
    elseif v36 > 0 then
        local v40 = v36 == 1 and "hour" or "hours";
        return string.format("%i %s", v36, v40);
    elseif v37 > 0 then
        local v41 = v37 == 1 and "minute" or "minutes";
        return string.format("%i %s", v37, v41);
    else
        local v42 = v38 == 1 and "second" or "seconds";
        return string.format("%i %s", v38, v42);
    end;
end;
local function _() --[[ Line: 173 ]] --[[ Name: getwday ]]
    -- upvalues: v3 (copy)
    return os.date("!*t", v3()).wday;
end;
return {
    now = v3, 
    fromTable = v5, 
    toTable = v8, 
    getAbsoluteHour = v20, 
    getAbsoluteDay = v22, 
    untilMidnight = v25, 
    toLocalTime = v18, 
    format12HourTime = v14, 
    formatDate = v10, 
    formatTime = v33, 
    fromIsoDate = function(v45) --[[ Line: 197 ]] --[[ Name: fromIsoDate ]]
        local v46, v47, v48, v49, v50, v51 = v45:match("^(%d+)%-(%d+)%-(%d+)T(%d+):(%d+):([%d%.]+)Z$");
        local v52 = {
            year = tonumber(v46) or 0, 
            month = tonumber(v47) or 0, 
            day = tonumber(v48) or 0, 
            hour = tonumber(v49) or 0, 
            minute = tonumber(v50) or 0, 
            second = math.floor(tonumber(v51) or 0)
        };
        return DateTime.fromUniversalTime(v52.year, v52.month or 1, v52.day or 1, v52.hour or 0, v52.minute or 0, v52.second or 0).UnixTimestamp;
    end, 
    isWeekend = function() --[[ Line: 177 ]] --[[ Name: isWeekend ]]
        -- upvalues: v3 (copy)
        local l_wday_0 = os.date("!*t", v3()).wday;
        local v54 = true;
        if l_wday_0 ~= 1 then
            v54 = l_wday_0 == 7;
        end;
        return v54;
    end, 
    timeUntilWeekend = function() --[[ Line: 187 ]] --[[ Name: timeUntilWeekend ]]
        -- upvalues: v3 (copy)
        local l_wday_1 = os.date("!*t", v3()).wday;
        if l_wday_1 == 1 or l_wday_1 == 7 then
            return 0;
        else
            local l_workspace_ServerTimeNow_0 = workspace:GetServerTimeNow();
            return (math.floor((l_workspace_ServerTimeNow_0 or workspace:GetServerTimeNow()) / 86400) + 1) * 86400 - l_workspace_ServerTimeNow_0 + 86400 * (6 - l_wday_1);
        end;
    end, 
    formatRealTime = v43, 
    secondsInDay = 86400, 
    secondsInHour = 3600, 
    secondsInMinute = 60
};
ModuleScript: VectorToGridPosition
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1) --[[ Line: 3 ]] --[[ Name: VectorToGridPosition ]]
    local v2 = v1 / 2;
    return (Vector3.new(math.round((v0.X + v2) / v1), math.round((v0.Y + v2) / v1), (math.round((v0.Z + v2) / v1))));
end;
ModuleScript: Button1Up
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_UserInputService_0 = game:GetService("UserInputService");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Signal).new();
l_UserInputService_0.InputEnded:Connect(function(v3) --[[ Line: 10 ]]
    -- upvalues: v2 (copy)
    local l_UserInputType_0 = v3.UserInputType;
    if l_UserInputType_0 == Enum.UserInputType.MouseButton1 or l_UserInputType_0 == Enum.UserInputType.Touch then
        v2:Fire();
    end;
end);
return v2;
ModuleScript: FindLastCharacter
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
return function(v2, v3) --[[ Line: 12 ]] --[[ Name: FindLastCharacter ]]
    -- upvalues: v1 (copy)
    assert(v1.string(v2));
    assert(v1.string(v3));
    for v4 = string.len(v2), 1, -1 do
        if string.sub(v2, v4, v4) == v3 then
            return v4 - 1;
        end;
    end;
    return -1;
end;
ModuleScript: Flatten
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
return function(v2) --[[ Line: 10 ]] --[[ Name: Flatten ]]
    -- upvalues: v1 (copy)
    assert(v1.string(v2));
    return (v2:gsub("[\n\t]", ""));
end;
ModuleScript: FormatCommas
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
return function(v2) --[[ Line: 10 ]] --[[ Name: FormatCommas ]]
    -- upvalues: v1 (copy)
    assert(v1.number(v2));
    local v3 = string.format("%i", v2);
    local v4 = -1;
    while v4 ~= 0 do
        local v5, v6 = string.gsub(v3, "^(-?%d+)(%d%d%d)", "%1,%2");
        v3 = v5;
        v4 = v6;
    end;
    return v3;
end;
ModuleScript: FormatList
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0) --[[ Line: 6 ]] --[[ Name: formatList ]]
    if #v0 == 1 then
        return v0[1];
    elseif #v0 == 2 then
        return (("%* and %*"):format(v0[1], v0[2]));
    else
        return (("%*, and %*"):format(table.concat(v0, ", ", 1, #v0 - 1), v0[#v0]));
    end;
end;
ModuleScript: FormatOrdinal
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {
    [0] = "th"; 
    "st", 
    "nd", 
    "rd"
};
FormatOrdinal = function(v1) --[[ Line: 4 ]] --[[ Name: FormatOrdinal ]]
    -- upvalues: v0 (copy)
    local v2 = v1 % 10;
    local v3 = v1 % 100;
    if v3 > 10 and v3 < 14 then
        return v1 .. "th";
    else
        return v1 .. (v0[v2] or v0[0]);
    end;
end;
return FormatOrdinal;
ModuleScript: FormatPercent
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatSuffix);
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatCommas);
return function(v3, v4) --[[ Line: 9 ]] --[[ Name: FormatPercent ]]
    -- upvalues: v1 (copy), v2 (copy)
    if v4 then
        if v3 > 1 then
            return string.format("%.1f", v3):gsub("%.?0+$", "") .. "%";
        elseif v3 > 1.0E-4 then
            return string.format("%.6f", v3):gsub("%.?0+$", "") .. "%";
        else
            local v5 = string.format("%g", v3);
            if string.find(v5, "e") then
                return v5 .. "%";
            else
                return tostring(v3) .. "%";
            end;
        end;
    else
        local v6 = false;
        if v3 < 1 then
            v6 = v3 > 0;
        end;
        if v3 % 1 == 0 or v6 then
            if v6 == true then
                return (("1/%*"):format((v1(100 / v3))));
            else
                return (("%*%%"):format((v2(v3))));
            end;
        else
            return string.format("%0.1f", v3) .. "%";
        end;
    end;
end;
ModuleScript: FormatPlural
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {
    "a", 
    "e", 
    "i", 
    "o", 
    "u"
};
local v1 = {
    fish = "fish", 
    damage = "damage", 
    anglerfish = "anglerfish"
};
local function _(v2, v3) --[[ Line: 12 ]] --[[ Name: endsWith ]]
    local v4 = true;
    if v3 ~= "" then
        v4 = string.sub(v2, -string.len(v3)) == v3;
    end;
    return v4;
end;
local function _(v6) --[[ Line: 17 ]] --[[ Name: firstToUpper ]]
    return (v6:gsub("(%a)([%w_']*)", function(v7, v8) --[[ Line: 18 ]]
        return string.upper(v7) .. v8;
    end));
end;
local v14 = {
    {
        suffix = "cus", 
        pluralForm = "cuses"
    }, 
    {
        suffix = "box", 
        pluralForm = "boxes"
    }, 
    {
        suffix = "y", 
        condition = function(v10) --[[ Line: 25 ]] --[[ Name: pluralizeY ]]
            -- upvalues: v0 (copy)
            local v11 = string.sub(v10, -2, -2);
            for _, v13 in ipairs(v0) do
                if v11 == v13 then
                    return false;
                end;
            end;
            return true;
        end, 
        pluralForm = "ies"
    }, 
    {
        suffix = {
            "s", 
            "x", 
            "z"
        }, 
        pluralForm = "es"
    }, 
    {
        suffix = {
            "sh", 
            "ch"
        }, 
        pluralForm = "es"
    }, 
    {
        suffix = "man", 
        pluralForm = "men"
    }, 
    {
        suffix = "", 
        pluralForm = "s"
    }
};
return function(v15) --[[ Line: 51 ]] --[[ Name: FormatPlural ]]
    -- upvalues: v1 (copy), v14 (copy)
    if v15 == "Wolf" then
        return "Wolves";
    else
        local v16 = string.lower((string.sub(v15, 1, 1))) .. string.sub(v15, 2);
        local v17 = v1[v16];
        if v17 ~= nil then
            if v16 ~= v15 then
                v17 = string.upper((string.sub(v17, 1, 1))) .. string.sub(v17, 2);
            end;
            return v17;
        else
            for _, v19 in ipairs(v14) do
                local v20 = type(v19.suffix) == "table" and v19.suffix or {
                    v19.suffix
                };
                for _, v22 in ipairs(v20) do
                    local v23 = string.lower(v15);
                    local v24 = string.lower(v22);
                    local v25 = true;
                    if v24 ~= "" then
                        v25 = string.sub(v23, -string.len(v24)) == v24;
                    end;
                    if v25 and (not v19.condition or v19.condition(v15)) then
                        return ((string.sub(v15, 1, -string.len(v22) - 1) .. v19.pluralForm):gsub("(%a)([%w_']*)", function(v26, v27) --[[ Line: 18 ]]
                            return string.upper(v26) .. v27;
                        end));
                    end;
                end;
            end;
            return v15;
        end;
    end;
end;
ModuleScript: FormatRomanNumeral
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {
    {
        1000, 
        "M"
    }, 
    {
        900, 
        "CM"
    }, 
    {
        500, 
        "D"
    }, 
    {
        400, 
        "CD"
    }, 
    {
        100, 
        "C"
    }, 
    {
        90, 
        "XC"
    }, 
    {
        50, 
        "L"
    }, 
    {
        40, 
        "XL"
    }, 
    {
        10, 
        "X"
    }, 
    {
        9, 
        "IX"
    }, 
    {
        5, 
        "V"
    }, 
    {
        4, 
        "IV"
    }, 
    {
        1, 
        "I"
    }
};
FormatRomanNumeral = function(v1) --[[ Line: 20 ]] --[[ Name: FormatRomanNumeral ]]
    -- upvalues: v0 (copy)
    local v2 = "";
    for _, v4 in ipairs(v0) do
        local v5 = math.floor(v1 / v4[1]);
        v1 = v1 % v4[1];
        v2 = v2 .. string.rep(v4[2], v5);
    end;
    return v2;
end;
return FormatRomanNumeral;
ModuleScript: FormatSuffix
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatCommas);
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v3 = {
    "K", 
    "M", 
    "B", 
    "T", 
    "Qa", 
    "Qi", 
    "Sx", 
    "Sp", 
    "Oc", 
    "No", 
    "Dc", 
    "Ud", 
    "Dd", 
    "Td", 
    "Qad", 
    "Qid"
};
return function(v4, v5, v6) --[[ Line: 9 ]] --[[ Name: FormatSuffix ]]
    -- upvalues: v2 (copy), v1 (copy), v3 (copy)
    assert(v2.number(v4));
    assert(v2.number(v5) or v2.none(v5));
    if not v5 then
        v5 = 1000000000000;
    end;
    local v7 = math.floor(math.log(v4) / 6.907755278982137);
    if v7 < 1 or v5 and v4 < v5 then
        return v1(v4);
    else
        local v8 = v4 / 1000 ^ v7;
        local v9 = v3[v7];
        if math.abs(v8 - 1000) < 0.01 then
            v8 = v8 / 1000;
            v9 = v3[v7 + 1];
        end;
		return ((not (v8 % 1 ~= 0) or v6) and string.format("%d", v8) or string.format("%0.2f", v8):gsub("0+$", ""):gsub("%.$", "")) .. v9;
    end;
end;
ModuleScript: GetCharacterFromTextLabel
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_TextService_0 = game:GetService("TextService");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local function _(v3, v4, v5, v6) --[[ Line: 14 ]] --[[ Name: AddLine ]]
    if v6 and v5 ~= " " then
        v5 = " " .. v5;
    end;
    if not v3[v4] then
        v3[v4] = string.sub(v5, 2);
        return;
    else
        v3[v4] = v3[v4] .. v5;
        return;
    end;
end;
local function v36(v8, v9) --[[ Line: 36 ]] --[[ Name: GetLines ]]
    -- upvalues: l_TextService_0 (copy)
    local v10 = 0;
    local v11 = 1;
    local v12 = v8.AbsoluteSize / v9;
    local v13 = {};
    local v14 = {};
    for _, v16 in string.split(v8.ContentText, " ") do
        if v16 ~= "" then
            local v17 = "";
            for _, v19 in utf8.codes(v16) do
                local v20 = utf8.char(v19);
                if v20 == "\n" then
                    if v17 ~= "" then
                        v13[#v13 + 1] = v17;
                    end;
                    v13[#v13 + 1] = "*NEWLINE*";
                    v17 = "";
                else
                    v17 = v17 .. v20;
                end;
            end;
            v13[#v13 + 1] = v17;
        else
            v13[#v13 + 1] = " ";
        end;
    end;
    repeat
        local v21 = table.remove(v13, 1);
        local l_X_0 = l_TextService_0:GetTextSize(v21 .. " ", v8.TextSize, v8.Font, Vector2.new()).X;
        if v21 == "*NEWLINE*" then
            v10 = 0;
            v11 = v11 + 1;
        elseif v12.X < l_X_0 then
            local v23 = "";
            v10 = 0;
            v11 = v11 + 1;
            for _, v25 in utf8.codes(v23 .. " ") do
                local v26 = utf8.char(v25);
                local l_X_1 = l_TextService_0:GetTextSize(v26, v8.TextSize, v8.Font, Vector2.new()).X;
                if l_X_1 + v10 > v12.X then
                    local l_v11_0 = v11;
                    local l_v23_0 = v23;
                    if not v14[l_v11_0] then
                        v14[l_v11_0] = string.sub(l_v23_0, 2);
                    else
                        v14[l_v11_0] = v14[l_v11_0] .. l_v23_0;
                    end;
                    v11 = v11 + 1;
                    v23 = v26;
                    v10 = l_X_1;
                else
                    v23 = v23 .. v26;
                    v10 = v10 + l_X_1;
                end;
            end;
            v10 = 0;
            local l_v11_1 = v11;
            local l_v23_1 = v23;
            if not v14[l_v11_1] then
                v14[l_v11_1] = string.sub(l_v23_1, 2);
            else
                v14[l_v11_1] = v14[l_v11_1] .. l_v23_1;
            end;
        elseif l_X_0 + v10 > v12.X then
            v10 = l_X_0;
            v11 = v11 + 1;
            local l_v11_2 = v11;
            local l_v21_0 = v21;
            if l_v21_0 ~= " " then
                l_v21_0 = " " .. l_v21_0;
            end;
            if not v14[l_v11_2] then
                v14[l_v11_2] = string.sub(l_v21_0, 2);
            else
                v14[l_v11_2] = v14[l_v11_2] .. l_v21_0;
            end;
        else
            v10 = v10 + l_X_0;
            local l_v11_3 = v11;
            local l_v21_1 = v21;
            if l_v21_1 ~= " " then
                l_v21_1 = " " .. l_v21_1;
            end;
            if not v14[l_v11_3] then
                v14[l_v11_3] = string.sub(l_v21_1, 2);
            else
                v14[l_v11_3] = v14[l_v11_3] .. l_v21_1;
            end;
        end;
    until #v13 == 0;
    return v14;
end;
return function(v37, v38, v39) --[[ Line: 117 ]] --[[ Name: GetCharacterFromTextLabel ]]
    -- upvalues: v2 (copy), v36 (copy), l_TextService_0 (copy)
    assert(v2.Vector2(v37));
    assert(v2.number(v39));
    local v40 = v39 or 1;
    local v41 = v36(v38, v40);
    local v42 = v37 / v40 - v38.AbsolutePosition / v40;
    if v42.X < 0 or v42.X > v38.AbsoluteSize.X / v40 then
        return nil;
    else
        local v43 = math.floor(v42.Y / v38.TextSize) + 1;
        local v44 = v41[v43];
        if not v44 then
            return nil;
        else
            local v45 = 0;
            for _, v47 in utf8.codes(v44) do
                local v48 = utf8.char(v47);
                v45 = v45 + l_TextService_0:GetTextSize(v48, v38.TextSize, v38.Font, Vector2.new()).X;
                if v42.X <= v45 then
                    return v48, v43;
                end;
            end;
            return nil, v43;
        end;
    end;
end;
ModuleScriptL GetStringArticle
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {
    "a", 
    "e", 
    "i", 
    "o", 
    "u"
};
return function(v1) --[[ Line: 6 ]] --[[ Name: GetStringArticle ]]
    -- upvalues: v0 (copy)
    local v2 = string.sub(v1, 1, 2);
    local v3 = string.sub(v1, 1, 1);
    local v4 = string.sub(v1, 2, 2);
    local v5 = table.find(v0, v3:lower());
    if v3:lower() == "h" and table.find(v0, v4:lower()) and v1:lower() ~= "husky" then
        return "an";
    elseif v2:lower() == "eu" or v2:lower() == "ui" then
        return "a";
    elseif v1:lower() == "unique" or v1:lower() == "unicorn" then
        return "a";
    elseif v5 then
        return "an";
    else
        return "a";
    end;
end;
ModuleScript: GetSuffix
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {
    "K", 
    "M", 
    "B", 
    "T", 
    "Qa", 
    "Qi", 
    "Sx", 
    "Sp", 
    "Oc", 
    "No", 
    "Dc", 
    "Ud", 
    "Dd", 
    "Td", 
    "Qad", 
    "Qid", 
    "Spd", 
    "Opd", 
    "Npd", 
    "Vpd", 
    "Uvg", 
    "Dvg", 
    "Tvg", 
    "Qavg", 
    "Qivg", 
    "Sxvg", 
    "Spvg", 
    "Ocvg", 
    "Novg", 
    "Tg", 
    "Utg", 
    "Dtg", 
    "Ttg", 
    "Qatg", 
    "Qitg", 
    "Sxtg", 
    "Sptg", 
    "Octg", 
    "Notg", 
    "Qag", 
    "UQag", 
    "DQag", 
    "TQag", 
    "QaQag", 
    "QiQag", 
    "SxQag", 
    "SpQag", 
    "OcQag", 
    "NoQag", 
    "Qig", 
    "UQig", 
    "DQig", 
    "TQig", 
    "QaQig", 
    "QiQig", 
    "SxQig", 
    "SpQig", 
    "OcQig", 
    "NoQig", 
    "Sxg", 
    "USxg", 
    "DSxg", 
    "TSxg", 
    "QaSxg", 
    "QiSxg", 
    "SxSxg", 
    "SpSxg", 
    "OcSxg", 
    "NoSxg", 
    "Spg", 
    "USpg", 
    "DSpg", 
    "TSpg", 
    "QaSpg", 
    "QiSpg", 
    "SxSpg", 
    "SpSpg", 
    "OcSpg", 
    "NoSpg", 
    "Ocg", 
    "UOcg", 
    "DOcg", 
    "TOcg", 
    "QaOcg", 
    "QiOcg", 
    "SxOcg", 
    "SpOcg", 
    "OcOcg", 
    "NoOcg", 
    "Nog", 
    "UNog", 
    "DNog", 
    "TNog", 
    "QaNog", 
    "QiNog", 
    "SxNog", 
    "SpNog", 
    "OcNog", 
    "NoNog", 
    "C"
};
return function(v1) --[[ Line: 15 ]] --[[ Name: GetSuffix ]]
    -- upvalues: v0 (copy)
    local v2 = false;
    if type(v1) == "number" then
        v2 = v1 > 0;
    end;
    assert(v2, "Index must be a positive number");
    local v3 = (v1 - 1) % #v0 + 1;
    v2 = math.floor((v1 - 1) / #v0);
    local v4 = v0[v3];
    if v2 > 0 then
        v4 = string.rep(v4, v2 + 1);
    end;
    return v4;
end;
ModuleScript: Trim
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
return function(v2) --[[ Line: 10 ]] --[[ Name: Trim ]]
    -- upvalues: v1 (copy)
    assert(v1.string(v2));
    return (v2:gsub("^%s*(.-)%s*$", "%1"));
end;
ModuleScript: UpperCaseFirstLetter
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
return function(v2) --[[ Line: 10 ]] --[[ Name: UpperCaseFirstLetter ]]
    -- upvalues: v1 (copy)
    assert(v1.string(v2));
    return string.upper(v2:sub(1, 1)) .. string.sub(v2, 2);
end;
ModuleScript: Array
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local v2 = {};
v2.__index = v2;
local v3 = Random.new();
local v4 = v1.keys(v1.integer);
v2.from = function(v5) --[[ Line: 38 ]] --[[ Name: from ]]
    -- upvalues: v1 (copy), v4 (copy), v2 (copy)
    assert(v1.table(v5));
    assert(v4(v5));
    return (setmetatable({
        _data = table.clone(v5)
    }, v2));
end;
v2.every = function(v6, v7) --[[ Line: 48 ]] --[[ Name: every ]]
    -- upvalues: v1 (copy)
    assert(v1.callback(v7));
    for v8 = 1, #v6._data do
        if v7(v6._data[v8]) == false then
            return false;
        end;
    end;
    return true;
end;
v2.filter = function(v9, v10) --[[ Line: 59 ]] --[[ Name: filter ]]
    -- upvalues: v1 (copy), v2 (copy)
    assert(v1.callback(v10));
    local v11 = table.clone(v9._data);
    for v12 = #v9._data, 1, -1 do
        if not v10(v11[v12]) then
            table.remove(v11, v12);
        end;
    end;
    return v2.from(v11);
end;
v2.includes = function(v13, v14) --[[ Line: 71 ]] --[[ Name: includes ]]
    -- upvalues: v1 (copy)
    assert(not v1.none(v14));
    return table.find(v13._data, v14) ~= nil;
end;
v2.indexOf = function(v15, v16, v17) --[[ Line: 77 ]] --[[ Name: indexOf ]]
    -- upvalues: v1 (copy)
    assert(not v1.none(v16));
    assert(v1.none(v16) or v1.integer(v17));
    for v18 = v17 or 1, #v15._data do
        if v15._data[v18] == v16 then
            return v18;
        end;
    end;
    return nil;
end;
v2.map = function(v19, v20) --[[ Line: 89 ]] --[[ Name: map ]]
    -- upvalues: v1 (copy), v2 (copy)
    assert(v1.callback(v20));
    local v21 = {};
    for v22 = 1, #v19._data do
        local v23 = v20(v19._data[v22]);
        if v23 then
            v21[#v21 + 1] = v23;
        end;
    end;
    return v2.from(v21);
end;
v2.pop = function(v24) --[[ Line: 102 ]] --[[ Name: pop ]]
    local v25 = table.clone(v24._data);
    return table.remove(v25);
end;
v2.push = function(v26, ...) --[[ Line: 108 ]] --[[ Name: push ]]
    for _, v28 in ipairs({
        ...
    }) do
        v26._data[#v26._data + 1] = v28;
    end;
    return #v26._data;
end;
v2.shuffle = function(v29) --[[ Line: 116 ]] --[[ Name: shuffle ]]
    -- upvalues: v3 (copy), v2 (copy)
    local v30 = table.clone(v29._data);
    for v31 = #v29._data, 2, -1 do
        local v32 = v3:NextInteger(1, v31);
        local v33 = v30[v32];
        local v34 = v30[v31];
        v30[v31] = v33;
        v30[v32] = v34;
    end;
    return v2.from(v30);
end;
v2.random = function(v35) --[[ Line: 127 ]] --[[ Name: random ]]
    -- upvalues: v3 (copy)
    return v35._data[v3:NextInteger(1, #v35._data)];
end;
v2.reduce = function(v36, v37, v38) --[[ Line: 132 ]] --[[ Name: reduce ]]
    -- upvalues: v1 (copy)
    assert(v1.callback(v37));
    assert(not v1.none(v38));
    for v39 = 1, #v36._data do
        v38 = v37(v38, v36._data[v39], v39);
    end;
    return v38;
end;
v2.shift = function(v40) --[[ Line: 142 ]] --[[ Name: shift ]]
    -- upvalues: v2 (copy)
    local v41 = table.clone(v40._data);
    table.remove(v41, 1);
    return v2.from(v41);
end;
v2.slice = function(v42, v43, v44) --[[ Line: 149 ]] --[[ Name: slice ]]
    -- upvalues: v1 (copy), v2 (copy)
    assert(v1.none(v43) or v1.integer(v43));
    assert(v1.none(v44) or v1.integer(v44));
    v43 = if v43 and v43 < 0 then #v42._data + v43 + 1 else (v43 or 0) + 1;
    v44 = if v44 then if v44 < 0 then #v42._data + v44 + 1 else v44 + 1 else #v42._data + 1;
    assert(v43);
    assert(v44);
    local v45 = {};
    for v46 = v43, v44 - 1 do
        table.insert(v45, v42._data[v46]);
    end;
    return v2.from(v45);
end;
v2.sort = function(v47, v48) --[[ Line: 180 ]] --[[ Name: sort ]]
    -- upvalues: v1 (copy), v2 (copy)
    assert(v1.callback(v48));
    local v49 = table.clone(v47._data);
    table.sort(v49, v48);
    return v2.from(v49);
end;
v2.table = function(v50) --[[ Line: 188 ]] --[[ Name: table ]]
    return v50._data;
end;
v2.toString = function(v51) --[[ Line: 193 ]] --[[ Name: toString ]]
    return table.concat(v51._data, ", ");
end;
return v2;
ModuleScript: CompareTable
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local function v0(v1, v2, v3) --[[ Line: 3 ]] --[[ Name: CompareTable ]]
    -- upvalues: v0 (copy)
    if not v1 or not v2 then
        return false;
    elseif #v1 ~= #v2 then
        return false;
    else
        for v4, v5 in pairs(v1) do
            local v6 = v2[v4];
            if type(v5) ~= type(v6) then
                return false;
            elseif not v3 or type(v5) ~= "function" or type(v6) ~= "function" then
                if type(v5) == "table" then
                    if not v0(v5, v6, v3) then
                        return false;
                    end;
                elseif v5 ~= v6 then
                    return false;
                end;
            end;
        end;
        for v7, _ in pairs(v2) do
            if v1[v7] == nil then
                return false;
            end;
        end;
        return true;
    end;
end;
return v0;
ModuleScript: CountKeys
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
return function(v2) --[[ Line: 7 ]] --[[ Name: CountKeys ]]
    -- upvalues: v1 (copy)
    assert(v1.table(v2));
    local v3 = 0;
    for _ in v2 do
        v3 = v3 + 1;
    end;
    return v3;
end;
ModuleScript: DeepCopy
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
return function(v2) --[[ Line: 7 ]] --[[ Name: CountKeys ]]
    -- upvalues: v1 (copy)
    assert(v1.table(v2));
    local v3 = 0;
    for _ in v2 do
        v3 = v3 + 1;
    end;
    return v3;
end;
ModuleScript: Seriallize
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.T);
local function v2(v3, v4, v5, v6) --[[ Line: 13 ]] --[[ Name: Serialize ]]
    -- upvalues: v1 (copy), v2 (copy)
    assert(v1.table(v3));
    assert(v1.number(v4));
    assert(v1.table(v5));
    v4 = v4 or 0;
    v6 = v6 or "";
    local v7 = "";
    local v8 = string.rep(" ", v4 + 1);
    for v9, v10 in pairs(v3) do
        local v11 = string.format("[%s] = ", type(v9) == "number" and v9 or "\"" .. tostring(v9) .. "\"");
        if type(v10) == "table" then
            if next(v10) == nil then
                v11 = v11 .. "{}";
            elseif v5 then
                local v12 = v6 .. (string.len(v6) == 0 and "" or ".") .. (type(v9) == "string" and tonumber(v9) and string.format("'%s'", v9) or v9);
                v11 = if v5[v12] then v11 .. string.format("\226\150\188 {\n%s\n%s}", v2(v10, v4 + 1, v5, v12), v8) else v11 .. "\226\150\182 { \226\128\166 }";
            else
                v11 = v11 .. string.format("\226\150\188 {\n%s\n%s}", v2(v10, v4 + 1), v8);
            end;
        else
            v11 = if type(v10) == "string" then v11 .. "\"" .. v10 .. "\"" else v11 .. tostring(v10);
        end;
        v7 = v7 .. v8 .. v11 .. ",\n";
    end;
    return string.format(v4 == 0 and "{\n%s\n}" or "%s", v7:sub(1, -3));
end;
return v2;
ModuleScript: TableDiff
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {};
local function _(v1) --[[ Line: 7 ]] --[[ Name: isEmpty ]]
    return next(v1) == nil;
end;
v0.diff = function(v3, v4) --[[ Line: 12 ]] --[[ Name: diff ]]
    -- upvalues: v0 (copy)
    assert(type(v3) == "table", "currentData must be a table");
    assert(type(v4) == "table", "newData must be a table");
    local v5 = {};
    for v6, v7 in pairs(v4) do
        local v8 = v3[v6];
        if v8 == nil then
            v5[v6] = {
                new = v7
            };
        elseif type(v8) ~= type(v7) or type(v8) ~= "table" and v8 ~= v7 then
            v5[v6] = {
                old = v8, 
                new = v7
            };
        elseif type(v8) == "table" then
            local v9 = v0.diff(v8, v7);
            if not (next(v9) == nil) then
                v5[v6] = v9;
            end;
        end;
    end;
    for v10, v11 in pairs(v3) do
        if v4[v10] == nil then
            v5[v10] = {
                old = v11
            };
        end;
    end;
    return v5;
end;
v0.patch = function(v12, v13) --[[ Line: 44 ]] --[[ Name: patch ]]
    -- upvalues: v0 (copy)
    assert(type(v12) == "table", "data must be a table");
    assert(type(v13) == "table", "changes must be a table");
    for v14, v15 in pairs(v13) do
        if v15.new ~= nil then
            v12[v14] = v15.new;
        elseif v15.old ~= nil then
            v12[v14] = nil;
        elseif type(v12[v14]) == "table" then
            v0.patch(v12[v14], v15);
        end;
    end;
end;
return v0;
ModuleScript: find
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local function v7(v0, v1, v2) --[[ Line: 3 ]] --[[ Name: search ]]
    local l_v0_0 = v0;
    for v4, v5 in v2 do
        if v4 == #v2 then
            local v6 = false;
            if l_v0_0[v5] == v1 then
                v6 = l_v0_0;
            end;
            return v6;
        else
            l_v0_0 = l_v0_0[v5];
            if l_v0_0 == nil then
                return nil;
            end;
        end;
    end;
    return nil;
end;
return function(v8, v9, ...) --[[ Line: 22 ]] --[[ Name: find ]]
    -- upvalues: v7 (copy)
    local v10 = nil;
    local v11 = table.pack(...);
    for _, v13 in v8 do
        v10 = v7(v13, v9, v11);
        if v10 then
            break;
        end;
    end;
    return v10;
end;
ModuleScript: AnimateColor
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_RunService_0 = game:GetService("RunService");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Client.LowDetail);
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Table.Array);
local v4 = Color3.fromRGB(255, 255, 255);
local l_Gradients_0 = l_ReplicatedStorage_0.Assets.Gradients;
local function _(v6) --[[ Line: 14 ]] --[[ Name: getExistingGradient ]]
    return v6:FindFirstChildWhichIsA("UIGradient");
end;
local function _(v8) --[[ Line: 19 ]] --[[ Name: getTemplateGradient ]]
    -- upvalues: l_Gradients_0 (copy)
    return assert(l_Gradients_0:FindFirstChild(v8), (("no gradient named '%*' exists"):format(v8)));
end;
local function _(v10, v11) --[[ Line: 24 ]] --[[ Name: setColor ]]
    if v10:IsA("TextLabel") then
        v10.TextColor3 = v11;
        return;
    elseif v10:IsA("ImageLabel") then
        v10.ImageColor3 = v11;
        return;
    elseif v10:IsA("UIStroke") then
        v10.Color = v11;
        return;
    else
        v10.BackgroundColor3 = v11;
        return;
    end;
end;
local function _(v13, v14) --[[ Line: 37 ]] --[[ Name: setupGradient ]]
    -- upvalues: l_Gradients_0 (copy)
    local v15 = assert(l_Gradients_0:FindFirstChild(v14), (("no gradient named '%*' exists"):format(v14)));
    local l_UIGradient_0 = v13:FindFirstChildWhichIsA("UIGradient");
    if l_UIGradient_0 ~= nil then
        l_UIGradient_0.Color = v15.Color;
        l_UIGradient_0.Offset = v15.Offset;
        l_UIGradient_0.Rotation = v15.Rotation;
        l_UIGradient_0.Transparency = v15.Transparency;
        return l_UIGradient_0;
    else
        l_UIGradient_0 = v15:Clone();
        l_UIGradient_0.Parent = v13;
        return l_UIGradient_0;
    end;
end;
local function v25(v18, v19) --[[ Line: 53 ]] --[[ Name: cycleSequenceColor ]]
    local l_Keypoints_0 = v18.Keypoints;
    if v19 == 0 then
        return l_Keypoints_0[1].Value;
    elseif v19 == 1 then
        return l_Keypoints_0[#l_Keypoints_0].Value;
    else
        for v21 = 1, #l_Keypoints_0 - 1 do
            local v22 = l_Keypoints_0[v21];
            local v23 = l_Keypoints_0[v21 + 1];
            if v22.Time <= v19 and v19 <= v23.Time then
                local v24 = v23.Time - v22.Time;
                if v24 == 0 then
                    return v22.Value;
                else
                    return v22.Value:Lerp(v23.Value, (v19 - v22.Time) / v24);
                end;
            end;
        end;
        return l_Keypoints_0[1].Value;
    end;
end;
local function v28(v26, v27) --[[ Line: 77 ]] --[[ Name: compareKeypointTime ]]
    return v26.Time < v27.Time;
end;
local function v40(v29, v30) --[[ Line: 82 ]] --[[ Name: shiftSequenceTime ]]
    -- upvalues: v28 (copy)
    local v31 = {};
    for v32, v33 in v29.Keypoints do
        local v34 = (v33.Time + v30) % 1;
        if v32 <= 1 or v31[v32 - 1].Time ~= v34 then
            table.insert(v31, ColorSequenceKeypoint.new(v34, v33.Value));
        end;
    end;
    table.sort(v31, v28);
    local v35 = v31[1];
    local v36 = v31[#v31];
    local l_Time_0 = v35.Time;
    local v38 = 1 - v36.Time;
    local v39 = v36.Value:Lerp(v35.Value, v38 / (l_Time_0 + v38));
    if l_Time_0 > 0 then
        table.insert(v31, 1, ColorSequenceKeypoint.new(0, v39));
    end;
    if v38 > 0 then
        table.insert(v31, ColorSequenceKeypoint.new(1, v39));
    end;
    return ColorSequence.new(v31);
end;
local v41 = {};
local v43 = v3.from(l_Gradients_0:GetChildren()):filter(function(v42) --[[ Line: 135 ]]
    return v42:IsA("UIGradient");
end):table();
local v44 = 0;
local v45 = 0;
local function v64(v46) --[[ Line: 142 ]] --[[ Name: updateEffects ]]
    -- upvalues: v44 (ref), v45 (ref), v43 (copy), v41 (copy), v25 (copy), v40 (copy)
    v44 = v44 + v46;
    v45 = v45 + 1;
    local v47 = {};
    for _, v49 in v43 do
        v47[v49.Name] = {
            [0] = v49.Color.Keypoints[1].Value
        };
    end;
    local v50 = {};
    for _, v52 in v43 do
        v50[v52.Name] = {
            [0] = v52.Color
        };
    end;
    for v53, v54 in v41 do
        if not v53.Parent then
            v41[v53] = nil;
        elseif v54.Kind == "Cycle" then
            local v55 = v44 * v54.Speed % 1;
            local v56 = v47[v54.Name][v55];
            if not v56 then
                v56 = v25(v54.Color, v55);
                v47[v54.Name][v55] = v56;
            end;
            local l_v56_0 = v56;
            if v53:IsA("TextLabel") then
                v53.TextColor3 = l_v56_0;
            elseif v53:IsA("ImageLabel") then
                v53.ImageColor3 = l_v56_0;
            elseif v53:IsA("UIStroke") then
                v53.Color = l_v56_0;
            else
                v53.BackgroundColor3 = l_v56_0;
            end;
        elseif v54.Kind == "Shift" then
            local v58 = v44 * v54.Speed % 1;
            local v59 = v50[v54.Name][v58];
            if not v59 then
                v59 = v40(v54.Color, v58);
                v50[v54.Name][v58] = v59;
            end;
            v54.Gradient.Color = v59;
        elseif v54.Kind == "Pulse" then
            local v60 = 1 / v54.Speed;
            local l_Interval_0 = v54.Interval;
            local v62 = v44 % l_Interval_0;
            if v62 < v60 then
                local v63 = v62 / v60;
                v54.Gradient.Offset = v54.Direction * (v63 * 2 - 1);
            else
                v54.Gradient.Offset = -v54.Direction;
            end;
        end;
    end;
end;
l_RunService_0.Heartbeat:Connect(v64);
return {
    None = function(v65) --[[ Line: 220 ]] --[[ Name: None ]]
        -- upvalues: v4 (copy), v41 (copy)
        local l_UIGradient_1 = v65:FindFirstChildWhichIsA("UIGradient");
        if l_UIGradient_1 then
            l_UIGradient_1:Destroy();
        end;
        local l_v4_0 = v4;
        if v65:IsA("TextLabel") then
            v65.TextColor3 = l_v4_0;
        elseif v65:IsA("ImageLabel") then
            v65.ImageColor3 = l_v4_0;
        elseif v65:IsA("UIStroke") then
            v65.Color = l_v4_0;
        else
            v65.BackgroundColor3 = l_v4_0;
        end;
        v41[v65] = nil;
    end, 
    Color3 = function(v68, v69) --[[ Line: 230 ]] --[[ Name: Color3 ]]
        -- upvalues: v41 (copy)
        local l_UIGradient_2 = v68:FindFirstChildWhichIsA("UIGradient");
        if l_UIGradient_2 then
            l_UIGradient_2:Destroy();
        end;
        if v68:IsA("TextLabel") then
            v68.TextColor3 = v69;
        elseif v68:IsA("ImageLabel") then
            v68.ImageColor3 = v69;
        elseif v68:IsA("UIStroke") then
            v68.Color = v69;
        else
            v68.BackgroundColor3 = v69;
        end;
        v41[v68] = nil;
    end, 
    Static = function(v71, v72) --[[ Line: 240 ]] --[[ Name: Static ]]
        -- upvalues: v4 (copy), l_Gradients_0 (copy), v41 (copy)
        local l_v4_1 = v4;
        if v71:IsA("TextLabel") then
            v71.TextColor3 = l_v4_1;
        elseif v71:IsA("ImageLabel") then
            v71.ImageColor3 = l_v4_1;
        elseif v71:IsA("UIStroke") then
            v71.Color = l_v4_1;
        else
            v71.BackgroundColor3 = l_v4_1;
        end;
        l_v4_1 = assert(l_Gradients_0:FindFirstChild(v72), (("no gradient named '%*' exists"):format(v72)));
        local l_UIGradient_3 = v71:FindFirstChildWhichIsA("UIGradient");
        if l_UIGradient_3 ~= nil then
            l_UIGradient_3.Color = l_v4_1.Color;
            l_UIGradient_3.Offset = l_v4_1.Offset;
            l_UIGradient_3.Rotation = l_v4_1.Rotation;
            l_UIGradient_3.Transparency = l_v4_1.Transparency;
        else
            l_v4_1:Clone().Parent = v71;
        end;
        v41[v71] = nil;
    end, 
    Cycle = function(v75, v76, v77) --[[ Line: 247 ]] --[[ Name: Cycle ]]
        -- upvalues: v41 (copy), l_Gradients_0 (copy)
        local l_UIGradient_4 = v75:FindFirstChildWhichIsA("UIGradient");
        if l_UIGradient_4 then
            l_UIGradient_4:Destroy();
        end;
        v41[v75] = {
            Kind = "Cycle", 
            Name = v76, 
            Color = assert(l_Gradients_0:FindFirstChild(v76), (("no gradient named '%*' exists"):format(v76))).Color, 
            Speed = v77.Speed
        };
    end, 
    Shift = function(v79, v80, v81) --[[ Line: 267 ]] --[[ Name: Shift ]]
        -- upvalues: l_Gradients_0 (copy), v41 (copy), v4 (copy)
        local v82 = assert(l_Gradients_0:FindFirstChild(v80), (("no gradient named '%*' exists"):format(v80)));
        local l_UIGradient_5 = v79:FindFirstChildWhichIsA("UIGradient");
        if l_UIGradient_5 ~= nil then
            l_UIGradient_5.Color = v82.Color;
            l_UIGradient_5.Offset = v82.Offset;
            l_UIGradient_5.Rotation = v82.Rotation;
            l_UIGradient_5.Transparency = v82.Transparency;
        else
            l_UIGradient_5 = v82:Clone();
            l_UIGradient_5.Parent = v79;
        end;
        local l_l_UIGradient_5_0 = l_UIGradient_5;
        v41[v79] = {
            Kind = "Shift", 
            Name = v80, 
            Color = l_l_UIGradient_5_0.Color, 
            Speed = v81.Speed, 
            Gradient = l_l_UIGradient_5_0
        };
        v82 = v4;
        if v79:IsA("TextLabel") then
            v79.TextColor3 = v82;
            return;
        elseif v79:IsA("ImageLabel") then
            v79.ImageColor3 = v82;
            return;
        elseif v79:IsA("UIStroke") then
            v79.Color = v82;
            return;
        else
            v79.BackgroundColor3 = v82;
            return;
        end;
    end, 
    Pulse = function(v85, v86, v87) --[[ Line: 286 ]] --[[ Name: Pulse ]]
        -- upvalues: v4 (copy), l_Gradients_0 (copy), v41 (copy)
        local l_v4_2 = v4;
        if v85:IsA("TextLabel") then
            v85.TextColor3 = l_v4_2;
        elseif v85:IsA("ImageLabel") then
            v85.ImageColor3 = l_v4_2;
        elseif v85:IsA("UIStroke") then
            v85.Color = l_v4_2;
        else
            v85.BackgroundColor3 = l_v4_2;
        end;
        local v89 = assert(l_Gradients_0:FindFirstChild(v86), (("no gradient named '%*' exists"):format(v86)));
        local l_UIGradient_6 = v85:FindFirstChildWhichIsA("UIGradient");
        if l_UIGradient_6 ~= nil then
            l_UIGradient_6.Color = v89.Color;
            l_UIGradient_6.Offset = v89.Offset;
            l_UIGradient_6.Rotation = v89.Rotation;
            l_UIGradient_6.Transparency = v89.Transparency;
        else
            l_UIGradient_6 = v89:Clone();
            l_UIGradient_6.Parent = v85;
        end;
        v41[v85] = {
            Kind = "Pulse", 
            Name = v86, 
            Gradient = l_UIGradient_6, 
            Interval = v87.Interval, 
            Speed = v87.Speed, 
            Direction = v87.Direction or Vector2.xAxis
        };
    end
};
ModuleScript: ApplyMultiplierToPool
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.GetRandomWeightedItem);
return function(v3, v4, v5, v6) --[[ Line: 11 ]] --[[ Name: ApplyMultiplierToPool ]]
    local v7 = table.create(#v3);
    local v8 = 0;
    for v9, v10 in ipairs(v3) do
        if v5(v10) == true then
            local v11 = v10.Chance * v4;
            local v12 = table.clone(v10);
            v8 = v8 + (v11 - v12.Chance);
            v12.Chance = v11;
            v7[v9] = v12;
        else
            v7[v9] = table.clone(v10);
        end;
    end;
    if v8 > 0 then
        local v13 = {};
        for v14, v15 in ipairs(v3) do
            if not v5(v15) and v6 and not v6(v15) then
                v13[#v13 + 1] = v14;
            end;
        end;
        if #v13 > 0 then
            local v16 = v8 / #v13;
            for _, v18 in ipairs(v13) do
                local v19 = v7[v18];
                v19.Chance = math.max(0, v19.Chance - v16);
            end;
        end;
    end;
    return v7;
end;
ModuleScript: BoardUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Table.Array);
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.GetRandomWeightedItem);
local l_Board_0 = workspace.Board;
local v9 = v1.from(l_Board_0.Nodes:GetChildren()):sort(function(v4, v5) --[[ Line: 30 ]]
    return tonumber(v4.Name) < tonumber(v5.Name);
end):map(function(v6) --[[ Line: 33 ]]
    local v7 = v6:GetAttribute("Weight") or 1;
    local v8 = v6:GetAttribute("Type") or "basic";
    return {
        Part = v6, 
        Weight = v7, 
        Type = v8
    };
end):table();
local v10 = {
    Model = l_Board_0, 
    Nodes = v9, 
    Pieces = {
        [1] = "Doggy", 
        [2] = "Kitty"
    }, 
    ChanceTiles = {
        {
            Chance = 40, 
            Item = "insta-rift"
        }, 
        {
            Chance = 50, 
            Item = "server-luck"
        }, 
        {
            Chance = 10, 
            Item = "elixir"
        }
    }, 
    ChanceTile = {
        ["insta-rift"] = {
            DisplayName = "Instant Rift Spawn (x10\240\159\141\128)", 
            Color = "Rainbow"
        }, 
        ["server-luck"] = {
            DisplayName = "\240\159\141\128 +400% Server Luck (5 mins)", 
            Color = Color3.fromRGB(82, 255, 73)
        }, 
        elixir = {
            DisplayName = "Instant Infinity Elixir (10 mins)", 
            Color = "Rainbow"
        }
    }
};
v10.ResolveNodes = function(_, v12, v13) --[[ Line: 82 ]] --[[ Name: ResolveNodes ]]
    -- upvalues: v10 (copy)
    local v14 = {};
    local l_v12_0 = v12;
    for _ = 1, v13 do
        l_v12_0 = l_v12_0 + 1;
        if #v10.Nodes < l_v12_0 then
            l_v12_0 = 1;
        end;
        table.insert(v14, v10.Nodes[l_v12_0]);
    end;
    return v14;
end;
v10.ToWeights = function(_, v18) --[[ Line: 96 ]] --[[ Name: ToWeights ]]
    local v19 = {};
    for v20, v21 in v18 do
        table.insert(v19, {
            Chance = v21.Weight, 
            Item = v20
        });
    end;
    return v19;
end;
v10.Roll = function(_, v23) --[[ Line: 108 ]] --[[ Name: Roll ]]
    -- upvalues: v10 (copy), v2 (copy)
    local v24 = v10:ToWeights(v23);
    local v25 = v2(v24) or 1;
    return v25, v23[v25];
end;
return v10;
ModuleScript: Chunker
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Signal);
local v2 = {};
v2.__index = v2;
v2.new = function(v3, v4) --[[ Line: 40 ]] --[[ Name: new ]]
    -- upvalues: v1 (copy), v2 (copy)
    local l_Folder_0 = Instance.new("Folder");
    l_Folder_0.Name = "Chunker";
    l_Folder_0.Parent = workspace.Rendered;
    return (setmetatable({
        _chunks = {}, 
        _loaded = {}, 
        _chunkSize = v3, 
        _folder = l_Folder_0, 
        Loaded = v1.new(), 
        Unloaded = v1.new(), 
        RenderDistance = v4 or 1, 
        Mode = "2D"
    }, v2));
end;
v2.ToCoord = function(v6, v7) --[[ Line: 61 ]] --[[ Name: ToCoord ]]
    local v8 = Vector3.new(math.round(v7.X / v6._chunkSize + 0.5), math.round(v7.Y / v6._chunkSize + 0.5), (math.round(v7.Z / v6._chunkSize + 0.5)));
    if v6.Mode == "2D" then
        return v8 * Vector3.new(1, 0, 1, 0);
    else
        return v8;
    end;
end;
v2.Add = function(v9, v10, v11) --[[ Line: 73 ]] --[[ Name: Add ]]
    local v12 = v9:ToCoord(v10);
    local v13 = v9._chunks[v12];
    if not v13 then
        v13 = {};
        v9._chunks[v12] = v13;
    end;
    if table.find(v13, v11) then
        return;
    else
        local v14 = v9._loaded[v12] ~= nil;
        if typeof(v11) == "Instance" then
            v11.Parent = v14 and v9._folder or nil;
        end;
        if v14 then
            v9.Loaded:Fire(v11, v12);
        end;
        table.insert(v13, v11);
        return;
    end;
end;
v2.Remove = function(v15, v16, v17) --[[ Line: 94 ]] --[[ Name: Remove ]]
    local v18 = v15:ToCoord(v16);
    local v19 = v15._chunks[v18];
    if not v19 then
        return;
    else
        for v20, v21 in v19 do
            if v21 == v17 then
                v19[v20] = nil;
                v15.Unloaded:Fire(v17, v18);
                break;
            end;
        end;
        if not next(v19) then
            table.clear(v19);
            v15._chunks[v18] = nil;
        end;
        return;
    end;
end;
v2.GetChunk = function(v22, v23) --[[ Line: 115 ]] --[[ Name: GetChunk ]]
    return v22._chunks[v23];
end;
v2.GetChunkFromPosition = function(v24, v25) --[[ Line: 119 ]] --[[ Name: GetChunkFromPosition ]]
    return v24:GetChunk(v24:ToCoord(v25));
end;
v2.IsLoaded = function(v26, v27) --[[ Line: 123 ]] --[[ Name: IsLoaded ]]
    return v26._loaded[v27] ~= nil;
end;
v2.IsValueLoaded = function(v28, v29) --[[ Line: 127 ]] --[[ Name: IsValueLoaded ]]
    for v30 in v28._loaded do
        local v31 = v28._chunks[v30];
        if v31 then
            for _, v33 in v31 do
                if v33 == v29 then
                    return true;
                end;
            end;
        end;
    end;
    return false;
end;
v2.Update = function(v34, v35) --[[ Line: 142 ]] --[[ Name: Update ]]
    local v36 = v34:ToCoord(v35);
    local v37 = v34.RenderDistance - 1;
    local v38 = {};
    if v34.Mode == "2D" then
        for v39 = -v37, v37 do
            for v40 = -v37, v37 do
                v38[v36 + Vector3.new(v39, 0, v40)] = true;
            end;
        end;
    else
        for v41 = -v37, v37 do
            for v42 = -v37, v37 do
                for v43 = -v37, v37 do
                    v38[v36 + Vector3.new(v41, v42, v43)] = true;
                end;
            end;
        end;
    end;
    for v44 in v38 do
        local l_v34_Chunk_0 = v34:GetChunk(v44);
        if l_v34_Chunk_0 and not v34._loaded[v44] then
            for _, v47 in l_v34_Chunk_0 do
                if typeof(v47) == "Instance" then
                    v47.Parent = v34._folder;
                end;
                v34.Loaded:Fire(v47, v44);
            end;
            v34._loaded[v44] = true;
        end;
    end;
    for v48 in v34._loaded do
        local l_v34_Chunk_1 = v34:GetChunk(v48);
        if l_v34_Chunk_1 and not v38[v48] then
            for _, v51 in l_v34_Chunk_1 do
                if typeof(v51) == "Instance" then
                    v51.Parent = nil;
                end;
                v34.Unloaded:Fire(v51, v36);
            end;
            v34._loaded[v48] = nil;
        end;
    end;
end;
return v2;
ModuleScript: CreatePlayerPet
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local l_HttpService_0 = game:GetService("HttpService");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v3 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local _ = require(l_ReplicatedStorage_0.Shared.Utils.PetLevelUtil);
local _ = require(l_ReplicatedStorage_0.Shared.Constants);
local v6 = require(l_ReplicatedStorage_0.Shared.Utils.EnchantUtil);
return function(v7, v8, v9) --[[ Line: 22 ]] --[[ Name: CreatePlayerPet ]]
    -- upvalues: v3 (copy), l_HttpService_0 (copy), v6 (copy)
    local _ = v3[v8].Rarity;
    local v11 = v9.XP or 0;
    local v12 = {
        Id = l_HttpService_0:GenerateGUID(false), 
        Name = v8, 
        Amount = if v9.Amount and v9.Amount > 1 then v9.Amount else nil, 
        Shiny = v9.Shiny == true or nil, 
        Mythic = v9.Mythic == true or nil, 
        XP = v11
    };
    if v12.Amount == nil and v11 > 0 then
        v6:FillPetEnchants(v7, v12);
    end;
    return v12;
end;
ModuleScript: CurrencyUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Data.Currency);
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v3 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.ItemUtil);
return {
    CurrencyMultUpdateKeys = {
        "Teams", 
        "TeamsEquipped", 
        "Gamepasses", 
        "ActivePotions", 
        "ActiveBuffs"
    }, 
    GetDataKeys = function(_) --[[ Line: 19 ]] --[[ Name: GetDataKeys ]]
        -- upvalues: v1 (copy)
        local v5 = {};
        for v6 in v1 do
            if v6 ~= "Points" and v6 ~= "Stars" and v6 ~= "ChallengePoints" then
                table.insert(v5, v6);
            end;
        end;
        table.insert(v5, "Season");
        table.insert(v5, "DailyRewards");
        table.insert(v5, "ChallengePass");
        return v5;
    end, 
    GetBalance = function(_, v8, v9) --[[ Line: 36 ]] --[[ Name: GetBalance ]]
        -- upvalues: v3 (copy)
        return v3:GetOwnedAmount(v8, {
            Type = "Currency", 
            Currency = v9, 
            Amount = 0
        });
    end
};
ModuleScript: DoggyJumpUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Builders.LootPoolBuilder);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.GetRandomWeightedItem);
return {
    RefreshPeriod = 1800, 
    PrizeScores = {
        100, 
        250, 
        500
    }, 
    PointsPerSecond = 10.2, 
    GetPrizes = function(_, _, _) --[[ Line: 19 ]] --[[ Name: GetPrizes ]]
        return {
            {
                Type = "Currency", 
                Currency = "Coins", 
                Amount = 350
            }, 
            {
                Type = "Potion", 
                Name = "Lucky", 
                Level = 3, 
                Amount = 1
            }, 
            {
                Type = "Powerup", 
                Name = "Mystery Box", 
                Amount = 1
            }
        };
    end
};
ModuleScript: EnchantUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Data.Enchants);
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatRomanNumeral);
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.GetRandomWeightedItem);
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v5 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local _ = require(l_ReplicatedStorage_0.Shared.Utils.PetLevelUtil);
local v7 = require(l_ReplicatedStorage_0.Shared.Constants);
local v8 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.BuffUtil);
local v9 = {};
local _ = v7.RarityOrder;
v9.GetIdentifier = function(_, v12, v13) --[[ Line: 22 ]] --[[ Name: GetIdentifier ]]
    return (("%*/%*"):format(v12, v13));
end;
v9.GetFullTitle = function(_, v15, v16, v17) --[[ Line: 27 ]] --[[ Name: GetFullTitle ]]
    -- upvalues: v1 (copy), v2 (copy)
    local v18 = v1[v15];
    local l_DisplayName_0 = v18.DisplayName;
    if v18.Levels > 1 then
        l_DisplayName_0 = ("%* %*"):format(l_DisplayName_0, (v2(v16)));
    end;
    if v17 ~= true then
        l_DisplayName_0 = ("%* %*"):format(v18.Emoji, l_DisplayName_0);
    end;
    return l_DisplayName_0;
end;
v9.GetDescription = function(_, v21, v22) --[[ Line: 40 ]] --[[ Name: GetDescription ]]
    -- upvalues: v1 (copy), v8 (copy)
    local v23 = v1[v21];
    return (v8:Format(v23.Description, v23.Buffs[v22]));
end;
v9.IsEnchantable = function(_, _) --[[ Line: 48 ]] --[[ Name: IsEnchantable ]]
    return true;
end;
local function v30(v26) --[[ Line: 55 ]] --[[ Name: getLootPool ]]
    -- upvalues: v1 (copy)
    local v27 = {};
    for v28, v29 in v1 do
        if not v26 or v26(v28) then
            table.insert(v27, {
                Item = v28, 
                Chance = v29.Weight
            });
        end;
    end;
    return v27;
end;
v9.GetPossibleEnchants = function(_, v32, v33) --[[ Line: 69 ]] --[[ Name: GetPossibleEnchants ]]
    -- upvalues: v5 (copy), v1 (copy)
    local v34 = {};
    local v35 = v5[v33];
    local v36 = false;
    for _, v38 in v32.MasteryUpgrades do
        if v38.Type == "Special" then
            v36 = true;
            break;
        end;
    end;
    local v39 = true;
    if v35.Rarity ~= "Secret" then
        v39 = false;
        if v35.Rarity == "Legendary" then
            v39 = (v35.Tier or 1) >= 3;
        end;
    end;
    for v40, v41 in v1 do
        if not v41.Special or v36 and v39 then
            table.insert(v34, v40);
        end;
    end;
    return v34;
end;
v9.GetRandomEnchant = function(_, v43, v44) --[[ Line: 94 ]] --[[ Name: GetRandomEnchant ]]
    -- upvalues: v9 (copy), v3 (copy), v30 (copy)
    local l_v9_PossibleEnchants_0 = v9:GetPossibleEnchants(v43, v44);
    return v3((v30(function(v46) --[[ Line: 97 ]]
        -- upvalues: l_v9_PossibleEnchants_0 (copy)
        return table.find(l_v9_PossibleEnchants_0, v46) ~= nil;
    end)));
end;
v9.GetUnusedEnchant = function(_, v48, v49, v50) --[[ Line: 103 ]] --[[ Name: GetUnusedEnchant ]]
    -- upvalues: v9 (copy), v3 (copy), v30 (copy)
    if not v49 or #v49 == 0 then
        return v9:GetRandomEnchant(v48, v50);
    else
        local v51 = {};
        for _, v53 in v49 do
            v51[v53.Id] = true;
        end;
        local l_v9_PossibleEnchants_1 = v9:GetPossibleEnchants(v48, v50);
        return v3((v30(function(v55) --[[ Line: 115 ]]
            -- upvalues: v51 (copy), l_v9_PossibleEnchants_1 (copy)
            return not v51[v55] and table.find(l_v9_PossibleEnchants_1, v55) ~= nil;
        end)));
    end;
end;
local v56 = Random.new();
v9.GetRandomLevel = function(_, v58) --[[ Line: 125 ]] --[[ Name: GetRandomLevel ]]
    -- upvalues: v1 (copy), v56 (copy)
    local v59 = v1[v58];
    local v60 = v56:NextNumber();
    return (math.clamp(math.ceil(v59.Levels * v60 ^ 4), 1, v59.Levels));
end;
v9.GetChance = function(_, v62, v63, v64, v65) --[[ Line: 136 ]] --[[ Name: GetChance ]]
    -- upvalues: v9 (copy), v1 (copy)
    local v66 = 0;
    for _, v68 in (v9:GetPossibleEnchants(v62, v65)) do
        v66 = v66 + v1[v68].Weight;
    end;
    local v69 = v1[v63];
    return v69.Weight / v66 * ((v64 / v69.Levels) ^ 0.25 - ((v64 - 1) / v69.Levels) ^ 0.25);
end;
v9.GetMaxEnchantSlots = function(_, v71) --[[ Line: 161 ]] --[[ Name: GetMaxEnchantSlots ]]
    -- upvalues: v5 (copy)
    local _ = v5[v71.Name].Rarity;
    local v73 = 1;
    if v71.Shiny == true then
        v73 = v73 + 1;
    end;
    return v73;
end;
v9.GetUnusedEnchantSlots = function(_, v75) --[[ Line: 174 ]] --[[ Name: GetUnusedEnchantSlots ]]
    -- upvalues: v9 (copy)
    local v76 = if v75.Enchants then #v75.Enchants else 0;
    return v9:GetMaxEnchantSlots(v75) - v76;
end;
v9.MakeEnchant = function(_, v78, v79) --[[ Line: 183 ]] --[[ Name: MakeEnchant ]]
    -- upvalues: v1 (copy)
    local _ = v1[v78];
    local v81 = nil;
    if v78 == "high-roller" or v78 == "infinity" then
        v81 = 0;
    end;
    return {
        Id = v78, 
        Level = v79, 
        Extra = v81
    };
end;
v9.FillPetEnchants = function(_, _, v84) --[[ Line: 203 ]] --[[ Name: FillPetEnchants ]]
    -- upvalues: v9 (copy)
    if v9:GetUnusedEnchantSlots(v84) <= 0 then
        return false;
    else
        v84.Enchants = v84.Enchants or {};
        return true;
    end;
end;
v9.UpdateDiscoveredEnchants = function(_, v86) --[[ Line: 242 ]] --[[ Name: UpdateDiscoveredEnchants ]]
    local v87 = {};
    local l_DiscoveredEnchants_0 = v86.DiscoveredEnchants;
    for _, v90 in v86.Pets do
        if v90.Enchants then
            for _, v92 in v90.Enchants do
                if not l_DiscoveredEnchants_0[v92.Id] then
                    l_DiscoveredEnchants_0[v92.Id] = {};
                end;
                if not table.find(l_DiscoveredEnchants_0[v92.Id], v92.Level) then
                    table.insert(l_DiscoveredEnchants_0[v92.Id], v92.Level);
                    table.insert(v87, {
                        Id = v92.Id, 
                        Level = v92.Level
                    });
                end;
            end;
        end;
    end;
    return v87;
end;
return v9;
ModuleScript: GetChanceColor
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1) --[[ Line: 3 ]] --[[ Name: GetChanceColor ]]
    if v1 then
        if v1 == "Exclusive Pet" then
            return Color3.fromRGB(112, 255, 35);
        elseif string.find(v1, "Season") then
            return Color3.fromRGB(255, 70, 73);
        else
            return Color3.fromRGB(146, 255, 159);
        end;
    else
        local v2 = 100 / v0;
        if v2 >= 5000000 then
            return Color3.fromRGB(255, 20, 212);
        elseif v2 >= 1000000 then
            return Color3.fromRGB(255, 70, 73);
        elseif v2 >= 500000 then
            return Color3.fromRGB(255, 79, 188);
        elseif v2 >= 100000 then
            return Color3.fromRGB(227, 144, 255);
        elseif v2 >= 50000 then
            return Color3.fromRGB(106, 248, 255);
        elseif v2 >= 10000 then
            return Color3.fromRGB(170, 255, 157);
        elseif v2 >= 1000 then
            return Color3.fromRGB(255, 230, 167);
        else
            return Color3.new(1, 1, 1);
        end;
    end;
end;
ModuleScript: GetEggPool
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Data.Eggs);
local v2 = require(l_ReplicatedStorage_0.Shared.Utils.ApplyMultiplierToPool);
local v3 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.ItemUtil);
local _ = require(l_ReplicatedStorage_0.Shared.Types);
return function(v5, v6, v7) --[[ Line: 11 ]] --[[ Name: GetEggPool ]]
    -- upvalues: v1 (copy), v2 (copy), v3 (copy)
    local v8 = v1[v5];
    if v8.World ~= v6 then
        v6 = "None";
    end;
    local v13 = v2(v8.Pool, math.min(4, v7), function(v9) --[[ Line: 22 ]]
        -- upvalues: v3 (ref)
        if v9.Item.Type ~= "Pet" then
            return false;
        else
            return v3:GetRarity(v9.Item) == "Epic";
        end;
    end, function(v10) --[[ Line: 29 ]]
        -- upvalues: v3 (ref)
        local l_v3_Rarity_0 = v3:GetRarity(v10.Item);
        local v12 = true;
        if l_v3_Rarity_0 ~= "Legendary" then
            v12 = l_v3_Rarity_0 == "Secret";
        end;
        return v12;
    end);
    return v2(v13, v7, function(v14) --[[ Line: 36 ]]
        -- upvalues: v3 (ref)
        if v14.Item.Type ~= "Pet" then
            return false;
        else
            local l_v3_Rarity_1 = v3:GetRarity(v14.Item);
            local v16 = true;
            if l_v3_Rarity_1 ~= "Legendary" then
                v16 = l_v3_Rarity_1 == "Secret";
            end;
            return v16;
        end;
    end);
end;
ModuleScript: GetFriendCountInServer
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_Players_0 = game:GetService("Players");
local _ = game:GetService("RunService");
local v2 = {};
local _ = function(v3) --[[ Line: 8 ]] --[[ Name: getFriendsAsync ]]
    -- upvalues: l_Players_0 (copy)
    local l_status_0, l_result_0 = pcall(function() --[[ Line: 9 ]]
        -- upvalues: l_Players_0 (ref), v3 (copy)
        local v4 = {};
        local l_l_Players_0_FriendsAsync_0 = l_Players_0:GetFriendsAsync(v3.UserId);
        while true do
            for _, v7 in l_l_Players_0_FriendsAsync_0:GetCurrentPage() do
                table.insert(v4, v7.Id);
            end;
            if not l_l_Players_0_FriendsAsync_0.IsFinished then
                l_l_Players_0_FriendsAsync_0:AdvanceToNextPageAsync();
            else
                break;
            end;
        end;
        return v4;
    end);
    if not l_status_0 then
        return {};
    else
        return l_result_0;
    end;
end;
local function v19(v11) --[[ Line: 31 ]] --[[ Name: onPlayerAdded ]]
    -- upvalues: l_Players_0 (copy), v2 (copy)
    local l_status_1, l_result_1 = pcall(function() --[[ Line: 9 ]]
        -- upvalues: l_Players_0 (ref), v11 (copy)
        local v12 = {};
        local l_l_Players_0_FriendsAsync_1 = l_Players_0:GetFriendsAsync(v11.UserId);
        while true do
            for _, v15 in l_l_Players_0_FriendsAsync_1:GetCurrentPage() do
                table.insert(v12, v15.Id);
            end;
            if not l_l_Players_0_FriendsAsync_1.IsFinished then
                l_l_Players_0_FriendsAsync_1:AdvanceToNextPageAsync();
            else
                break;
            end;
        end;
        return v12;
    end);
    local v18 = if not l_status_1 then {} else l_result_1;
    if not v11.Parent then
        return;
    else
        v2[v11] = v18;
        return;
    end;
end;
local function v21(v20) --[[ Line: 40 ]] --[[ Name: onPlayerRemoving ]]
    -- upvalues: v2 (copy)
    v2[v20] = nil;
end;
l_Players_0.PlayerAdded:Connect(v19);
l_Players_0.PlayerRemoving:Connect(v21);
for _, v23 in l_Players_0:GetPlayers() do
    task.spawn(v19, v23);
end;
return function(v24) --[[ Line: 51 ]] --[[ Name: GetFriendCountInServer ]]
    -- upvalues: v2 (copy), l_Players_0 (copy)
    local v25 = v2[v24];
    if not v25 then
        return 0;
    else
        local v26 = 0;
        for _, v28 in v25 do
            if l_Players_0:GetPlayerByUserId(v28) ~= nil then
                v26 = v26 + 1;
            end;
        end;
        return v26;
    end;
end;
ModuleScript: GetInfinityChest
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Data.Chests);
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v3 = require(l_ReplicatedStorage_0.Shared.Data.Builders.LootPoolBuilder);
local v4 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.ItemUtil);
local v5 = v1["Infinity Chest"];
return function(v6) --[[ Line: 14 ]] --[[ Name: GetInfinityChest ]]
    -- upvalues: v5 (copy), v3 (copy), v1 (copy), v4 (copy)
    local l_Cooldown_0 = v5.Cooldown;
    local l_Rolls_0 = v5.Rolls;
    local v9 = 1;
    local v10 = {};
    for _, v12 in workspace.Rendered.Chests:GetChildren() do
        if v12.Name ~= "Infinity Chest" then
            local l_v12_Attribute_0 = v12:GetAttribute("Island");
            if not l_v12_Attribute_0 or v6.AreasUnlocked[l_v12_Attribute_0] then
                v9 = v9 + 1;
                table.insert(v10, v12.Name);
            end;
        end;
    end;
    local v14 = table.clone(v5.Reward);
    local v15 = v3.new();
    for _, v17 in v10 do
        local v18 = v1[v17];
        if v18 then
            for _, v20 in v18.Pool do
                v15:Add(v20.Chance / v9, v20.Item);
            end;
            for _, v22 in v18.Reward do
                table.insert(v14, v22);
            end;
            l_Rolls_0 = l_Rolls_0 + v18.Rolls;
            l_Cooldown_0 = math.max(l_Cooldown_0, v18.Cooldown);
        end;
    end;
    local v23 = v15:Build();
    table.sort(v23, function(v24, v25) --[[ Line: 51 ]]
        return v24.Chance > v25.Chance;
    end);
    return {
        DevProduct = v5.DevProduct, 
        Rolls = l_Rolls_0, 
        Cooldown = l_Cooldown_0, 
        Reward = v4:Combine(v14), 
        Pool = v23
    };
end;
ModuleScript: GetInfinityEgg
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local l_RunService_0 = game:GetService("RunService");
local l_Players_0 = game:GetService("Players");
local l_ServerScriptService_0 = game:GetService("ServerScriptService");
local l_CollectionService_0 = game:GetService("CollectionService");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v6 = require(l_ReplicatedStorage_0.Shared.Data.Eggs);
local v7 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.ItemUtil);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Builders.LootPoolBuilder);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Currency);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.GetRandomWeightedItem);
local v11 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v12 = require(l_ReplicatedStorage_0.Shared.Constants);
local v13 = require(l_ReplicatedStorage_0.Shared.Data.Enchants);
local v14 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.BuffUtil);
local v15 = {};
local v16 = {};
local _ = function(v17, v18) --[[ Line: 34 ]] --[[ Name: generateKey ]]
    local v19 = "";
    for _, v21 in v17 do
        v19 = v19 .. string.sub(v21, 1, 3);
    end;
    return (("%*:%*"):format(v19, v18));
end;
local function v57(v23, v24) --[[ Line: 43 ]] --[[ Name: updateCache ]]
    -- upvalues: v6 (copy), v16 (copy), v7 (copy), v13 (copy), v14 (copy), v15 (copy), v12 (copy), v11 (copy)
    local v25 = {};
    local v26 = table.clone(v24.EggsOpened);
    if not v26["Common Egg"] then
        v26["Common Egg"] = 0;
    end;
    if not v26["Spikey Egg"] then
        v26["Spikey Egg"] = 0;
    end;
    if not v26["Nightmare Egg"] then
        v26["Nightmare Egg"] = 0;
    end;
    local v27 = 1;
    for v28 in v26 do
        local v29 = v6[v28];
        if v29 then
            v27 = math.max(v27, v29.LayoutOrder);
        end;
    end;
    local v30 = 0;
    for v31 in v16 do
        if v31 ~= "Infinity Egg" then
            local v32 = v6[v31];
            if v32 and not v32.ProductId and v32.Cost.Type == "Currency" and v32.Cost.Currency == "Coins" then
                v30 = math.max(v30, v7:GetAmount(v32.Cost));
                table.insert(v25, v31);
            end;
        end;
    end;
    table.sort(v25, function(v33, v34) --[[ Line: 81 ]]
        -- upvalues: v6 (ref)
        return v6[v33].LayoutOrder < v6[v34].LayoutOrder;
    end);
    for v35 = #v25, 1, -1 do
        if v27 < v6[v25[v35]].LayoutOrder then
            table.remove(v25, v35);
        end;
    end;
    local v36 = 0;
    local v37 = {};
    for _, v39 in v24.Pets do
        v37[v39.Id] = v39;
    end;
    local v40 = v13.infinity.Buffs[1];
    for _, v42 in v24.Teams[v24.TeamEquipped].Pets do
        local v43 = v37[v42];
        if v43 and v43.Enchants then
            for _, v45 in v43.Enchants do
                if v45.Id == "infinity" then
                    v36 = v14:GetValue(v36, v40);
                    break;
                end;
            end;
        end;
    end;
    local l_v36_0 = v36;
    local v47 = "";
    for _, v49 in v25 do
        v47 = v47 .. string.sub(v49, 1, 3);
    end;
    local v50 = ("%*:%*"):format(v47, l_v36_0);
    if v15[v23] and v15[v23].Key == v50 then
        return;
    else
        l_v36_0 = {
            {
                Chance = 60, 
                Item = "Common"
            }, 
            {
                Chance = 20, 
                Item = "Unique"
            }, 
            {
                Chance = 13, 
                Item = "Rare"
            }, 
            {
                Chance = 6.5, 
                Item = "Epic"
            }, 
            {
                Chance = 0.5, 
                Item = "Legendary"
            }, 
            {
                Chance = v12.SecretRarity, 
                Item = "Secret"
            }
        };
        v47 = {};
        for v51 in v12.RarityOrder do
            v47[v51] = {};
        end;
        for _, v53 in v25 do
            for _, v55 in v6[v53].Pool do
                if v55.Item.Type == "Pet" then
                    table.insert(v47[v11[v55.Item.Name].Rarity], {
                        Chance = v55.Chance, 
                        Item = v55.Item
                    });
                end;
            end;
        end;
        local v56 = math.max(1, (math.round(math.max(1, (math.floor(v30 / 2))) * (1 - v36))));
        v15[v23] = {
            Key = v50, 
            Rarities = l_v36_0, 
            Chances = v47, 
            Cost = {
                Type = "Currency", 
                Currency = "Coins", 
                Amount = math.ceil(v56)
            }
        };
        return;
    end;
end;
local function v59(v58) --[[ Line: 163 ]] --[[ Name: GetInfinityEgg ]]
    -- upvalues: v15 (copy)
    return v15[v58];
end;
for _, v61 in l_CollectionService_0:GetTagged("Egg") do
    v16[v61.Name] = true;
end;
local v62 = {
    "EggsOpened", 
    "Pets", 
    "Teams", 
    "TeamEquipped"
};
if l_RunService_0:IsClient() then
    local v63 = require(l_ReplicatedStorage_0.Client.Framework.Services.LocalData);
    local l_LocalPlayer_0 = l_Players_0.LocalPlayer;
    v63:ConnectDataChanged(v62, function(v65) --[[ Line: 178 ]]
        -- upvalues: v57 (copy), l_LocalPlayer_0 (copy)
        v57(l_LocalPlayer_0, v65);
    end);
    return v59;
else
    if l_RunService_0:IsServer() then
        local v66 = require(l_ServerScriptService_0.Server.Framework.Services.DataService);
        local function v69(v67) --[[ Line: 184 ]] --[[ Name: recache ]]
            -- upvalues: v66 (copy), v57 (copy)
            local l_v66_Data_0 = v66:GetData(v67);
            if l_v66_Data_0 then
                v57(v67, l_v66_Data_0);
            end;
        end;
        for _, v71 in v62 do
            v66:ConnectDataChanged(v71, v69);
        end;
        l_Players_0.PlayerRemoving:Connect(function(v72) --[[ Line: 195 ]]
            -- upvalues: v15 (copy)
            v15[v72] = nil;
        end);
    end;
    return v59;
end;
ModuleScript: GetPetChanceColor
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.PetUtil);
local v3 = require(l_ReplicatedStorage_0.Shared.Constants);
return function(v4) --[[ Line: 9 ]] --[[ Name: GetPetChanceColor ]]
    -- upvalues: v2 (copy), v3 (copy)
    local l_v2_Chance_0 = v2:GetChance({
        Type = "Pet", 
        Name = v4.Name
    });
    local v6 = Color3.new(0, 1, 1);
    if l_v2_Chance_0 <= 0.001 then
        v6 = Color3.fromRGB(255, 0, 100);
    elseif l_v2_Chance_0 < 0.005 then
        v6 = Color3.new(0, 1, 0);
    end;
    if v4.Mythic then
        l_v2_Chance_0 = l_v2_Chance_0 * (v3.MythicChance / 100);
    end;
    if v4.Shiny then
        l_v2_Chance_0 = l_v2_Chance_0 * (v3.ShinyChance / 100);
    end;
    local v7, v8, v9 = v6:ToHSV();
    local v10 = (v4.Shiny and 0.25 or 0) + (v4.Mythic and 0.15 or 0);
    return Color3.fromHSV((v7 + v10) % 1, v8, v9);
end;
ModuleScript: GetPetModel
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local l_Pets_0 = l_ReplicatedStorage_0.Assets.Pets;
local l_Normal_0 = l_Pets_0:FindFirstChild("Normal");
local l_Shiny_0 = l_Pets_0:FindFirstChild("Shiny");
return function(v5) --[[ Line: 11 ]] --[[ Name: GetPetModel ]]
    -- upvalues: l_Shiny_0 (copy), l_Normal_0 (copy)
    local v6 = if v5.Shiny then l_Shiny_0 else l_Normal_0;
    local l_v6_FirstChild_0 = v6:FindFirstChild((("%*%*"):format(v5.Name, v5.Mythic and " Mythic" or "")));
    if not l_v6_FirstChild_0 then
        return v6.Doggy;
    else
        return l_v6_FirstChild_0;
    end;
end;
ModuleScript: GetPickUpZones
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")

local Zone = require(ReplicatedStorage.Shared.Framework.Classes.Zone)
require(ReplicatedStorage.Shared.Types)

local Worlds = require(ReplicatedStorage.Shared.Data.Worlds)

-- Varsaylan pickup
local DefaultPickups = {
	{
		Chance = 100,
		Item = {
			Visual = "Coin",
			Item = {
				Type = "Currency",
				Currency = "Coins",
				Amount = 1
			}
		}
	}
}

-- Festival pickup seti
local FestivalPickups = {
	{
		Chance = 50,
		Item = {
			Visual = "Festival Token",
			Item = {
				Type = "Currency",
				Currency = "FestivalCoins",
				Amount = 500
			}
		}
	},
	{
		Chance = 20,
		Item = {
			Visual = "Festival Token Pile",
			Item = {
				Type = "Currency",
				Currency = "FestivalCoins",
				Amount = 1000
			}
		}
	},
	{
		Chance = 15,
		Item = {
			Visual = "Festival Token Stack",
			Item = {
				Type = "Currency",
				Currency = "FestivalCoins",
				Amount = 2500
			}
		}
	},
	{
		Chance = 10,
		Item = {
			Visual = "Festival Token Box",
			Item = {
				Type = "Currency",
				Currency = "FestivalCoins",
				Amount = 3750
			}
		}
	},
	{
		Chance = 5,
		Item = {
			Visual = "Festival Token Safe",
			Item = {
				Type = "Currency",
				Currency = "FestivalCoins",
				Amount = 5000
			}
		}
	}
}

local PickupSets = {}
PickupSets.Festival = FestivalPickups

-- Worlds verilerini ykle
for worldName, worldData in Worlds do
	for _, island in worldData.Islands do
		PickupSets[island.Name] = island.Pickups
	end
	PickupSets[worldName] = worldData.Pickups
end

-- Pickup zone fonksiyonu
local function GetPickupZones()
	local zones = {}

	for _, zoneObject in CollectionService:GetTagged("PickupZone") do
		local zone

		if zoneObject:IsA("Folder") then
			task.defer(function()
				for _, part in zoneObject:GetChildren() do
					if part:IsA("BasePart") then
						part.Transparency = 1
						part.CanCollide = false
					end
				end
			end)
			zone = Zone.fromPointsFolder(zoneObject)
		elseif zoneObject:IsA("BasePart") then
			task.defer(function()
				zoneObject.Transparency = 1
				zoneObject.CanCollide = false
			end)
			zone = Zone.fromPart(zoneObject)
		else
			error(("zone root must be a folder or a basepart (%s)"):format(zoneObject:GetFullName()))
		end

		local area = zoneObject:GetAttribute("Area") or ""
		local pickups = PickupSets[area]

		if not pickups then
			warn(("no pickups for area \"%s\""):format(area))
			pickups = DefaultPickups
		end

		zones[zoneObject] = {
			Zone = zone,
			Area = area,
			Pickups = pickups,
			Count = zoneObject:GetAttribute("Count")
		}
	end

	return zones
end

return GetPickupZones
ModuleScript: GetPostionNearPlayer
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_Players_0 = game:GetService("Players");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.CharacterUtil);
local v3 = Random.new();
local function v7() --[[ Line: 10 ]] --[[ Name: getCharacters ]]
    -- upvalues: l_Players_0 (copy)
    local v4 = {};
    for _, v6 in l_Players_0:GetPlayers() do
        if v6.Character then
            table.insert(v4, v6.Character);
        end;
    end;
    return v4;
end;
return function(v8, v9) --[[ Line: 21 ]] --[[ Name: GetPositionNearPlayer ]]
    -- upvalues: v2 (copy), v7 (copy), v3 (copy)
    local l_v2_RootPart_0 = v2:GetRootPart(v8);
    local v11 = Vector3.new(0, 0, 0, 0);
    if l_v2_RootPart_0 then
        v11 = l_v2_RootPart_0.Position;
    end;
    local v12 = RaycastParams.new();
    v12.RespectCanCollide = true;
    v12.FilterType = Enum.RaycastFilterType.Exclude;
    v12.FilterDescendantsInstances = v7();
    if not v9 then
        local v13 = v3:NextNumber() * 3.141592653589793 * 2;
        local v14 = v11 + Vector3.new(math.cos(v13) * 5, 0, math.sin(v13) * 5);
        local v15 = workspace:Raycast(v14, Vector3.new(0, -10, 0, 0), v12);
        local v16 = v15 and v15.Position or v14;
        return {
            Position = v16, 
            Unit = (v16 - v11).Unit * Vector3.new(1, 0, 1, 0)
        };
    else
        local v17 = {};
        local v18 = {};
        for v19 = 0, 15 do
            local v20 = 0.39269908169872414 * v19;
            local v21 = v11 + Vector3.new(math.cos(v20) * 5, 0, math.sin(v20) * 5);
            local v22 = workspace:Raycast(v21, Vector3.new(0, -10, 0, 0), v12);
            if v22 then
                v17[v19 + 1] = v22.Position.Y - v11.Y;
                v18[v19 + 1] = v22.Position;
            else
                v17[v19 + 1] = 1e999;
                v18[v19 + 1] = v21;
            end;
        end;
        local v23 = 1e999;
        local v24 = 1;
        for v25 = 1, 16 do
            local v26 = 0;
            for v27 = -7, 7 do
                v26 = v26 + math.abs(v17[(v25 + v27 - 1) % 16 + 1] - v17[v25]);
            end;
            if v26 < v23 then
                v23 = v26;
                v24 = v25;
            end;
        end;
        local v28 = v18[v24];
        return {
            Position = v28, 
            Unit = (v28 - v11).Unit * Vector3.new(1, 0, 1, 0)
        };
    end;
end;
ModuleScript: IndexUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Data.Eggs);
local v3 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v26 = {
    GetCompleted = function(_, v5, v6, v7) --[[ Line: 17 ]] --[[ Name: GetCompleted ]]
        -- upvalues: v2 (copy), v3 (copy)
        local v8 = 0;
        local v9 = 0;
        for _, v11 in v2 do
            if v11.World == v6 then
                local v12 = 0;
                local v13 = 0;
                for _, v15 in v11.Pool do
                    if v15.Item.Type == "Pet" then
                        if v5.Discovered[("%*%*"):format(v7 == "Normal" and "" or "Shiny ", v15.Item.Name)] ~= nil then
                            v13 = v13 + 1;
                        end;
                        if v3[v15.Item.Name].Rarity ~= "Secret" then
                            v12 = v12 + 1;
                        end;
                    end;
                end;
                v9 = v9 + v12;
                v8 = v8 + v13;
            end;
        end;
        return {
            Found = v8, 
            Total = v9
        };
    end, 
    GetEggCompleted = function(_, v17, _, v19, v20) --[[ Line: 53 ]] --[[ Name: GetEggCompleted ]]
        -- upvalues: v2 (copy), v3 (copy)
        local v21 = 0;
        local v22 = 0;
        local v23 = v2[v20];
        if not v23 then
            return {
                Found = 0, 
                Total = 1
            };
        else
            for _, v25 in v23.Pool do
                if v25.Item.Type == "Pet" then
                    if v17.Discovered[("%*%*"):format(v19 == "Normal" and "" or "Shiny ", v25.Item.Name)] ~= nil then
                        v21 = v21 + 1;
                    end;
                    if v3[v25.Item.Name].Rarity ~= "Secret" then
                        v22 = v22 + 1;
                    end;
                end;
            end;
            return {
                Found = v21, 
                Total = v22
            };
        end;
    end
};
v26.IsFinished = function(_, v28, v29) --[[ Line: 85 ]] --[[ Name: IsFinished ]]
    -- upvalues: v26 (copy)
    local l_v26_Completed_0 = v26:GetCompleted(v28, v29, "Normal");
    local v31 = false;
    if l_v26_Completed_0.Found >= l_v26_Completed_0.Total then
        v31 = l_v26_Completed_0.Found > 0;
    end;
    return v31;
end;
v26.IsShinyFinished = function(_, v33, v34) --[[ Line: 92 ]] --[[ Name: IsShinyFinished ]]
    -- upvalues: v26 (copy)
    local l_v26_Completed_1 = v26:GetCompleted(v33, v34, "Shiny");
    local v36 = false;
    if l_v26_Completed_1.Found == l_v26_Completed_1.Total then
        v36 = l_v26_Completed_1.Found > 0;
    end;
    return v36;
end;
v26.HasAny = function(_, v38, v39) --[[ Line: 99 ]] --[[ Name: HasAny ]]
    local l_Discovered_0 = v38.Discovered;
    return (l_Discovered_0[v39] or l_Discovered_0[("Shiny %*"):format(v39)] or l_Discovered_0[("Mythic %*"):format(v39)] or l_Discovered_0[("Shiny Mythic %*"):format(v39)]) ~= nil;
end;
v26.Has = function(_, v42, v43) --[[ Line: 110 ]] --[[ Name: Has ]]
    return v42.Discovered[v43] ~= nil;
end;
v26.HasShiny = function(_, v45, v46) --[[ Line: 115 ]] --[[ Name: HasShiny ]]
    return v45.Discovered[("Shiny %*"):format(v46)] ~= nil;
end;
v26.HasMythic = function(_, v48, v49) --[[ Line: 120 ]] --[[ Name: HasMythic ]]
    return v48.Discovered[("Mythic %*"):format(v49)] ~= nil;
end;
v26.HasShinyMythic = function(_, v51, v52) --[[ Line: 126 ]] --[[ Name: HasShinyMythic ]]
    return v51.Discovered[("Shiny Mythic %*"):format(v52)] ~= nil;
end;
return v26;
ModuleScript: PetLevelUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v3 = require(l_ReplicatedStorage_0.Shared.Constants);
local v4 = {};
local l_RarityXPRequired_0 = v3.RarityXPRequired;
local l_PetMaximumLevel_0 = v3.PetMaximumLevel;
local function _(v7) --[[ Line: 21 ]] --[[ Name: getMaxXP ]]
    -- upvalues: l_RarityXPRequired_0 (copy)
    return l_RarityXPRequired_0[v7.Rarity];
end;
local function _(v9, v10, v11) --[[ Line: 31 ]] --[[ Name: getTotalXPForLevel ]]
    return (math.clamp(math.ceil(((v11 - 1) / (v10 - 1)) ^ 2 * v9 / 5) * 5, 0, v9));
end;
local function v17(v13, v14, v15) --[[ Line: 45 ]] --[[ Name: getLevelFromXP ]]
    if v15 == 0 then
        return 1;
    else
        for v16 = v14, 1, -1 do
            if math.clamp(math.ceil(((v16 - 1) / (v14 - 1)) ^ 2 * v13 / 5) * 5, 0, v13) <= v15 then
                return v16;
            end;
        end;
        return 1;
    end;
end;
v4.GetLevelFromXP = function(_, v19, v20) --[[ Line: 68 ]] --[[ Name: GetLevelFromXP ]]
    -- upvalues: v2 (copy), v17 (copy), l_RarityXPRequired_0 (copy), l_PetMaximumLevel_0 (copy)
    local v21 = v2[v19];
    return (v17(l_RarityXPRequired_0[v21.Rarity], l_PetMaximumLevel_0[v21.Rarity], v20));
end;
v4.GetLevelFromPet = function(_, v23) --[[ Line: 81 ]] --[[ Name: GetLevelFromPet ]]
    -- upvalues: v2 (copy), v17 (copy), l_RarityXPRequired_0 (copy), l_PetMaximumLevel_0 (copy)
    local v24 = v2[v23.Name];
    return (v17(l_RarityXPRequired_0[v24.Rarity], l_PetMaximumLevel_0[v24.Rarity], v23.XP));
end;
v4.GetTotalXPForLevel = function(_, v26, v27) --[[ Line: 94 ]] --[[ Name: GetTotalXPForLevel ]]
    -- upvalues: v2 (copy), l_RarityXPRequired_0 (copy), l_PetMaximumLevel_0 (copy)
    local v28 = v2[v26];
    local v29 = l_RarityXPRequired_0[v28.Rarity];
    local v30 = l_PetMaximumLevel_0[v28.Rarity];
    return (math.clamp(math.ceil(((v27 - 1) / (v30 - 1)) ^ 2 * v29 / 5) * 5, 0, v29));
end;
v4.GetMarginalXPForLevel = function(_, v32, v33) --[[ Line: 111 ]] --[[ Name: GetMarginalXPForLevel ]]
    -- upvalues: v4 (copy)
    return v4:GetTotalXPForLevel(v32, v33) - v4:GetTotalXPForLevel(v32, v33 - 1);
end;
v4.CalculateXPUntilMax = function(_, v35) --[[ Line: 124 ]] --[[ Name: CalculateXPUntilMax ]]
    -- upvalues: v2 (copy), l_RarityXPRequired_0 (copy)
    return l_RarityXPRequired_0[v2[v35.Name].Rarity] - v35.XP;
end;
v4.CalculateGiveXP = function(_, v37, v38) --[[ Line: 137 ]] --[[ Name: CalculateGiveXP ]]
    -- upvalues: v2 (copy), l_RarityXPRequired_0 (copy), v4 (copy)
    local v39 = l_RarityXPRequired_0[v2[v37.Name].Rarity];
    local v40 = math.min(v37.XP + v38, v39);
    return v40, (v4:GetLevelFromXP(v37.Name, v40));
end;
v4.GetMaxLevel = function(_, v42) --[[ Line: 152 ]] --[[ Name: GetMaxLevel ]]
    -- upvalues: l_PetMaximumLevel_0 (copy), v2 (copy)
    return l_PetMaximumLevel_0[v2[v42.Name].Rarity];
end;
v4.IsMaxLevel = function(_, v44) --[[ Line: 158 ]] --[[ Name: IsMaxLevel ]]
    -- upvalues: v4 (copy)
    return v4:GetLevelFromPet(v44) >= v4:GetMaxLevel(v44);
end;
return v4;
ModuleScript: PetStacksUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Constants);
local v3 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v8 = {
    CanMergePet = function(_, _, v6) --[[ Line: 15 ]] --[[ Name: CanMergePet ]]
        -- upvalues: v3 (copy)
        local v7 = false;
        if v6.Locked ~= true then
            v7 = false;
            if v6.XP == 0 then
                v7 = false;
                if v6.Enchants == nil then
                    v7 = v3[v6.Name].Rarity ~= "Secret";
                end;
            end;
        end;
        return v7;
    end
};
v8.FindMergePet = function(_, v10, v11) --[[ Line: 28 ]] --[[ Name: FindMergePet ]]
    -- upvalues: v8 (copy)
    for _, v13 in v10.Pets do
        if v13 ~= v11 and v13.Name == v11.Name and v13.Shiny == v11.Shiny and v13.Mythic == v11.Mythic and v8:CanMergePet(v10, v13) then
            return v13;
        end;
    end;
    return nil;
end;
v8.GetMinStackSize = function(_, v15, v16) --[[ Line: 44 ]] --[[ Name: GetMinStackSize ]]
    -- upvalues: v3 (copy), v2 (copy)
    local l_Rarity_0 = v3[v16.Name].Rarity;
    if l_Rarity_0 == "Secret" or v15.Settings["Compact Pet Inventory"] ~= true then
        return v2.VisualStackMinSize[l_Rarity_0];
    else
        return 1;
    end;
end;
return v8;
ModuleScript: RaceUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.Time);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Signal);
local v3 = require(l_ReplicatedStorage_0.Shared.Data.Builders.LootPoolBuilder);
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v5 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.GetRandomWeightedItem);
local v6 = {
    RaceTime = 300
};
local v7 = {
    Type = "Currency", 
    Currency = "Gems", 
    Amount = 550
};
local v8 = v3.new():Add(5, {
    Type = "Powerup", 
    Name = "Mystery Box", 
    Amount = 3
}):Add(5, {
    Type = "Powerup", 
    Name = "Golden Key", 
    Amount = 10
}):Add(5, {
    Type = "Powerup", 
    Name = "Reroll Orb", 
    Amount = 10
}):Add(5, {
    Type = "Powerup", 
    Name = "Power Orb", 
    Amount = 1
}):Add(15, {
    Type = "Potion", 
    Name = "Lucky", 
    Level = 4, 
    Amount = 1
}):Add(15, {
    Type = "Potion", 
    Name = "Speed", 
    Level = 4, 
    Amount = 1
}):Add(15, {
    Type = "Potion", 
    Name = "Coins", 
    Level = 4, 
    Amount = 1
}):Add(15, {
    Type = "Potion", 
    Name = "Mythic", 
    Level = 4, 
    Amount = 1
}):Add(5, {
    Type = "Potion", 
    Name = "Lucky", 
    Level = 5, 
    Amount = 1
}):Add(5, {
    Type = "Potion", 
    Name = "Speed", 
    Level = 5, 
    Amount = 1
}):Add(5, {
    Type = "Potion", 
    Name = "Coins", 
    Level = 5, 
    Amount = 1
}):Add(5, {
    Type = "Potion", 
    Name = "Mythic", 
    Level = 5, 
    Amount = 1
}):Build();
v6.GetSeed = function(_) --[[ Line: 60 ]] --[[ Name: GetSeed ]]
    -- upvalues: v1 (copy)
    return (math.ceil(v1.now() / 900));
end;
v6.GetRewards = function(_, v11) --[[ Line: 64 ]] --[[ Name: GetRewards ]]
    -- upvalues: v5 (copy), v8 (copy), v7 (copy)
    local v12 = Random.new(v11);
    return {
        {
            Time = 150, 
            Item = v5(v8, v12)
        }, 
        {
            Time = 180, 
            Item = v5(v8, v12)
        }, 
        {
            Time = 1e999, 
            Item = v7
        }
    };
end;
v6.HasPlayer = function(_, v14) --[[ Line: 73 ]] --[[ Name: HasPlayer ]]
    return v14:GetAttribute("InRace") == true;
end;
v6.GetPhase = function(_) --[[ Line: 77 ]] --[[ Name: GetPhase ]]
    -- upvalues: v1 (copy), v6 (copy)
    local v16 = v1.now();
    local v17 = v6:GetNextTime() - v16;
    if v17 <= 20 and v17 > 5 then
        return {
            Type = "SignUp", 
            Time = v17 - 5
        };
    elseif v17 <= 5 and v17 > 0 then
        return {
            Type = "Countdown", 
            Time = v17
        };
    else
        return {
            Type = "Inactive", 
            Time = v17 - 5
        };
    end;
end;
v6.GetNextTime = function(_) --[[ Line: 99 ]] --[[ Name: GetNextTime ]]
    -- upvalues: v6 (copy)
    return v6:GetSeed() * 900;
end;
return v6;
ModuleScript: RenderBand
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local l_RunService_0 = game:GetService("RunService");
local v2 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Signal);
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Maid);
local v4 = {
    {
        Distance = 100, 
        Rate = 1
    }, 
    {
        Distance = 150, 
        Rate = 2
    }, 
    {
        Distance = 200, 
        Rate = 4
    }, 
    {
        Distance = 300, 
        Rate = 0
    }
};
local l_CurrentCamera_0 = workspace.CurrentCamera;
local v6 = {};
v6.__index = v6;
v6.new = function(v7) --[[ Line: 54 ]] --[[ Name: new ]]
    -- upvalues: v4 (copy), v2 (copy), v3 (copy), v6 (copy), l_RunService_0 (copy)
    local v8 = v7 or v4;
    local v9 = 1;
    for _, v11 in v8 do
        if v11.Rate > 0 then
            v9 = v9 * v11.Rate;
        end;
    end;
    local v12 = v2.new();
    local v13 = v2.new();
    local v14 = v2.new();
    local v15 = v3.new();
    local v16 = setmetatable({
        _offsets = {}, 
        _frameCount = 0, 
        _nextOffset = 0, 
        _maxOffset = v9, 
        _config = v8, 
        _maid = v15, 
        Update = v12, 
        Render = v13, 
        Culled = v14, 
        Active = {}
    }, v6);
    v15:Add(function() --[[ Line: 83 ]]
        -- upvalues: v12 (copy), v13 (copy), v14 (copy)
        v12:Destroy();
        v13:Destroy();
        v14:Destroy();
    end);
    v15:Add(l_RunService_0.Heartbeat:Connect(function(v17) --[[ Line: 89 ]]
        -- upvalues: v16 (copy), v12 (copy), v13 (copy), v14 (copy)
        for v18 in v16._offsets do
            local l_v16_RenderData_0, v20 = v16:GetRenderData(v18);
            if v20 > 0 then
                v12:Fire(v18, v17 * v20);
            end;
            if l_v16_RenderData_0 and not v16.Active[v18] then
                v13:Fire(v18);
                v16.Active[v18] = true;
            elseif not l_v16_RenderData_0 and v16.Active[v18] then
                v14:Fire(v18);
                v16.Active[v18] = nil;
            end;
        end;
        v16._frameCount = (v16._frameCount + 1) % 4294967296;
    end));
    return v16;
end;
v6.GetRenderData = function(v21, v22) --[[ Line: 110 ]] --[[ Name: GetRenderData ]]
    -- upvalues: l_CurrentCamera_0 (copy)
    local l_Magnitude_0 = ((v22:GetPivot().Position - l_CurrentCamera_0.CFrame.Position) * Vector3.new(1, 0, 1, 0)).Magnitude;
    local v24 = 0;
    local v25 = false;
    local v26 = v21._frameCount + (v21._offsets[v22] or 0);
    for _, v28 in v21._config do
        if l_Magnitude_0 <= v28.Distance then
            v25 = true;
            if v26 % v28.Rate == 0 then
                v24 = v28.Rate;
                break;
            else
                break;
            end;
        end;
    end;
    return v25, v24;
end;
v6.Add = function(v29, v30) --[[ Line: 130 ]] --[[ Name: Add ]]
    v29._offsets[v30] = v29._nextOffset;
    v29._nextOffset = v29._nextOffset + 1;
    v29._nextOffset = v29._nextOffset % v29._maxOffset;
    v29.Update:Fire(v30, 0);
end;
v6.Remove = function(v31, v32) --[[ Line: 138 ]] --[[ Name: Remove ]]
    v31._offsets[v32] = nil;
end;
return v6;
ModuleScript: RichText
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local v0 = {};
local function v7(v1) --[[ Line: 47 ]] --[[ Name: extractColorBody ]]
    if type(v1) == "string" then
        local v2 = string.match(v1, "^#?(%x%x%x%x%x%x)$");
        local v3 = string.match(v1, "^#?(%x%x%x)$");
        if not v2 and not v3 then
            error((("invalid hex color (%*)"):format(v1)));
        end;
        return (("#%*"):format(v2 or v3));
    else
        local v4 = math.round(v1.R * 255);
        local v5 = math.round(v1.G * 255);
        local v6 = math.round(v1.B * 255);
        if v4 < 0 or v4 > 255 or v5 < 0 or v5 > 255 or v6 < 0 or v6 > 255 then
            error((("invalid color3 (%*)"):format(v1)));
        end;
        return (("rgb(%*,%*,%*)"):format(v4, v5, v6));
    end;
end;
local function v10(v8) --[[ Line: 66 ]] --[[ Name: getStrokeElements ]]
    -- upvalues: v7 (copy)
    local v9 = {};
    if v8.color then
        table.insert(v9, (("color=\"%*\""):format((v7(v8.color)))));
    end;
    if v8.joins then
        table.insert(v9, (("joins=\"%*\""):format((string.lower(v8.joins.Name)))));
    end;
    if v8.thickness then
        table.insert(v9, (("thickness=\"%*\""):format(v8.thickness)));
    end;
    if v8.transparency then
        table.insert(v9, (("transparency=\"%*\""):format(v8.transparency)));
    end;
    assert(#v9 > 0, "must specify at least one text stroke feature");
    return v9;
end;
local function v11(v12, v13) --[[ Line: 84 ]] --[[ Name: construct ]]
    -- upvalues: v11 (copy), v7 (copy), v10 (copy)
    local v16 = setmetatable({}, {
        __call = function(_, v15) --[[ Line: 86 ]] --[[ Name: __call ]]
            -- upvalues: v12 (copy), v13 (copy)
            return (("%*%*%*"):format(table.concat(v12), v15, (table.concat(v13))));
        end
    });
    local function v21(v17, v18) --[[ Line: 91 ]] --[[ Name: push ]]
        -- upvalues: v12 (copy), v13 (copy), v11 (ref)
        local v19 = table.clone(v12);
        local v20 = table.clone(v13);
        table.insert(v19, v17);
        table.insert(v20, 1, v18);
        return v11(v19, v20);
    end;
    local function v23(v22) --[[ Line: 99 ]] --[[ Name: simple ]]
        -- upvalues: v21 (copy)
        return v21(("<%*>"):format(v22), (("</%*>"):format(v22)));
    end;
    v16.bold = function(_) --[[ Line: 103 ]] --[[ Name: bold ]]
        -- upvalues: v23 (copy)
        return v23("b");
    end;
    v16.italic = function(_) --[[ Line: 107 ]] --[[ Name: italic ]]
        -- upvalues: v23 (copy)
        return v23("i");
    end;
    v16.underline = function(_) --[[ Line: 111 ]] --[[ Name: underline ]]
        -- upvalues: v23 (copy)
        return v23("u");
    end;
    v16.strikethrough = function(_) --[[ Line: 115 ]] --[[ Name: strikethrough ]]
        -- upvalues: v23 (copy)
        return v23("s");
    end;
    v16.color = function(_, v29) --[[ Line: 119 ]] --[[ Name: color ]]
        -- upvalues: v7 (ref), v21 (copy)
        local v30 = v7(v29);
        return v21(("<font color=\"%*\">"):format(v30), "</font>");
    end;
    v16.size = function(_, v32) --[[ Line: 124 ]] --[[ Name: size ]]
        -- upvalues: v21 (copy)
        return v21(("<font size=\"%*\">"):format(v32), "</font>");
    end;
    v16.face = function(_, v34) --[[ Line: 128 ]] --[[ Name: face ]]
        -- upvalues: v21 (copy)
        return v21(("<font face=\"%*\">"):format(v34), "</font>");
    end;
    v16.family = function(_, v36) --[[ Line: 132 ]] --[[ Name: family ]]
        -- upvalues: v21 (copy)
        return v21(("<font family=\"%*\">"):format(v36), "</font>");
    end;
    v16.weight = function(_, v38) --[[ Line: 136 ]] --[[ Name: weight ]]
        -- upvalues: v21 (copy)
        return v21(("<font weight=\"%*\">"):format(v38.Value), "</font>");
    end;
    v16.stroke = function(_, v40) --[[ Line: 140 ]] --[[ Name: stroke ]]
        -- upvalues: v10 (ref), v21 (copy)
        local v41 = v10(v40);
        return v21(("<stroke %*>"):format((table.concat(v41, " "))), "</stroke>");
    end;
    v16.transparency = function(_, v43) --[[ Line: 145 ]] --[[ Name: transparency ]]
        -- upvalues: v21 (copy)
        if v43 < 0 or v43 > 1 then
            error((("invalid transparency (%*)"):format(v43)));
        end;
        return v21(("<font transparency=\"%*\">"):format(v43), "</font>");
    end;
    v16.linebreak = function(_) --[[ Line: 152 ]] --[[ Name: linebreak ]]
        -- upvalues: v13 (copy), v11 (ref), v12 (copy)
        local v45 = table.clone(v13);
        table.insert(v45, "<br />");
        return v11(table.clone(v12), v45);
    end;
    v16.uppercase = function(_) --[[ Line: 158 ]] --[[ Name: uppercase ]]
        -- upvalues: v23 (copy)
        return v23("uc");
    end;
    v16.smallcaps = function(_) --[[ Line: 162 ]] --[[ Name: smallcaps ]]
        -- upvalues: v23 (copy)
        return v23("sc");
    end;
    return v16;
end;
v0.new = function() --[[ Line: 169 ]] --[[ Name: new ]]
    -- upvalues: v11 (copy)
    return (v11({}, {}));
end;
v0.escape = function(v48) --[[ Line: 173 ]] --[[ Name: escape ]]
    local v49 = string.gsub(v48, "&", "&amp;");
    v49 = string.gsub(v49, "<", "&lt;");
    v49 = string.gsub(v49, ">", "&gt;");
    v49 = string.gsub(v49, "\"", "&quot;");
    return (string.gsub(v49, "'", "&apos;"));
end;
v0.withStroke = function(v50, v51) --[[ Line: 183 ]] --[[ Name: withStroke ]]
    -- upvalues: v10 (copy)
    local v52 = v10(v51);
    return (("<stroke %*>%*</stroke>"):format(table.concat(v52, " "), v50));
end;
v0.autoStroke = function(v53, v54) --[[ Line: 188 ]] --[[ Name: autoStroke ]]
    -- upvalues: v0 (copy)
    return v0.withStroke(v53, {
        color = "#00295E", 
        joins = Enum.LineJoinMode.Round, 
        thickness = v54 or 2
    });
end;
v0.autoColor = function(v55, v56) --[[ Line: 196 ]] --[[ Name: autoColor ]]
    local l_v56_0 = v56;
    if typeof(v56) == "Color3" then
        l_v56_0 = v56:ToHex();
    end;
    return (("<font color=\"#%*\">%*</font>"):format(l_v56_0, v55));
end;
return v0;
ModuleScript: SetModelUnlocked
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

return function(v0, v1) --[[ Line: 4 ]] --[[ Name: SetModelUnlocked ]]
    for _, v3 in v0:GetDescendants() do
        if v3:IsA("BasePart") then
            if v3.Transparency ~= 1 then
                local l_v3_Attribute_0 = v3:GetAttribute("OriginalColor");
                local l_v3_Attribute_1 = v3:GetAttribute("OriginalTransparency");
                if not l_v3_Attribute_0 then
                    l_v3_Attribute_0 = v3.Color;
                    v3:SetAttribute("OriginalColor", l_v3_Attribute_0);
                end;
                if not l_v3_Attribute_1 then
                    l_v3_Attribute_1 = v3.Transparency;
                    v3:SetAttribute("OriginalTransparency", l_v3_Attribute_1);
                end;
                if v3:IsA("MeshPart") then
                    local l_v3_Attribute_2 = v3:GetAttribute("OriginalTexture");
                    if not l_v3_Attribute_2 then
                        l_v3_Attribute_2 = v3.TextureID;
                        v3:SetAttribute("OriginalTexture", l_v3_Attribute_2);
                    end;
                    v3.TextureID = v1 and l_v3_Attribute_2 or "";
                end;
                v3.Anchored = true;
                v3.CanCollide = v1;
                v3.Color = v1 and l_v3_Attribute_0 or Color3.new();
                v3.Transparency = v1 and l_v3_Attribute_1 or 0.1;
            end;
        elseif v3:IsA("FileMesh") then
            local l_v3_Attribute_3 = v3:GetAttribute("OriginalTexture");
            if not l_v3_Attribute_3 then
                l_v3_Attribute_3 = v3.TextureId;
                v3:SetAttribute("OriginalTexture", l_v3_Attribute_3);
            end;
            v3.TextureId = v1 and l_v3_Attribute_3 or "";
        elseif v3:IsA("SurfaceGui") then
            v3.Enabled = v1;
        elseif v3:IsA("ParticleEmitter") then
            v3.Enabled = v1;
        elseif v3:IsA("Decal") or v3:IsA("Texture") then
            local l_v3_Attribute_4 = v3:GetAttribute("OriginalColor");
            if not l_v3_Attribute_4 then
                l_v3_Attribute_4 = v3.Color3;
                v3:SetAttribute("OriginalColor", l_v3_Attribute_4);
            end;
            v3.Color3 = v1 and l_v3_Attribute_4 or Color3.new();
        end;
    end;
end;
ModuleScript: ShinyUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v3 = require(l_ReplicatedStorage_0.Shared.Constants);
local v9 = {
    GetRequiredCount = function(_, v5) --[[ Line: 20 ]] --[[ Name: GetRequiredCount ]]
        -- upvalues: v3 (copy), v2 (copy)
        return v3.ShinyCountRequired[v2[v5.Name].Rarity];
    end, 
    CanUse = function(_, v7) --[[ Line: 25 ]] --[[ Name: CanUse ]]
        local v8 = false;
        if v7.Shiny ~= true then
            v8 = v7.Locked ~= true;
        end;
        return v8;
    end
};
v9.GetOwnedCount = function(_, v11, v12) --[[ Line: 30 ]] --[[ Name: GetOwnedCount ]]
    -- upvalues: v9 (copy)
    local v13 = 0;
    for _, v15 in v11.Pets do
        if v15.Name == v12.Name and v15.Mythic == v12.Mythic and v9:CanUse(v15) then
            v13 = v13 + (v15.Amount or 1);
        end;
    end;
    return v13;
end;
v9.GetPets = function(_, v17, v18) --[[ Line: 41 ]] --[[ Name: GetPets ]]
    -- upvalues: v9 (copy)
    local v19 = {};
    for _, v21 in v17.Pets do
        if v21.Name == v18.Name and v21.Mythic == v18.Mythic and v9:CanUse(v21) then
            table.insert(v19, v21);
        end;
    end;
    table.sort(v19, function(v22, v23) --[[ Line: 49 ]]
        -- upvalues: v18 (copy)
        local v24 = v22 == v18;
        if v24 ~= (v23 == v18) then
            return v24;
        else
            local l_XP_0 = v22.XP;
            local l_XP_1 = v23.XP;
            if l_XP_0 ~= l_XP_1 then
                return l_XP_0 < l_XP_1;
            else
                local v27 = v22.Enchants ~= nil;
                if v27 ~= (v23.Enchants ~= nil) then
                    return not v27;
                else
                    return v22.Id < v23.Id;
                end;
            end;
        end;
    end);
    local l_v9_RequiredCount_0 = v9:GetRequiredCount(v18);
    local v29 = {};
    for _, v31 in v19 do
        if l_v9_RequiredCount_0 > 0 then
            local v32 = math.min(l_v9_RequiredCount_0, v31.Amount or 1);
            table.insert(v29, {
                Id = v31.Id, 
                Item = {
                    Type = "Pet", 
                    Name = v31.Name, 
                    Amount = v32, 
                    Mythic = v31.Mythic, 
                    XP = v31.XP, 
                    Enchants = v31.Enchants
                }
            });
            l_v9_RequiredCount_0 = l_v9_RequiredCount_0 - v32;
        else
            break;
        end;
    end;
    return v29;
end;
return v9;
ModuleScript: ShopUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Data.Shops);
local v3 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.BuffUtil);
local _ = require(l_ReplicatedStorage_0.Shared.Utils.Stats.MasteryUtil);
local v5 = require(l_ReplicatedStorage_0.Shared.Data.Mastery);
local v6 = require(l_ReplicatedStorage_0.Shared.Constants);
local v7 = {};
local v15 = (function() --[[ Line: 16 ]] --[[ Name: getMaxExtraShopSlots ]]
    -- upvalues: v5 (copy), v3 (copy)
    local v8 = 0;
    for _, v10 in v5.Upgrades do
        for _, v12 in v10.Levels do
            for _, v14 in v12.Upgrades do
                if v14.Type == "ShopSlots" then
                    v8 = math.max(v8, v3:GetValue(0, v14.Buff));
                end;
            end;
        end;
    end;
    return v8;
end)();
v7.GetUnlockedSlots = function(_, v17, v18) --[[ Line: 33 ]] --[[ Name: GetUnlockedSlots ]]
    -- upvalues: v3 (copy), v15 (copy)
    local v19 = 0;
    for _, v21 in v17.MasteryUpgrades do
        if v21.Type == "ShopSlots" then
            v19 = v3:GetValue(v19, v21.Buff);
            break;
        end;
    end;
    return v18 - (v15 - v19);
end;
v7.GetMaxFreeRerolls = function(_, v23) --[[ Line: 47 ]] --[[ Name: GetMaxFreeRerolls ]]
    -- upvalues: v3 (copy)
    local v24 = 0;
    for _, v26 in v23.MasteryUpgrades do
        if v26.Type == "InstantRestock" then
            v24 = v3:GetValue(v24, v26.Buff);
        end;
    end;
    return v24;
end;
v7.GetItemsData = function(_, v28, v29, v30) --[[ Line: 58 ]] --[[ Name: GetItemsData ]]
    -- upvalues: v2 (copy), v15 (copy), v6 (copy), v3 (copy)
    local v31 = v2[v28];
    local v32 = v30.Shops[v28];
    local v33 = bit32.bxor(v29.UserId % 4294967296, v32.Period);
    local v34 = Random.new(v33);
    local v35 = table.clone(v31.PermanentItems);
    local v36 = table.clone(v31.RandomItems);
    local v37 = v31.SlotCount + v15;
    local function _(v38, v39) --[[ Line: 93 ]] --[[ Name: applyCost ]]
        -- upvalues: v6 (ref)
        local v40 = table.clone(v38);
        local v41 = table.clone(v40.Cost);
        local l_Amount_0 = v41.Amount;
        if v39 then
            l_Amount_0 = l_Amount_0 * (100 - v6.ShopSaleMasteryDiscount) / 100;
        end;
        v41.Amount = math.round(l_Amount_0);
        v40.Cost = v41;
        return v40;
    end;
    local v44 = 0;
    for _, v46 in v30.MasteryUpgrades do
        if v46.Type == "Sale" then
            v44 = v3:GetValue(v44, v46.Buff);
            break;
        end;
    end;
    local v47 = table.create(v37);
    for v48 = 1, v37 do
        v47[v48] = v34:NextNumber() < v44;
    end;
    for v49, v50 in v35 do
        local v51 = v47[v49];
        local v52 = table.clone(v50);
        local v53 = table.clone(v52.Cost);
        local l_Amount_1 = v53.Amount;
        if v51 then
            l_Amount_1 = l_Amount_1 * (100 - v6.ShopSaleMasteryDiscount) / 100;
        end;
        v53.Amount = math.round(l_Amount_1);
        v52.Cost = v53;
        v35[v49] = v52;
    end;
    for v55 = #v35 + 1, v37 do
        if #v36 ~= 0 then
            local v56 = v34:NextInteger(1, #v36);
            local v57 = table.remove(v36, v56);
            local v58 = v47[v55];
            local v59 = table.clone(v57);
            local v60 = table.clone(v59.Cost);
            local l_Amount_2 = v60.Amount;
            if v58 then
                l_Amount_2 = l_Amount_2 * (100 - v6.ShopSaleMasteryDiscount) / 100;
            end;
            v60.Amount = math.round(l_Amount_2);
            v59.Cost = v60;
            table.insert(v35, v59);
        end;
    end;
    local v62 = {};
    for v63, v64 in v35 do
        local l_Stock_0 = v64.Stock;
        if typeof(l_Stock_0) == "NumberRange" then
            l_Stock_0 = v34:NextInteger(l_Stock_0.Min, l_Stock_0.Max);
        end;
        local v66 = 1;
        for _, v68 in v30.MasteryUpgrades do
            if v68.Type == "MoreStock" then
                v66 = v3:GetValue(v66, v68.Buff);
                break;
            end;
        end;
        v62[v63] = math.ceil(l_Stock_0 * v66);
    end;
    return v35, v62, v47;
end;
return v7;
ModuleScript: SortPetsList
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.PetUtil);
local v3 = require(l_ReplicatedStorage_0.Shared.Constants);
local v4 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
return function(v5, v6, v7) --[[ Line: 11 ]] --[[ Name: SortPetsList ]]
    -- upvalues: v2 (copy), v4 (copy), v3 (copy)
    local v8 = {};
    for _, v10 in v5 do
        v8[v10] = v2:GetPower(v6[v10]);
    end;
    table.sort(v5, function(v11, v12) --[[ Line: 21 ]]
        -- upvalues: v6 (copy), v4 (ref), v3 (ref), v8 (copy), v7 (copy)
        local v13 = v6[v11];
        local v14 = v6[v12];
        local v15 = v4[v13.Name];
        local v16 = v4[v14.Name];
        if v15.Rarity == "Secret" ~= (v16.Rarity == "Secret") then
            return v15.Rarity == "Secret";
        elseif v13.Locked ~= v14.Locked then
            return v13.Locked == true;
        else
            local v17 = v3.RarityOrder[v15.Rarity];
            local v18 = v3.RarityOrder[v16.Rarity];
            local v19 = v8[v11];
            local v20 = v8[v12];
            if v7 == "Rarity" then
                if v17 ~= v18 then
                    return v18 < v17;
                elseif v19 ~= v20 then
                    return v20 < v19;
                end;
            elseif v19 ~= v20 then
                return v20 < v19;
            elseif v17 ~= v18 then
                return v18 < v17;
            end;
            if v13.Name ~= v14.Name then
                return v13.Name < v14.Name;
            elseif v13.XP ~= v14.XP then
                return v13.XP > v14.XP;
            else
                return v11 < v12;
            end;
        end;
    end);
end;
ModuleScript: WorldUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local _ = game:GetService("Workspace");
local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Data.Worlds);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.CharacterUtil);
local v6 = {
    GetPlayerWorld = function(_, v5) --[[ Line: 13 ]] --[[ Name: GetPlayerWorld ]]
        return v5:GetAttribute("World") or "The Overworld";
    end
};
v6.OnPlayerWorldChanged = function(_, v8, v9) --[[ Line: 18 ]] --[[ Name: OnPlayerWorldChanged ]]
    -- upvalues: v6 (copy)
    v9(v6:GetPlayerWorld(v8));
    v8:GetAttributeChangedSignal("World"):Connect(function() --[[ Line: 20 ]]
        -- upvalues: v9 (copy), v6 (ref), v8 (copy)
        v9(v6:GetPlayerWorld(v8));
    end);
end;
v6.toIslandLocation = function(v10, v11) --[[ Line: 26 ]] --[[ Name: toIslandLocation ]]
    return (("Workspace.Worlds.%*.Islands.%*.Island.Portal.Spawn"):format(v10, v11));
end;
return v6;
ModuleScript: BountyUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.Time);
local v4 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.QuestUtil);
local v5 = require(l_ReplicatedStorage_0.Shared.Data.Builders.QuestBuilder);
local v6 = require(l_ReplicatedStorage_0.Shared.Data.Eggs);
local v7 = {
    Interval = v3.secondsInDay
};
local v8 = {};
v7.GetSeed = function(_) --[[ Line: 22 ]] --[[ Name: GetSeed ]]
    -- upvalues: v3 (copy), v7 (copy)
    return (math.floor(v3.now() / v7.Interval));
end;
v7.GetQuest = function(_, v11) --[[ Line: 28 ]] --[[ Name: GetQuest ]]
    -- upvalues: v5 (copy), v8 (copy)
    local v12 = Random.new(v11);
    return v5.new("bounty-mythic"):Visual("Mythic Bounty"):Task({
        Type = "Hatch", 
        Name = v8[v12:NextInteger(1, #v8)], 
        Mythic = true, 
        Amount = 1
    }):Reward({
        Type = "Powerup", 
        Name = "Mystery Box", 
        Amount = 7
    }):Reward({
        Type = "Potion", 
        Name = "Lucky", 
        Level = 6, 
        Amount = 1
    }):Reward({
        Type = "Potion", 
        Name = "Speed", 
        Level = 6, 
        Amount = 1
    }):Build();
end;
v7.Refresh = function(_, v14) --[[ Line: 46 ]] --[[ Name: Refresh ]]
    -- upvalues: v7 (copy), v4 (copy)
    local l_v7_Seed_0 = v7:GetSeed();
    if l_v7_Seed_0 == v14.BountySeed then
        return false;
    else
        v4:Remove(v14, function(v16) --[[ Line: 52 ]]
            return string.sub(v16.Id, 1, 13) == "bounty-mythic";
        end);
        v14.BountySeed = l_v7_Seed_0;
        v4:Add(v14, v7:GetQuest(l_v7_Seed_0));
        return true;
    end;
end;
for v17, v18 in v2 do
    if v18.Tier and v18.Tier < 2 and v18.Egg and v6[v18.Egg].World then
        table.insert(v8, v17);
    end;
end;
return v7;
ModuleScript: BuffUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Data.Potions);
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.Time);
local _ = require(l_ReplicatedStorage_0.Shared.Constants);
local v5 = require(l_ReplicatedStorage_0.Shared.Data.Buffs);
local v6 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatPercent);
local v7 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatSuffix);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Table.DeepCopy);
local v18 = {
    GiveBuff = function(_, v10, v11, v12, v13) --[[ Line: 19 ]] --[[ Name: GiveBuff ]]
        -- upvalues: v5 (copy), v3 (copy)
        if not v5[v11] then
            return;
        else
            local v14 = false;
            for _, v16 in v10.ActiveBuffs do
                if v16.Expiry.Type == v13.Type and v16.Level == v12 then
                    v14 = true;
                    local l_Expiry_0 = v16.Expiry;
                    l_Expiry_0.Duration = l_Expiry_0.Duration + v13.Duration;
                    break;
                end;
            end;
            if not v14 then
                if v13.Type == "Timer" then
                    table.insert(v10.ActiveBuffs, {
                        Name = v11, 
                        Level = v12, 
                        Expiry = {
                            Type = "Timer", 
                            Duration = v3.now() + v13.Duration
                        }
                    });
                    return;
                else
                    table.insert(v10.ActiveBuffs, {
                        Name = v11, 
                        Level = v12, 
                        Expiry = table.clone(v13)
                    });
                end;
            end;
            return;
        end;
    end
};
v18.GivePotion = function(_, v20, v21, v22) --[[ Line: 73 ]] --[[ Name: GivePotion ]]
    -- upvalues: v2 (copy), v18 (copy), v3 (copy)
    local v23 = v2[v21];
    local v24 = v20.ActivePotions[v21];
    if not v24 then
        local v25 = {
            Active = nil, 
            Queue = {}
        };
        v24 = v25;
        v20.ActivePotions[v21] = v25;
    end;
    local l_Active_0 = v24.Active;
    local v27 = v23.Buff.Expiry[v22] or v23.Buff.Expiry[1];
    local v28 = 1;
    for _, v30 in v20.MasteryUpgrades do
        if v30.Type == "PotionDuration" then
            v28 = v18:GetValue(v28, v30.Buff);
        end;
    end;
    local v31 = math.round(v27.Duration * v28);
    if v27.Type == "Uses" then
        v18:GiveBuff(v20, v23.Buff.Name, v22 or 1, v27);
    else
        local v32 = true;
        if l_Active_0 then
            if l_Active_0.Level == v22 then
                v32 = false;
                local l_Expiry_1 = l_Active_0.Expiry;
                l_Expiry_1.Duration = l_Expiry_1.Duration + v31;
            else
                local v34 = math.max(l_Active_0.Expiry.Duration - v3.now(), 0);
                if v34 > 0 then
                    table.insert(v24.Queue, {
                        Level = l_Active_0.Level, 
                        Expiry = {
                            Type = "Timer", 
                            Duration = v34
                        }
                    });
                end;
                v24.Active = nil;
            end;
        end;
        if v32 then
            local v35 = false;
            for _, v37 in v24.Queue do
                if v37.Level == v22 then
                    v35 = true;
                    local l_Expiry_2 = v37.Expiry;
                    l_Expiry_2.Duration = l_Expiry_2.Duration + v31;
                    break;
                end;
            end;
            if not v35 then
                table.insert(v24.Queue, {
                    Level = v22, 
                    Expiry = {
                        Type = "Timer", 
                        Duration = v31
                    }
                });
            end;
            table.sort(v24.Queue, function(v39, v40) --[[ Line: 169 ]]
                return v39.Level > v40.Level;
            end);
        end;
    end;
    v18:Update(v20);
end;
v18.UseBuffs = function(_, v42, v43, v44, v45) --[[ Line: 186 ]] --[[ Name: UseBuffs ]]
    -- upvalues: v3 (copy), v2 (copy), v5 (copy), v18 (copy)
    local v46 = v3.now();
    local v47 = {};
    for v48, v49 in v42.ActivePotions do
        local v50 = v5[v2[v48].Buff.Name];
        local l_Active_1 = v49.Active;
        if v50.Stat == v43 and l_Active_1 and l_Active_1.Expiry.Duration - v46 > 0 then
            local l_Buff_0 = v50.Level[l_Active_1.Level].Buff;
            table.insert(v47, {
                Name = v48, 
                Level = l_Active_1.Level, 
                Buff = l_Buff_0
            });
        end;
    end;
    for v53 = #v42.ActiveBuffs, 1, -1 do
        local v54 = v42.ActiveBuffs[v53];
        local v55 = v5[v54.Name];
        if v55.Stat == v43 then
            local v56 = false;
            if v54.Expiry.Type == "Uses" then
                local l_Duration_0 = v54.Expiry.Duration;
                if l_Duration_0 > 0 then
                    if not v45 then
                        l_Duration_0 = math.max(0, l_Duration_0 - 1);
                        v54.Expiry.Duration = l_Duration_0;
                    end;
                    v56 = true;
                end;
                if l_Duration_0 == 0 and not v45 then
                    table.remove(v42.ActiveBuffs, v53);
                end;
            elseif v54.Expiry.Duration - v46 > 0 then
                v56 = true;
            end;
            if v56 then
                local l_Buff_1 = v55.Level[v54.Level].Buff;
                table.insert(v47, {
                    Name = v54.Name, 
                    Level = v54.Level, 
                    Buff = l_Buff_1
                });
            end;
        end;
    end;
    for _, v60 in v47 do
        v44(v60.Buff);
    end;
    v18:Update(v42);
    return v47;
end;
v18.Update = function(_, v62) --[[ Line: 293 ]] --[[ Name: Update ]]
    -- upvalues: v3 (copy)
    if not next(v62.ActivePotions) and not next(v62.ActiveBuffs) then
        return false;
    else
        local v63 = v3.now();
        local v64 = false;
        for v65, v66 in v62.ActivePotions do
            if v66.Active then
                if v66.Active.Expiry.Duration - v63 <= 0 then
                    v64 = true;
                    v66.Active = nil;
                else
                    continue;
                end;
            end;
            if #v66.Queue == 0 then
                v64 = true;
                v62.ActivePotions[v65] = nil;
            else
                table.sort(v66.Queue, function(v67, v68) --[[ Line: 324 ]]
                    return v67.Level > v68.Level;
                end);
                local v69 = table.remove(v66.Queue, 1);
                if v69 then
                    local l_Expiry_3 = v69.Expiry;
                    l_Expiry_3.Duration = l_Expiry_3.Duration + v63;
                    v64 = true;
                    v66.Active = v69;
                end;
            end;
        end;
        for v71 = #v62.ActiveBuffs, 1, -1 do
            local v72 = v62.ActiveBuffs[v71];
            if v72.Expiry.Type == "Timer" and v72.Expiry.Duration < v63 then
                v64 = true;
                table.remove(v62.ActiveBuffs, v71);
            end;
        end;
        return v64;
    end;
end;
v18.OnJoining = function(_, v74) --[[ Line: 355 ]] --[[ Name: OnJoining ]]
    -- upvalues: v3 (copy), v18 (copy)
    local v75 = v3.now();
    for _, v77 in v74.ActiveBuffs do
        if v77.Expiry.Type == "Timer" then
            local l_Expiry_4 = v77.Expiry;
            l_Expiry_4.Duration = l_Expiry_4.Duration + v75;
        end;
    end;
    v18:Update(v74);
end;
v18.OnLeaving = function(_, v80) --[[ Line: 370 ]] --[[ Name: OnLeaving ]]
    -- upvalues: v3 (copy)
    local v81 = v3.now();
    for _, v83 in v80.ActiveBuffs do
        if v83.Expiry.Type == "Timer" then
            local l_Expiry_5 = v83.Expiry;
            l_Expiry_5.Duration = l_Expiry_5.Duration - v81;
        end;
    end;
    for _, v86 in v80.ActivePotions do
        local l_Active_2 = v86.Active;
        if l_Active_2 and l_Active_2.Expiry.Type == "Timer" then
            v86.Active = nil;
            local v88 = math.max(l_Active_2.Expiry.Duration - v3.now(), 0);
            if v88 > 0 then
                table.insert(v86.Queue, {
                    Level = l_Active_2.Level, 
                    Expiry = {
                        Type = "Timer", 
                        Duration = v88
                    }
                });
            end;
        end;
    end;
end;
v18.Format = function(_, v90, v91) --[[ Line: 411 ]] --[[ Name: Format ]]
    -- upvalues: v6 (copy), v7 (copy)
    if v91.Type == "Percent" then
        return string.gsub(v90, "BUFF", string.gsub("+" .. v6(v91.Value), "%%", "%%%%"));
    elseif v91.Type == "Value" then
        return string.gsub(v90, "BUFF", "+" .. v7(v91.Value));
    else
        return "unknown";
    end;
end;
v18.GetValue = function(_, v93, v94, v95) --[[ Line: 422 ]] --[[ Name: GetValue ]]
    local v96 = v95 or 1;
    if v94.Type == "Percent" then
        return v93 + v94.Value / 100 * v96;
    else
        if v94.Type == "Value" then
            v93 = v93 + v94.Value * v96;
        end;
        return v93;
    end;
end;
return v18;
ModuleScript: ItemUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = game:GetService("HttpService");
local _ = game:GetService("ServerScriptService");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v4 = require(l_ReplicatedStorage_0.Shared.Data.Currency);
local v5 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v6 = require(l_ReplicatedStorage_0.Shared.Data.Potions);
local v7 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatRomanNumeral);
local v8 = require(l_ReplicatedStorage_0.Shared.Data.Powerups);
local v9 = require(l_ReplicatedStorage_0.Shared.Constants);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.Time);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatCommas);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatPercent);
local v13 = require(l_ReplicatedStorage_0.Shared.Data.PermanentBuffs);
local v14 = require(l_ReplicatedStorage_0.Shared.Utils.PetStackUtil);
local v15 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.PetUtil);
local v16 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.BuffUtil);
local v17 = require(l_ReplicatedStorage_0.Shared.Data.Buffs);
local v18 = require(script.OrbIcon);
local v19 = require(script.PotionIcon);
local v20 = require(l_ReplicatedStorage_0.Shared.Utils.CreatePlayerPet);
local v21 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatSuffix);
local v37 = {
    Validate = function(_, v23) --[[ Line: 40 ]] --[[ Name: Validate ]]
        -- upvalues: v4 (copy), v5 (copy), v6 (copy), v8 (copy), v13 (copy)
        if v23.Type == "Currency" then
            return v4[v23.Currency] ~= nil;
        elseif v23.Type == "Pet" then
            return v5[v23.Name] ~= nil;
        elseif v23.Type == "Potion" then
            return v6[v23.Name] ~= nil;
        elseif v23.Type == "Powerup" then
            return v8[v23.Name] ~= nil;
        elseif v23.Type == "PermanentBuff" then
            return v13[v23.Name] ~= nil;
        else
            return false;
        end;
    end, 
    GetName = function(_, v25) --[[ Line: 57 ]] --[[ Name: GetName ]]
        -- upvalues: v4 (copy), v15 (copy), v6 (copy), v7 (copy)
        if v25.Type == "Currency" then
            local l_Currency_0 = v25.Currency;
            return v4[l_Currency_0].Display or l_Currency_0;
        elseif v25.Type == "Pet" then
            return v15:GetName(v25);
        elseif v25.Type == "Potion" then
            local v27 = v6[v25.Name];
            if not v27.OneLevel and #v27.Buff.Expiry > 0 and v25.Level then
                if v25.Level < 6 then
                    return (("%* %*"):format(v25.Name, (v7(v25.Level or 1))));
				elseif v25.Level == 6 then
					return (("%* Evolved"):format(v25.Name));
		     	else
				    return ("%* Infinity"):format(v25.Name)
				end;
            else
                return v25.Name;
            end;
        elseif v25.Name then
            return v25.Name;
        else
            return "Unknown";
        end;
    end, 
    GetDescription = function(_, v29) --[[ Line: 85 ]] --[[ Name: GetDescription ]]
        -- upvalues: v6 (copy), v17 (copy), v16 (copy), v13 (copy), v8 (copy)
        if v29.Type == "Potion" then
            local v30 = v6[v29.Name];
            local v31 = v17[v30.Buff.Name];
            local v32 = v29.Level or 1;
            local _ = v31.Level[v32];
            local v34 = v31.Description[v30.Buff.Expiry[v32].Type];
            local v35 = v31.Level[v32];
            return v16:Format(v34, v35.Buff);
        elseif v29.Type == "PermanentBuff" then
            local v36 = v13[v29.Name];
            return v16:Format(v36.Description, v36.Buff);
        elseif v29.Type == "Powerup" then
            return v8[v29.Name].Description or "";
        else
            return "";
        end;
    end
};
v37.GetRarity = function(_, v39) --[[ Line: 110 ]] --[[ Name: GetRarity ]]
    -- upvalues: v37 (copy), v5 (copy), v6 (copy), v9 (copy), v8 (copy)
    assert(v37:Validate(v39) == true, (("%* is not a valid item."):format((v37:GetName(v39)))));
    if v39.Type == "Pet" then
        return v5[v39.Name].Rarity;
    elseif v39.Type == "Potion" then
        local v40 = v6[v39.Name];
        if v40.Rarity then
            return v40.Rarity;
        else
            return v9.PotionRarityMap[v39.Level or 1] or "Common";
        end;
    elseif v39.Type == "Powerup" then
        return v8[v39.Name].Rarity;
    elseif v39.Type == "PermanentBuff" then
        return "Legendary";
    else
        return "Common";
    end;
end;
v37.GetValue = function(_, v42) --[[ Line: 133 ]] --[[ Name: GetValue ]]
    -- upvalues: v37 (copy), v15 (copy)
    assert(v37:Validate(v42) == true, (("%* is not a valid item."):format((v37:GetName(v42)))));
    if v42.Type == "Pet" then
        return (math.floor(100 / v15:GetChance(v42)));
    else
        return 1;
    end;
end;
v37.GetAmount = function(_, v44) --[[ Line: 144 ]] --[[ Name: GetAmount ]]
    -- upvalues: v37 (copy)
    assert(v37:Validate(v44) == true, (("%* is not a valid item."):format((v37:GetName(v44)))));
    local l_Amount_0 = v44.Amount;
    if l_Amount_0 then
        return l_Amount_0;
    else
        return 1;
    end;
end;
v37.GetOwnedAmount = function(_, v47, v48) --[[ Line: 154 ]] --[[ Name: GetOwnedAmount ]]
    -- upvalues: v37 (copy)
    assert(v37:Validate(v48) == true, (("%* is not a valid item."):format((v37:GetName(v48)))));
    if v48.Type == "Currency" then
        if v48.Currency == "Points" then
            return v47.Season.Points;
        elseif v48.Currency == "Stars" then
            return v47.DailyRewards.Stars;
        elseif v48.Currency == "ChallengePoints" then
            return v47.ChallengePass.Points;
        else
            return v47[v48.Currency] or 0;
        end;
    else
        if v48.Type == "Potion" then
            for _, v50 in v47.Potions do
                if v50.Level == v48.Level and v50.Name == v48.Name then
                    return v50.Amount;
                end;
            end;
        elseif v48.Type == "Powerup" then
            return v47.Powerups[v48.Name] or 0;
        elseif v48.Type == "PermanentBuff" then
            return v47.PermanentBuffs[v48.Name] or 0;
        end;
        return 0;
    end;
end;
v37.CanAfford = function(_, v52, v53) --[[ Line: 186 ]] --[[ Name: CanAfford ]]
    -- upvalues: v37 (copy)
    assert(v37:Validate(v53) == true, (("%* is not a valid item."):format((v37:GetName(v53)))));
    return v37:GetOwnedAmount(v52, v53) >= v37:GetAmount(v53);
end;
v37.UpdateIcon = function(_, v55, v56) --[[ Line: 194 ]] --[[ Name: UpdateIcon ]]
    -- upvalues: v19 (copy), v18 (copy), v37 (copy), v4 (copy), v5 (copy), v6 (copy), v8 (copy), v13 (copy), v9 (copy)
    if not v56 then
        v19.cleanup(v55);
        v18.cleanup(v55);
        return;
    else
        assert(v37:Validate(v56) == true, (("%* is not a valid item."):format((v37:GetName(v56)))));
        local v57 = nil;
        if v56.Type == "Currency" then
            v57 = v4[v56.Currency].Image;
        elseif v56.Type == "Pet" then
            local v58 = v5[v56.Name];
            v57 = if not not v56.Mythic or v56.Shiny then v58.Images[("%*%*"):format(v56.Mythic and "Mythic" or "", v56.Shiny and "Shiny" or "")] else v58.Images.Normal;
        elseif v56.Type == "Potion" then
            local v59 = v6[v56.Name];
            if v59.Image then
                v57 = v59.Image;
            else
                v19.new(v55, v56);
            end;
        elseif v56.Type == "Powerup" then
            local v60 = v8[v56.Name];
            if v60.Type ~= "Orb" then
                v57 = v60.Icon;
            else
                v18.new(v55, v56);
            end;
        elseif v56.Type == "PermanentBuff" then
            v57 = v13[v56.Name].Image;
        end;
        if v56.Type ~= "Potion" or v56.Type == "Potion" and v6[v56.Name].Image then
            v19.cleanup(v55);
        end;
        local v61 = v55:FindFirstChild("Label") or v55:FindFirstChildWhichIsA("ImageLabel");
        if v57 ~= nil then
            v61.Image = v57;
            v18.cleanup(v55);
        else
            v61.Image = v9.UnknownImage;
        end;
        local v62 = v56.Type == "Currency" and 0.85 or 1;
        v61.AnchorPoint = Vector2.one / 2;
        v61.Visible = v57 ~= nil;
        v61.Size = UDim2.fromScale(v62, v62);
        return;
    end;
end;
v37.Compare = function(_, v64, v65, v66) --[[ Line: 255 ]] --[[ Name: Compare ]]
    if v64.Type == "Currency" and v65.Type == "Currency" then
        if v66 and v64.Amount ~= v65.Amount then
            return false;
        else
            return v64.Currency == v65.Currency;
        end;
    elseif v64.Type == "Pet" and v65.Type == "Pet" then
        if v64.Name ~= v65.Name then
            return false;
        elseif v64.Shiny ~= v65.Shiny then
            return false;
        elseif v64.Mythic ~= v65.Mythic then
            return false;
        else
            return true;
        end;
    elseif v64.Type == "Potion" and v65.Type == "Potion" then
        if v66 and v64.Amount ~= v65.Amount then
            return false;
        elseif v64.Name ~= v65.Name then
            return false;
        elseif v64.Level ~= v65.Level then
            return false;
        else
            return true;
        end;
    elseif v64.Type == "Powerup" and v65.Type == "Powerup" then
        if v66 and v64.Amount ~= v65.Amount then
            return false;
        else
            return v64.Name == v65.Name;
        end;
    elseif v64.Type == "PermanentBuff" and v65.Type == "PermanentBuff" then
        return v64.Name == v65.Name;
    else
        return false;
    end;
end;
v37.FormatAmount = function(_, v68, v69) --[[ Line: 298 ]] --[[ Name: FormatAmount ]]
    -- upvalues: v37 (copy), v21 (copy)
    local l_v37_Amount_0 = v37:GetAmount(v69);
    if v69.Type == "Currency" then
        v68.Text = v21(l_v37_Amount_0, 1000);
    else
        v68.Text = ("x%*"):format((v21(l_v37_Amount_0, 1000)));
    end;
    v68.Visible = l_v37_Amount_0 > 1;
end;
local function _(v71, v72, v73) --[[ Line: 309 ]] --[[ Name: modifyStoredAmount ]]
    local v74 = v71[v72] or 0;
    if v74 + v73 < 0 then
        v71[v72] = nil;
    else
        v71[v72] = v74 + v73;
    end;
    return true;
end;
local function v92(v76, v77, v78) --[[ Line: 325 ]] --[[ Name: modifyAmount ]]
    if v77.Type == "Currency" then
        if v77.Currency == "Points" then
            local l_Season_0 = v76.Season;
            l_Season_0.Points = l_Season_0.Points + v78;
            return "Season";
        elseif v77.Currency == "Stars" then
            local l_DailyRewards_0 = v76.DailyRewards;
            l_DailyRewards_0.Stars = l_DailyRewards_0.Stars + v78;
            return "DailyRewards";
        elseif v77.Currency == "ChallengePoints" then
            local l_ChallengePass_0 = v76.ChallengePass;
            l_ChallengePass_0.Points = l_ChallengePass_0.Points + v78;
            return "ChallengePass";
        else
            local l_Currency_1 = v77.Currency;
            v76[l_Currency_1] = v76[l_Currency_1] + v78;
            return v77.Currency;
        end;
    elseif v77.Type == "Potion" then
        local v83 = false;
        for v84, v85 in v76.Potions do
            if v85.Name == v77.Name and v85.Level == (v77.Level or 1) then
                if v85.Amount + v78 <= 0 then
                    table.remove(v76.Potions, v84);
                else
                    v85.Amount = v85.Amount + v78;
                end;
                v83 = true;
                break;
            end;
        end;
        if not v83 and v78 > 0 then
            table.insert(v76.Potions, {
                Name = v77.Name, 
                Level = v77.Level or 1, 
                Amount = v78
            });
        end;
        return "Potions";
    else
        if v77.Type == "Powerup" then
            local l_Powerups_0 = v76.Powerups;
            local l_Name_0 = v77.Name;
            local v88 = l_Powerups_0[l_Name_0] or 0;
            if v88 + v78 < 0 then
                l_Powerups_0[l_Name_0] = nil;
            else
                l_Powerups_0[l_Name_0] = v88 + v78;
            end;
            if true then
                return "Powerups";
            end;
        elseif v77.Type == "PermanentBuff" then
            local l_PermanentBuffs_0 = v76.PermanentBuffs;
            local l_Name_1 = v77.Name;
            local v91 = l_PermanentBuffs_0[l_Name_1] or 0;
            if v91 + v78 < 0 then
                l_PermanentBuffs_0[l_Name_1] = nil;
            else
                l_PermanentBuffs_0[l_Name_1] = v91 + v78;
            end;
            if true then
                return "PermanentBuffs";
            end;
        end;
        return;
    end;
end;
v37.Deduct = function(_, v94, v95) --[[ Line: 390 ]] --[[ Name: Deduct ]]
    -- upvalues: v37 (copy), v92 (copy)
    if v95.Type == "PermanentBuff" or v95.Type == "Pet" then
        return;
    elseif not v37:Validate(v95) then
        return;
    else
        local l_v37_Amount_1 = v37:GetAmount(v95);
        if v37:GetOwnedAmount(v94, v95) < l_v37_Amount_1 then
            return;
        else
            return v92(v94, v95, -l_v37_Amount_1);
        end;
    end;
end;
v37.Add = function(_, v98, v99) --[[ Line: 410 ]] --[[ Name: Add ]]
    -- upvalues: v37 (copy), v20 (copy), v14 (copy), v92 (copy)
    if not v37:Validate(v99) then
        return;
    elseif v99.Type == "Pet" then
        for _ = 1, v99.Amount or 1 do
            local v101 = v20(v98, v99.Name, {
                Shiny = v99.Shiny, 
                Mythic = v99.Mythic, 
                XP = v99.XP
            });
            local v102 = false;
            if v14:CanMergePet(v98, v101) then
                local l_v14_MergePet_0 = v14:FindMergePet(v98, v101);
                if l_v14_MergePet_0 then
                    l_v14_MergePet_0.Amount = (l_v14_MergePet_0.Amount or 1) + 1;
                    v102 = true;
                end;
            end;
            if not v102 then
                table.insert(v98.Pets, v101);
            end;
        end;
        return "Pets";
    else
        local l_v37_Amount_2 = v37:GetAmount(v99);
        return v92(v98, v99, l_v37_Amount_2);
    end;
end;
v37.Split = function(_, v106, v107) --[[ Line: 448 ]] --[[ Name: Split ]]
    if v106.Type == "Pet" or v106.Type == "PermanentBuff" or not v106.Amount then
        return {
            v106
        };
    else
        local v108 = v106.Amount or 0;
        if v108 <= v107 then
            return {
                v106
            };
        else
            v107 = math.min(v108, v107);
            local v109 = math.floor(v108 / v107);
            local v110 = table.create(v107, v109);
            for v111 = 1, v108 - v109 * v107 do
                v110[v111] = v110[v111] + 1;
            end;
            local v112 = {};
            for v113, v114 in v110 do
                local v115 = table.clone(v106);
                v115.Amount = v114;
                v112[v113] = v115;
            end;
            return v112;
        end;
    end;
end;
v37.Combine = function(_, v117) --[[ Line: 483 ]] --[[ Name: Combine ]]
    -- upvalues: v37 (copy)
    local v118 = {};
    local v119 = {};
    for _, v121 in v117 do
        if v121.Type == "PermanentBuff" or v121.Type == "Pet" then
            table.insert(v119, v121);
        else
            local l_v37_Name_0 = v37:GetName(v121);
            if v118[l_v37_Name_0] then
                local v123 = v118[l_v37_Name_0];
                v123.Amount = v123.Amount + v121.Amount;
            else
                v118[l_v37_Name_0] = table.clone(v121);
            end;
        end;
    end;
    for _, v125 in v118 do
        table.insert(v119, v125);
    end;
    return v119;
end;
return v37;
ModuleScript: OrbIcon
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = game:GetService("TweenService");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v3 = require(l_ReplicatedStorage_0.Shared.Utils.AnimateColor);
local v4 = require(l_ReplicatedStorage_0.Shared.Data.Powerups);
local l_Frame_0 = Instance.new("Frame");
l_Frame_0.AnchorPoint = Vector2.one / 2;
l_Frame_0.Size = UDim2.fromScale(0.8, 0.8);
l_Frame_0.Position = UDim2.fromScale(0.5, 0.5);
l_Frame_0.BackgroundTransparency = 1;
local l_ImageLabel_0 = Instance.new("ImageLabel");
l_ImageLabel_0.AnchorPoint = l_Frame_0.AnchorPoint;
l_ImageLabel_0.Size = UDim2.fromScale(1, 1);
l_ImageLabel_0.Position = UDim2.fromScale(0.5, 0.5);
l_ImageLabel_0.BackgroundTransparency = 1;
l_ImageLabel_0.ZIndex = 2;
l_ImageLabel_0.Name = "Label";
l_ImageLabel_0.Parent = l_Frame_0;
local v7 = l_ImageLabel_0:Clone();
v7.ZIndex = -1;
v7.Name = "Fade";
v7.Size = UDim2.fromScale(1.12, 1.12);
v7.Image = "rbxassetid://108711580352701";
v7.Parent = l_Frame_0;
local v8 = {};
local function v13(v9) --[[ Line: 40 ]] --[[ Name: cleanup ]]
    -- upvalues: v8 (copy)
    for _, v11 in v9:GetChildren() do
        if v11:IsA("Frame") then
            local v12 = v8[v11];
            if v12 then
                v12();
                v8[v11] = nil;
            end;
        end;
    end;
end;
return {
    new = function(v14, v15, _) --[[ Line: 53 ]] --[[ Name: new ]]
        -- upvalues: v13 (copy), l_Frame_0 (copy), v4 (copy), v3 (copy), v8 (copy)
        local l_Frame_1 = v14:FindFirstChildOfClass("Frame");
        if l_Frame_1 and l_Frame_1.Name == v15.Name then
            return;
        else
            v13(v14);
            if l_Frame_1 and not l_Frame_1:FindFirstChild("Fade") then
                l_Frame_1:Destroy();
                l_Frame_1 = nil;
            end;
            if not l_Frame_1 then
                l_Frame_1 = l_Frame_0:Clone();
            end;
            assert(l_Frame_1);
            local v18 = v4[v15.Name];
            l_Frame_1.Label.Image = v18.Icon;
            l_Frame_1.Name = v15.Name;
            l_Frame_1.Parent = v14;
            v3.Cycle(l_Frame_1.Fade, v15.Name, {
                Speed = 0.5
            });
            v8[l_Frame_1] = function() --[[ Line: 76 ]] --[[ Name: callback ]]
                -- upvalues: v3 (ref), l_Frame_1 (ref)
                v3.None(l_Frame_1.Fade);
                l_Frame_1:Destroy();
            end;
            return;
        end;
    end, 
    cleanup = v13
};
ModuleScript: PotionIcon
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Utils.AnimateColor);
local v3 = require(l_ReplicatedStorage_0.Shared.Data.Potions);
local l_Frame_0 = Instance.new("Frame");
l_Frame_0.AnchorPoint = Vector2.one / 2;
l_Frame_0.Size = UDim2.fromScale(1, 1);
l_Frame_0.Position = UDim2.fromScale(0.5, 0.5);
l_Frame_0.BackgroundTransparency = 1;
local l_ImageLabel_0 = Instance.new("ImageLabel");
l_ImageLabel_0.AnchorPoint = l_Frame_0.AnchorPoint;
l_ImageLabel_0.Size = UDim2.fromScale(1, 1);
l_ImageLabel_0.Position = UDim2.fromScale(0.5, 0.5);
l_ImageLabel_0.BackgroundTransparency = 1;
l_ImageLabel_0.ZIndex = 2;
l_ImageLabel_0.Name = "Border";
l_ImageLabel_0.Parent = l_Frame_0;
local v6 = l_ImageLabel_0:Clone();
v6.ZIndex = 1;
v6.Name = "Liquid";
v6.Parent = l_Frame_0;
local v7 = {
    [1] = {
        Scale = 0.75, 
        Border = "rbxassetid://132471572935162", 
        Liquid = "rbxassetid://75087097262534"
    }, 
    [2] = {
        Scale = 0.8, 
        Border = "rbxassetid://81633414406283", 
        Liquid = "rbxassetid://127209732282967"
    }, 
    [3] = {
        Scale = 0.9, 
        Border = "rbxassetid://133997507319472", 
        Liquid = "rbxassetid://124712048821197"
    }, 
    [4] = {
        Scale = 1, 
        Border = "rbxassetid://129177261389626", 
        Liquid = "rbxassetid://135437581814171"
    }, 
    [5] = {
        Scale = 1, 
        Border = "rbxassetid://117399181299023", 
        Liquid = "rbxassetid://118929748403337"
    }, 
    [6] = {
        Scale = 1, 
        Border = "rbxassetid://84055961369538", 
        Liquid = "rbxassetid://131061782550443"
	},
	[7] = {
		Scale = 1.1, 
		Border = "rbxassetid://88259681396349", 
		Liquid = "rbxassetid://117650493267270"
	}
};
local function _(v8) --[[ Line: 76 ]] --[[ Name: getName ]]
    return (("Potion%*%*"):format(v8.Name, v8.Level or ""));
end;
local function _(v10) --[[ Line: 81 ]] --[[ Name: resolvePotionImage ]]
	-- upvalues: v7 (copy)
    if v10.Name == "Infinity Elixir" then
        return {
            Scale = 1, 
            Border = "rbxassetid://82532482890249", 
            Liquid = "rbxassetid://138542923319686"
		};
		elseif v10.Name == "Egg Elixir" then
			return {
				Scale = 1, 
				Border = "rbxassetid://74062731164171", 
				Liquid = "rbxassetid://130782351446670"
			};
		elseif v10.Name == "Aura Elixir" then
			return {
				Scale = 1, 
			    Border = "rbxassetid://82532482890249", 
				Liquid = "rbxassetid://138542923319686"
			};
		elseif v10.Name == "Sheckles Potion" then
			return {
				Scale = 1, 
				Border = "rbxassetid://84055961369538", 
				Liquid = "rbxassetid://131061782550443"
			};
		elseif v10.Name == "Secret Elixir" then
			return {
				Scale = 1, 
			    Border = "rbxassetid://89764846131346", 
			    Liquid = "rbxassetid://89130559664135"
			};
    else
        return v7[math.min(v10.Level or 1, #v7)];
	end;
end;
local v12 = {};
local function v17(v13) --[[ Line: 96 ]] --[[ Name: cleanup ]]
    -- upvalues: v12 (copy)
    for _, v15 in v13:GetChildren() do
        if v15:IsA("Frame") then
            local v16 = v12[v15];
            if v16 then
                v16();
                v12[v15] = nil;
            end;
        end;
    end;
end;
return {
    new = function(v18, v19, v20) --[[ Line: 109 ]] --[[ Name: new ]]
        -- upvalues: v17 (copy), l_Frame_0 (copy), v3 (copy), v7 (copy), v2 (copy), v12 (copy)
        local l_Frame_1 = v18:FindFirstChildOfClass("Frame");
        local v22 = ("Potion%*%*"):format(v19.Name, v19.Level or "");
        if l_Frame_1 and l_Frame_1.Name == v22 then
            return;
        else
            v17(v18);
            if l_Frame_1 and not l_Frame_1:FindFirstChild("Liquid") then
                l_Frame_1:Destroy();
                l_Frame_1 = nil;
            end;
            if not l_Frame_1 then
                l_Frame_1 = l_Frame_0:Clone();
            end;
            assert(l_Frame_1);
            local v23 = v3[v19.Name];
            local v24 = if v19.Name == "Infinity Elixir" then {
                Scale = 1, 
                Border = "rbxassetid://82532482890249", 
                Liquid = "rbxassetid://138542923319686"
			} elseif v19.Name == "Egg Elixir" then {
					Scale = 1, 
					Border = "rbxassetid://74062731164171", 
					Liquid = "rbxassetid://130782351446670"
			} elseif v19.Name == "Aura Elixir" then {
					Scale = 1, 
					Border = "rbxassetid://82532482890249", 
					Liquid = "rbxassetid://138542923319686"
			} elseif v19.Name == "Secret Elixir" then {
					Scale = 1, 
					Border = "rbxassetid://89764846131346", 
					Liquid = "rbxassetid://89130559664135"
			} elseif v19.Name == "Sheckles Potion" then {
					Scale = 1, 
					Border = "rbxassetid://84055961369538", 
					Liquid = "rbxassetid://131061782550443"
			} else v7[math.min(v19.Level or 1, #v7)];
			if v19.Name == "Infinity Elixir" then
                v2.Shift(l_Frame_1.Liquid, "Rainbow", {
                    Speed = 0.4
				});
			elseif v19.Name == "Egg Elixir" then
				v2.Shift(l_Frame_1.Liquid, "PotionEgg", {
					Speed = 0.4
				});
			elseif v19.Name == "Aura Elixir" then
				v2.Shift(l_Frame_1.Liquid, "PotionAura", {
					Speed = 0.4
				})
			elseif v19.Name == "Secret Elixir" then
				v2.Shift(l_Frame_1.Liquid, "PotionSecret", {
					Speed = 0.4
				})
			elseif v19.Name == "Sheckles Potion" then
				v2.Shift(l_Frame_1.Liquid, "PotionSheckle", {
					Speed = 0.4
				})
            elseif v23.Gradient then
                if (v19.Level or 1) <= 3 then
                    v2.None(l_Frame_1.Liquid);
                    l_Frame_1.Liquid.ImageColor3 = v23.Gradient.Color.Keypoints[2].Value;
                else
                    v2.Shift(l_Frame_1.Liquid, v23.Gradient.Name, {
                        Speed = 1
                    });
                end;
            end;
            local function v25() --[[ Line: 141 ]] --[[ Name: callback ]]
                -- upvalues: v2 (ref), l_Frame_1 (ref)
                v2.None(l_Frame_1.Liquid);
                l_Frame_1:Destroy();
            end;
            local v26 = v24.Scale or 1;
            if v20 then
                v26 = v20;
            end;
            local v27 = UDim2.fromScale(v26, v26);
            l_Frame_1.Size = v27;
            l_Frame_1.Border.Image = v24.Border;
            l_Frame_1.Liquid.Image = v24.Liquid;
            l_Frame_1.Name = v22;
            l_Frame_1.Parent = v18;
            v12[l_Frame_1] = v25;
            return;
        end;
    end, 
    cleanup = v17
};
ModuleScript: MasteryUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Data.Mastery);
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v3 = require(l_ReplicatedStorage_0.Shared.Palette);
local v4 = require(l_ReplicatedStorage_0.Shared.Utils.RichText);
local v5 = require(l_ReplicatedStorage_0.Shared.Constants);
local v6 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatRomanNumeral);
local v7 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.BuffUtil);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatCommas);
local _ = require(l_ReplicatedStorage_0.Shared.Utils.Stats.StatsUtil);
local _ = require(l_ReplicatedStorage_0.Shared.Utils.Stats.ItemUtil);
local v11 = require(l_ReplicatedStorage_0.Shared.Data.Buffs);
local v12 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatSuffix);
local v13 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatOrdinal);
local v14 = {};
local v15 = {
    {
        Rarity = "Common", 
        Image = "rbxassetid://103647563371436", 
        Background = "rbxassetid://124950230259431"
    }, 
    {
        Rarity = "Common", 
        Image = "rbxassetid://138151473874116", 
        Background = "rbxassetid://82688914925637"
    }, 
    {
        Rarity = "Common", 
        Image = "rbxassetid://123080010589665", 
        Background = "rbxassetid://136702446926586"
    }, 
    {
        Rarity = "Common", 
        Image = "rbxassetid://130520792817070", 
        Background = "rbxassetid://85396073256157"
    }, 
    {
        Rarity = "Common", 
        Image = "rbxassetid://89693255062025", 
        Background = "rbxassetid://126282290300271"
    }, 
    {
        Rarity = "Legendary", 
        Image = "rbxassetid://79139259556993", 
        Background = "rbxassetid://83688823939489", 
        Effect = "Rainbow"
    }
};
local function _(v16, v17) --[[ Line: 63 ]] --[[ Name: resolveOptional ]]
    -- upvalues: v5 (copy)
    if typeof(v16) == "string" then
        return v16, 0;
    else
        local v18 = v16[math.min(v17 or 1, #v16)];
        if v18 then
            return v18, #v16;
        else
            return v16[1] or v5.UnknownImage, 0;
        end;
    end;
end;
v14.GetUpgrades = function(_, v21) --[[ Line: 80 ]] --[[ Name: GetUpgrades ]]
    -- upvalues: v1 (copy)
    local v22 = {};
    for v23, v24 in v1.Upgrades do
        local v25 = v21.MasteryLevels[v23] or 0;
        for v26, v27 in v24.Levels do
            local v28 = false;
            if v27.UnlockEarly then
                v28 = v27.UnlockEarly(v21);
            end;
            if v25 >= v26 or v28 then
                for _, v30 in v27.Upgrades do
                    local v31 = v22[v30.Type];
                    if not v31 then
                        v22[v30.Type] = {
                            Level = v26, 
                            Upgrade = v30
                        };
                    elseif v31.Level < v26 then
                        v31.Upgrade = v30;
                    end;
                end;
            end;
        end;
    end;
    local v32 = {};
    for _, v34 in v22 do
        table.insert(v32, v34.Upgrade);
    end;
    return v32;
end;
v14.GetEmblem = function(_, v36, v37) --[[ Line: 118 ]] --[[ Name: GetEmblem ]]
    -- upvalues: v15 (copy)
    return v15[math.ceil((math.clamp((v36 - 1) / (v37 - 1) * #v15, 1, #v15)))];
end;
v14.GetUpgradeInfo = function(_, _, v40, v41) --[[ Line: 125 ]] --[[ Name: GetUpgradeInfo ]]
    -- upvalues: v1 (copy), v6 (copy), v5 (copy), v13 (copy), v11 (copy), v4 (copy), v3 (copy), v7 (copy), v12 (copy)
    local v42 = v1.Types[v40.Type];
    if v42 then
        local l_DisplayName_0 = v42.DisplayName;
        if v41 then
            l_DisplayName_0 = ("%* (%*)"):format(l_DisplayName_0, (v6(v41)));
        end;
        local l_Buff_0 = v40.Buff;
        local l_Description_0 = v42.Description;
        local v46;
        if typeof(l_Description_0) == "string" then
            v46 = l_Description_0;
        else
            local v47 = l_Description_0[math.min(v41 or 1, #l_Description_0)];
            if v47 then
                v46 = v47;
                local _ = #l_Description_0;
            else
                v46 = l_Description_0[1] or v5.UnknownImage;
            end;
        end;
        if v40.Type == "GoldenEgg" then
            v46 = string.gsub(v46, "BUFF", v13(v40.Every));
        elseif v40.Type == "LuckyStreak" then
            l_Description_0 = v40.Buff;
            local v49 = ("%* %*"):format(v11[l_Description_0.Name].DisplayName, (v6(l_Description_0.Level)));
            local v50 = math.max(1, (math.floor(l_Description_0.Expiry.Duration / 60)));
            v46 = string.gsub(v46, "BUFF", v49);
            v46 = string.gsub(v46, "DURATION", (("%* minute%*"):format(v50, v50 == 1 and "" or "s")));
        elseif v40.Type == "Sale" then
            v46 = if v40.Buff.Value == 100 then ("Shop items are %* on sale!"):format((v4.autoColor("ALWAYS", v3.Text.Cyan))) else v7:Format(v46, v40.Buff);
        elseif v40.Type == "PotionCrafting" then
            l_Description_0 = v40.Level;
            local v51 = ("Tier %*"):format((v6(l_Description_0)));
            if v5.PotionMaxLevel <= l_Description_0 then
                v51 = "Evolved";
            end;
            v46 = string.gsub(v46, "LEVEL", v51);
        elseif v40.Type == "InstantRestock" then
            l_Description_0 = v40.Buff.Value;
            v46 = string.gsub(v46, "BUFF", (("%* Time%*"):format(v12(l_Description_0), l_Description_0 == 1 and "" or "s")));
        elseif v40.Type == "MultiChest" then
            v46 = string.gsub(v46, "BUFF", (("%* Keys"):format(v40.Amount)));
        elseif l_Buff_0 then
            v46 = v7:Format(v46, l_Buff_0);
        end;
        l_Description_0 = ("Invalid (%*)"):format(v40.Type);
        if typeof(v42.DisplayName) == "string" then
            l_Description_0 = ("%*%*"):format(v42.DisplayName, v41 and v41 > 1 and (" %*"):format((v6(v41))) or "");
        else
            local l_DisplayName_1 = v42.DisplayName;
            local v53, v54;
            if typeof(l_DisplayName_1) == "string" then
                v54 = l_DisplayName_1;
                v53 = 0;
            else
                local v55 = l_DisplayName_1[math.min(v41 or 1, #l_DisplayName_1)];
                if v55 then
                    v54 = v55;
                    v53 = #l_DisplayName_1;
                else
                    v54 = l_DisplayName_1[1] or v5.UnknownImage;
                    v53 = 0;
                end;
            end;
            l_DisplayName_1 = v41 and v41 - v53 + 1;
            l_Description_0 = ("%*%*"):format(v54, l_DisplayName_1 and l_DisplayName_1 > 1 and (" %*"):format((v6(l_DisplayName_1))) or "");
        end;
        local v56 = {};
        local l_Image_0 = v42.Image;
        local v58;
        if typeof(l_Image_0) == "string" then
            v58 = l_Image_0;
        else
            local v59 = l_Image_0[math.min(v41 or 1, #l_Image_0)];
            if v59 then
                v58 = v59;
                local _ = #l_Image_0;
            else
                v58 = l_Image_0[1] or v5.UnknownImage;
            end;
        end;
        v56.Image = v58;
        v56.DisplayName = l_Description_0;
        v56.Description = v46;
        return v56;
    else
        return {
            Image = v5.UnknownImage, 
            DisplayName = ("Invalid (%*)"):format(v40.Type), 
            Description = "Unknown"
        };
    end;
end;
v14.GetUpgrade = function(_, v62, v63) --[[ Line: 200 ]] --[[ Name: GetUpgrade ]]
    for _, v65 in v62.MasteryUpgrades do
        if v65.Type == v63 then
            return v65;
        end;
    end;
    return nil;
end;
return v14;
ModuleScript: PetUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v3 = require(l_ReplicatedStorage_0.Shared.Constants);
local v4 = require(l_ReplicatedStorage_0.Shared.Utils.PetLevelUtil);
local v5 = require(l_ReplicatedStorage_0.Shared.Data.Enchants);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Currency);
local v7 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.BuffUtil);
local v14 = {
    GetName = function(_, v9) --[[ Line: 22 ]] --[[ Name: GetName ]]
        return (("%*%*%*"):format(v9.Shiny and "Shiny " or "", v9.Mythic and "Mythic " or "", v9.Name));
    end, 
    GetChance = function(_, v11) --[[ Line: 28 ]] --[[ Name: GetChance ]]
        -- upvalues: v2 (copy), v3 (copy)
        local v12 = v2[v11.Name];
        if not v12 then
            return 100;
        else
            local l_Chance_0 = v12.Chance;
            if v11.Shiny then
                l_Chance_0 = l_Chance_0 * (v3.ShinyChance / 100);
            end;
            if v11.Mythic then
                l_Chance_0 = l_Chance_0 * (v3.MythicChance / 100);
            end;
            return l_Chance_0;
        end;
    end
};
local function _(v15) --[[ Line: 45 ]] --[[ Name: getMultiplier ]]
    -- upvalues: v4 (copy)
    local v16 = 1;
    if v15.Shiny then
        v16 = v16 + 0.5;
    end;
    if v15.Mythic then
        v16 = v16 + 0.75;
    end;
    if v15.XP then
        local l_v4_LevelFromXP_0 = v4:GetLevelFromXP(v15.Name, v15.XP);
        local l_v4_MaxLevel_0 = v4:GetMaxLevel(v15);
        v16 = v16 + (l_v4_LevelFromXP_0 - 1) / (l_v4_MaxLevel_0 - 1) * 0.35;
    end;
    return v16;
end;
local function _(v20, v21) --[[ Line: 77 ]] --[[ Name: isOnTeam ]]
    return table.find(v20.Teams[v20.TeamEquipped].Pets, v21) ~= nil;
end;
local _ = function(v23) --[[ Line: 81 ]] --[[ Name: getTeamUpLevel ]]
    if v23.Enchants then
        for _, v25 in v23.Enchants do
            if v25.Id == "team-up" then
                return v25.Level;
            end;
        end;
    end;
    return nil;
end;
local l_Buffs_0 = v5["team-up"].Buffs;
v14.GetTeamUpMultiplier = function(_, v29) --[[ Line: 94 ]] --[[ Name: GetTeamUpMultiplier ]]
    -- upvalues: v7 (copy), l_Buffs_0 (copy)
    local v30 = false;
    local v31 = 1;
    for _, v33 in v29.Pets do
        local l_Id_0 = v33.Id;
        if table.find(v29.Teams[v29.TeamEquipped].Pets, l_Id_0) ~= nil then
            local v35;
            if v33.Enchants then
                for _, v37 in v33.Enchants do
                    if v37.Id == "team-up" then
                        v35 = v37.Level;
                        v30 = true;
                    end;
                    if v30 then
                        break;
                    end;
                end;
            end;
            if not v30 then
                v35 = nil;
            end;
            v30 = false;
            if v35 then
                v31 = v7:GetValue(v31, l_Buffs_0[v35]);
            end;
        end;
    end;
    return v31;
end;
local _ = function(v38, v39) --[[ Line: 115 ]] --[[ Name: getEnchantLevel ]]
    for _, v41 in v38 do
        if v41.Id == v39 then
            return v41.Level;
        end;
    end;
    return 0;
end;
v14.GetStats = function(_, v44, v45) --[[ Line: 125 ]] --[[ Name: GetStats ]]
    -- upvalues: v2 (copy), v14 (copy), v7 (copy), v5 (copy), v4 (copy)
    local v46 = false;
    local v47 = false;
    local v48 = false;
    local v49 = table.clone(v2[v44.Name].Stats);
    local v50 = v44.Enchants or {};
    local v51 = 1;
    if v45 then
        local v52 = v44.Id or "";
        if table.find(v45.Teams[v45.TeamEquipped].Pets, v52) ~= nil then
            local v53;
            if v44.Enchants then
                for _, v55 in v44.Enchants do
                    if v55.Id == "team-up" then
                        v53 = v55.Level;
                        v46 = true;
                    end;
                    if v46 then
                        break;
                    end;
                end;
            end;
            if not v46 then
                v53 = nil;
            end;
            v46 = false;
            if v53 ~= nil then
                v51 = v14:GetTeamUpMultiplier(v45);
            end;
        end;
    end;
    local v56 = 1;
    local v57;
    for _, v59 in v50 do
        if v59.Id == "looter" then
            v57 = v59.Level;
            v47 = true;
        end;
        if v47 then
            break;
        end;
    end;
    if not v47 then
        v57 = 0;
    end;
    v47 = false;
    if v57 > 0 then
        v56 = v7:GetValue(1, v5.looter.Buffs[v57]);
    end;
    local v60 = 1;
    local v61;
    for _, v63 in v50 do
        if v63.Id == "bubbler" then
            v61 = v63.Level;
            v48 = true;
        end;
        if v48 then
            break;
        end;
    end;
    if not v48 then
        v61 = 0;
    end;
    v48 = false;
    if v61 > 0 then
        v60 = v7:GetValue(1, v5.bubbler.Buffs[v61]);
    end;
    for v64, _ in v49 do
        local v66 = 1;
        if v64 == "Bubbles" then
            v66 = v51 - 1 + 1 + (v60 - 1);
        elseif v64 ~= "Gems" then
            v66 = v51 - 1 + 1 + (v56 - 1);
        elseif v64 == "Gems" then
            v66 = v51 - 1 + 1;
        end;
        v49[v64] = v49[v64] * v66;
    end;
    local v67 = 1;
    if v44.Shiny then
        v67 = v67 + 0.5;
    end;
    if v44.Mythic then
        v67 = v67 + 0.75;
    end;
    if v44.XP then
        local l_v4_LevelFromXP_1 = v4:GetLevelFromXP(v44.Name, v44.XP);
        local l_v4_MaxLevel_1 = v4:GetMaxLevel(v44);
        v67 = v67 + (l_v4_LevelFromXP_1 - 1) / (l_v4_MaxLevel_1 - 1) * 0.35;
    end;
    local l_v67_0 = v67;
    for v71, _ in v49 do
        v49[v71] = v49[v71] * l_v67_0;
    end;
    v49.Bubbles = math.round(v49.Bubbles or 0);
    return v49;
end;
v14.GetPower = function(_, v74) --[[ Line: 191 ]] --[[ Name: GetPower ]]
    -- upvalues: v14 (copy)
    local l_v14_Stats_0 = v14:GetStats(v74);
    local v76 = l_v14_Stats_0.Bubbles or 1;
    for v77, v78 in l_v14_Stats_0 do
        if v77 ~= "Bubbles" then
            v76 = v76 * v78;
        end;
    end;
    return v76;
end;
return v14;
ModuleScript: QuestUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v2 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.ItemUtil);
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatSuffix);
local v4 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.String.FormatPlural);
local v5 = require(l_ReplicatedStorage_0.Shared.Constants);
local v6 = require(l_ReplicatedStorage_0.Shared.Data.Flavors);
local v7 = require(l_ReplicatedStorage_0.Shared.Data.Eggs);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local v9 = require(l_ReplicatedStorage_0.Shared.Data.Gum);
local v10 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Table.DeepCopy);
local v11 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.Time);
local v12 = require(l_ReplicatedStorage_0.Shared.Data.Currency);
local v13 = {};
local function _(v14, v15) --[[ Line: 23 ]] --[[ Name: withPlural ]]
    -- upvalues: v4 (copy)
    if v15 > 1 then
        return v4(v14);
    else
        return v14;
    end;
end;
v13.GetRequirement = function(_, v18) --[[ Line: 32 ]] --[[ Name: GetRequirement ]]
    -- upvalues: v2 (copy)
    local l_Amount_0 = v18.Amount;
    if v18.Type == "Collect" then
        return v2:GetAmount(v18.Item);
    elseif l_Amount_0 then
        return l_Amount_0;
    else
        return 1;
    end;
end;
local v20 = {
    Common = "rbxassetid://104698246380703", 
    Unique = "rbxassetid://87473851841077", 
    Rare = "rbxassetid://95997927689265", 
    Epic = "rbxassetid://76555595934303", 
    Legendary = "rbxassetid://139856918486956", 
    Secret = "rbxassetid://72547722153444"
};
v13.FormatTask = function(_, v22) --[[ Line: 56 ]] --[[ Name: FormatTask ]]
    -- upvalues: v2 (copy), v4 (copy), v3 (copy), v11 (copy)
    if v22.Type == "Collect" then
        local l_v2_Amount_0 = v2:GetAmount(v22.Item);
        local l_v2_Name_0 = v2:GetName(v22.Item);
        local v25 = if l_v2_Amount_0 > 1 then v4(l_v2_Name_0) else l_v2_Name_0;
        if v22.Item.Type == "Currency" then
            v25 = v2:GetName(v22.Item);
        elseif v22.Item.Type == "Potion" then
            v25 = ("%* %*"):format(l_v2_Name_0, if l_v2_Amount_0 > 1 then v4("Potion") else "Potion");
        end;
        return (("Collect %* %*"):format(v3(l_v2_Amount_0), v25));
    elseif v22.Type == "Hatch" then
        local l_Amount_1 = v22.Amount;
        if v22.Egg then
            local v27 = "Hatch %* %*";
            local v28 = v3(v22.Amount);
            local l_Egg_0 = v22.Egg;
            return (v27:format(v28, if l_Amount_1 > 1 then v4(l_Egg_0) else l_Egg_0));
        elseif not v22.Name and not v22.Shiny and not v22.Rarity and not v22.Mythic then
            return (("Hatch %* %*"):format(v3(v22.Amount), if l_Amount_1 > 1 then v4("Egg") else "Egg"));
        else
            local v30 = "";
            if v22.Name then
                v30 = v22.Name;
            else
                if v22.Mythic then
                    v30 = v30 .. "Mythic ";
                end;
                if v22.Rarity then
                    v30 = v30 .. v22.Rarity .. " ";
                end;
                v30 = v30 .. "Pet";
            end;
            local v31 = "Hatch %* %*%*";
            local v32 = v3(l_Amount_1);
            local v33 = v22.Shiny and "Shiny " or "";
            local l_v30_0 = v30;
            return (v31:format(v32, v33, if l_Amount_1 > 1 then v4(l_v30_0) else l_v30_0));
        end;
    elseif v22.Type == "Bubbles" then
        return (("Blow %* Bubbles"):format((v3(v22.Amount))));
    elseif v22.Type == "Invite" then
        return (("Invite %* %*"):format(v3(v22.Amount), if v22.Amount > 1 then v4("Friend") else "Friend"));
    elseif v22.Type == "Purchase" then
        if v22.Purchased.Type == "Gum" then
            return (("Purchase %*"):format(v22.Purchased.Name));
        else
            return (("Purchase %* %*"):format(v22.Purchased.Name, v22.Purchased.Type));
        end;
    elseif v22.Type == "Group" then
        return "Join Blaze Games Group!";
    elseif v22.Type == "Discord" then
        return "Verify your Discord!";
    elseif v22.Type == "Playtime" then
        return (("Play for %*"):format((v11.formatRealTime(v22.Amount))));
    elseif v22.Type == "Sell" then
        if v22.Amount == 1 then
            return "Sell your bubble!";
        else
            return (("Sell %* Bubbles"):format((v3(v22.Amount))));
        end;
    elseif v22.Type == "AreaUnlock" then
        return (("Unlock %*%*"):format(string.find("the", string.lower(v22.Area)) and "" or "the ", v22.Area));
    else
        return "Unknown";
    end;
end;
v13.IsComplete = function(_, v36) --[[ Line: 134 ]] --[[ Name: IsComplete ]]
    -- upvalues: v13 (copy)
    local v37 = 0;
    for v38, v39 in v36.Tasks do
        if v13:GetRequirement(v39) == v36.Progress[v38] then
            v37 = v37 + 1;
        end;
    end;
    return v37 == #v36.Tasks;
end;
v13.FindById = function(_, v41, v42) --[[ Line: 147 ]] --[[ Name: FindById ]]
    local v43 = nil;
    for _, v45 in v41.Quests do
        if v45.Id == v42 then
            return v45;
        end;
    end;
    return v43;
end;
v13.Remove = function(_, v47, v48) --[[ Line: 163 ]] --[[ Name: Remove ]]
    local v49 = false;
    for v50 = #v47.Quests, 1, -1 do
        if v48(v47.Quests[v50]) == true then
            v49 = true;
            table.remove(v47.Quests, v50);
        end;
    end;
    return v49;
end;
v13.Add = function(_, v52, v53) --[[ Line: 183 ]] --[[ Name: Add ]]
    -- upvalues: v10 (copy)
    local v54 = true;
    for _, v56 in v52.Quests do
        if v56.Id == v53.Id then
            v54 = false;
            break;
        end;
    end;
    if v54 then
        local v57 = v10(v53);
        for v58, v59 in v57.Tasks do
            if v59.Type == "Purchase" then
                local v60 = false;
                if v59.Purchased.Type == "Gum" then
                    if v52.Gum[v59.Purchased.Name] or v52.Passes.VIP or v52.Passes["Infinity Gum"] then
                        v60 = true;
                    end;
                elseif v59.Purchased.Type == "Flavor" and (v52.Flavors[v59.Purchased.Name] or v52.Passes.VIP) then
                    v60 = true;
                end;
                if v60 then
                    v57.Progress[v58] = 1;
                end;
            elseif v59.Type == "AreaUnlock" and v52.AreasUnlocked[v59.Area] then
                v57.Progress[v58] = 1;
            end;
        end;
        table.insert(v52.Quests, v57);
    end;
    return v54;
end;
v13.CompareTask = function(_, v62, v63, v64) --[[ Line: 227 ]] --[[ Name: CompareTask ]]
    -- upvalues: v2 (copy)
    if v62.Type == "Bubbles" and v63.Type == "Bubbles" then
        if v64 and v62.Amount ~= v63.Amount then
            return false;
        else
            return true;
        end;
    elseif v62.Type == "Collect" and v63.Type == "Collect" then
        return v2:Compare(v62.Item, v63.Item, v64);
    elseif v62.Type == "Purchase" and v63.Type == "Purchase" then
        if v62.Purchased.Type ~= v63.Purchased.Type then
            return false;
        elseif v62.Purchased.Name ~= v63.Purchased.Name then
            return false;
        else
            return true;
        end;
    elseif v62.Type == "Hatch" and v63.Type == "Hatch" then
        if v64 and v62.Amount ~= v63.Amount then
            return false;
        elseif not v62.Shiny and not v62.Mythic and not v62.Name and not v62.Rarity and not v62.Egg then
            return true;
        elseif v62.Rarity and v62.Rarity ~= v63.Rarity then
            return false;
        elseif v62.Name and v62.Name ~= v63.Name then
            return false;
        elseif v62.Shiny and v62.Shiny ~= v63.Shiny then
            return false;
        elseif v62.Mythic and v62.Mythic ~= v63.Mythic then
            return false;
        elseif v62.Egg and v62.Egg ~= v63.Egg then
            return false;
        else
            return true;
        end;
    elseif v62.Type == "Invite" and v63.Type == "Invite" then
        if v64 and v62.Amount ~= v63.Amount then
            return false;
        else
            return true;
        end;
    elseif v62.Type == "Group" and v63.Type == "Group" then
        return true;
    elseif v62.Type == "Playtime" and v63.Type == "Playtime" then
        if v64 and v62.Amount ~= v63.Amount then
            return false;
        else
            return true;
        end;
    elseif v62.Type == "Sell" and v63.Type == "Sell" then
        if v64 and v62.Amount == v63.Amount then
            return false;
        else
            return true;
        end;
    elseif v62.Type == "AreaUnlock" and v63.Type == "AreaUnlock" then
        return v62.Area == v63.Area;
    elseif v62.Type == "Discord" and v63.Type == "Discord" then
        return true;
    else
        return false;
    end;
end;
v13.Compare = function(_, v66, v67) --[[ Line: 303 ]] --[[ Name: Compare ]]
    -- upvalues: v13 (copy), v2 (copy)
    if #v66.Tasks ~= #v67.Tasks or #v66.Rewards ~= #v67.Rewards then
        return false;
    else
        for v68, v69 in v66.Tasks do
            local v70 = v67.Tasks[v68];
            if not v13:CompareTask(v69, v70, true) then
                return false;
            end;
        end;
        for v71, v72 in v66.Rewards do
            local v73 = v67.Rewards[v71];
            if not v2:Compare(v72, v73, true) then
                return false;
            end;
        end;
        return true;
    end;
end;
v13.UpdateTaskIcon = function(_, v75, v76) --[[ Line: 328 ]] --[[ Name: UpdateTaskIcon ]]
    -- upvalues: v6 (copy), v2 (copy), v7 (copy), v20 (copy), v9 (copy), v12 (copy), v5 (copy)
    if v76.Type == "Bubbles" then
        v75.Label.Image = v6["Bubble Gum"].Image;
        return;
    elseif v76.Type == "Collect" then
        v2:UpdateIcon(v75, v76.Item);
        return;
    else
        if v76.Type == "Hatch" then
            if v76.Egg then
                v75.Label.Image = v7[v76.Egg].Image;
                return;
            elseif not v76.Name and not v76.Shiny and not v76.Rarity and not v76.Mythic then
                v75.Label.Image = v7["Common Egg"].Image;
                return;
            elseif v76.Name then
                v2:UpdateIcon(v75, {
                    Type = "Pet", 
                    Name = v76.Name, 
                    Mythic = v76.Mythic, 
                    Shiny = v76.Shiny, 
                    Amount = v76.Amount
                });
                return;
            elseif v76.Mythic then
                v75.Label.Image = "rbxassetid://74927583442057";
                return;
            elseif v76.Shiny then
                v75.Label.Image = "rbxassetid://73209196936182";
                return;
            elseif v76.Rarity then
                v75.Label.Image = v20[v76.Rarity];
                return;
            end;
        elseif v76.Type == "Purchase" then
            if v76.Purchased.Type == "Gum" then
                v75.Label.Image = v9[v76.Purchased.Name].Image;
                return;
            elseif v76.Purchased.Type == "Flavor" then
                v75.Label.Image = v6[v76.Purchased.Name].Image;
                return;
            end;
        elseif v76.Type == "Sell" then
            v75.Label.Image = v12.Coins.Image;
            return;
        elseif v76.Type == "AreaUnlock" then
            v75.Label.Image = "rbxassetid://115711155808064";
            return;
        elseif v76.Type == "Playtime" then
            v75.Label.Image = "rbxassetid://84730759262323";
            return;
        else
            v75.Label.Image = v5.UnknownImage;
        end;
        return;
    end;
end;
v13.UpdateIcon = function(_, v78, v79) --[[ Line: 383 ]] --[[ Name: UpdateIcon ]]
    -- upvalues: v5 (copy), v13 (copy)
    if v79.Icon == v5.UnknownImage then
        v13:UpdateTaskIcon(v78, v79.Tasks[1]);
        return;
    else
        v78.Label.Image = v79.Icon;
        return;
    end;
end;
return v13;
ModuleScript: SeasonUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local v1 = require(l_ReplicatedStorage_0.Shared.Data.Seasons);
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v3 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.GetRandomWeightedItem);
local v4 = require(l_ReplicatedStorage_0.Shared.Framework.Classes.Signal);
local _ = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.every);
local v6 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.QuestUtil);
local v7 = require(l_ReplicatedStorage_0.Shared.Data.Builders.QuestBuilder);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Currency);
local v9 = require(l_ReplicatedStorage_0.Shared.Framework.Utilities.Math.Time);
local v10 = require(l_ReplicatedStorage_0.Shared.Data.Pets);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Quests.SeasonChallenges);
local v12 = require(l_ReplicatedStorage_0.Shared.Utils.ApplyMultiplierToPool);
local v13 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.ItemUtil);
local v14 = require(l_ReplicatedStorage_0.Shared.Data.Builders.LootPoolBuilder);
local v15 = {
	ProductId = 3279503200, 
	DailySkip = 3279504268, 
	HourlySkip = 3279504383, 
	UnlockAll = 3279504629, 
	Skips = {
		3279504870, 
		3279504870, 
		3279504870, 
		3279504870, 
		3279504870, 
		3279504870, 
		3279504870
	}, 
	MaxLuck = 15, 
	LuckScale = 0.03, 
	Changed = v4.new()
};
local v16 = nil;
local v17 = Random.new();
local function v22(v18, v19) --[[ Line: 65 ]] --[[ Name: getRandomItem ]]
    -- upvalues: v3 (copy), v13 (copy), v10 (copy)
    local v20 = table.clone(v3(v18, v19));
    if v20.Type == "Pet" then
        local l_v13_Rarity_0 = v13:GetRarity(v20);
        if (l_v13_Rarity_0 == "Legendary" or l_v13_Rarity_0 == "Secret") and v10[v20.Name].Images.Mythic ~= nil and v19:NextNumber() * 100 <= 2 then
            v20.Mythic = true;
        end;
        v20.Shiny = v19:NextNumber() * 100 <= 5;
    end;
    return v20;
end;
v15.GetTimeLeft = function(_, v24) --[[ Line: 81 ]] --[[ Name: GetTimeLeft ]]
    local v25 = DateTime.now();
    return v24.Finish.UnixTimestamp - v25.UnixTimestamp;
end;
v15.GetCurrentSeason = function(_) --[[ Line: 88 ]] --[[ Name: GetCurrentSeason ]]
    -- upvalues: v16 (ref), v15 (copy)
    if not v16 then
        return;
    elseif v15:GetTimeLeft(v16) < 0 then
        return;
    else
        return v16;
    end;
end;
v15.GetLuckMultiplier = function(_, v28) --[[ Line: 100 ]] --[[ Name: GetLuckMultiplier ]]
    -- upvalues: v15 (copy)
    return (math.clamp(1 + v28 * v15.LuckScale, 1, v15.MaxLuck));
end;
v15.NewPlayerSeason = function(_, v30) --[[ Line: 106 ]] --[[ Name: NewPlayerSeason ]]
    -- upvalues: v17 (copy)
    return {
        ID = v30, 
        Points = 20000, 
        Seed = v17:NextInteger(0, 10000000), 
        Level = 0, 
        Premium = false, 
        IsInfinite = false, 
        InfinityLuckLevel = 0, 
        LastCost = 0, 
        LastCostIndex = 0, 
        InfinitySkipsBought = 0, 
        InfinityTiers = {}, 
        Challenges = {
            Hourly = 0, 
            Daily = 0
        }
    };
end;
v15.IsRequirementLevel = function(_, v32, _) --[[ Line: 131 ]] --[[ Name: IsRequirementLevel ]]
    if v32 > 1 and v32 < 4 then
        return false;
    else
        return v32 % 4 == 0;
    end;
end;
local v34 = {
    "Lucky", 
    "Mythic", 
    "Coins", 
    "Speed"
};
local function _(v35) --[[ Line: 140 ]] --[[ Name: isNotValuedItem ]]
    if v35.Type == "Potion" then
        local v36 = false;
        if v35.Level ~= nil then
            v36 = v35.Level < 6;
        end;
        return v36;
    else
        return v35.Type ~= "Pet";
    end;
end;
v15.GetInfiniteSegment = function(_, v39, v40, v41, v42) --[[ Line: 148 ]] --[[ Name: GetInfiniteSegment ]]
    -- upvalues: v15 (copy), v14 (copy), v13 (copy), v12 (copy), v22 (copy), v34 (copy)
    local l_Seed_0 = v39.Season.Seed;
    local l_LastCost_0 = v39.Season.LastCost;
    for v45 = v39.Season.LastCostIndex, v41 do
        local v46 = v42 and Random.new(l_Seed_0 + v45) or Random.new();
        if v15:IsRequirementLevel(v45, v46) then
            l_LastCost_0 = l_LastCost_0 + math.ceil(v46:NextInteger(2000, 2500) / 50) * 50;
        end;
    end;
    local l_v15_LuckMultiplier_0 = v15:GetLuckMultiplier(v41);
    local v48 = v14.new();
    for _, v50 in v40.Pool do
        local l_Item_0 = v50.Item;
        local l_Chance_0 = v50.Chance;
        local l_v13_Rarity_1 = v13:GetRarity(l_Item_0);
        if l_v13_Rarity_1 ~= "Secret" and l_v13_Rarity_1 ~= "Legendary" then
            l_Chance_0 = l_Chance_0 / (1 + l_v15_LuckMultiplier_0 / 100);
        end;
        v48:Add(v50.Chance, l_Item_0);
    end;
    local v58 = v12(v48:Build(), l_v15_LuckMultiplier_0, function(v54) --[[ Line: 176 ]]
        -- upvalues: v13 (ref)
        local l_Item_1 = v54.Item;
        local l_v13_Rarity_2 = v13:GetRarity(l_Item_1);
        if l_Item_1.Type == "Potion" and (l_Item_1.Level or 1) <= 5 then
            return false;
        else
            local v57 = true;
            if l_v13_Rarity_2 ~= "Legendary" then
                v57 = l_v13_Rarity_2 == "Secret";
            end;
            return v57;
        end;
    end);
    local v59 = v42 and Random.new(l_Seed_0 + v41) or Random.new();
    local v60 = table.clone((v22(v58, v59)));
    local v61 = table.clone((v22(v58, v59)));
    for _, v63 in {
        v60, 
        v61
    } do
        if v63.Type == "Potion" and v63.Name ~= "Infinity Elixir" then
            local l_Level_0 = v63.Level;
            if l_Level_0 and l_Level_0 ~= 6 then
                v63.Level = math.min(l_Level_0 + math.clamp(math.ceil(l_v15_LuckMultiplier_0 / 3), 1, 2), 5);
            end;
        end;
    end;
    if l_v15_LuckMultiplier_0 > 4 and v41 % 25 == 0 then
        local l_v60_0 = v60;
        if if l_v60_0.Type == "Potion" then l_v60_0.Level ~= nil and l_v60_0.Level < 6 else l_v60_0.Type ~= "Pet" then
            v60 = {
                Type = "Potion", 
                Name = v34[v59:NextInteger(1, #v34)], 
                Level = 6, 
                Amount = 1
            };
        end;
        l_v60_0 = v61;
        if if l_v60_0.Type == "Potion" then l_v60_0.Level ~= nil and l_v60_0.Level < 6 else l_v60_0.Type ~= "Pet" then
            v61 = {
                Type = "Potion", 
                Name = v34[v59:NextInteger(1, #v34)], 
                Level = 6, 
                Amount = 1
            };
        end;
    end;
    if l_v15_LuckMultiplier_0 > 4 and v41 % 35 == 0 then
        local l_v61_0 = v61;
        if if l_v61_0.Type == "Potion" then l_v61_0.Level ~= nil and l_v61_0.Level < 6 else l_v61_0.Type ~= "Pet" then
            v61 = {
                Type = "Potion", 
                Name = "Infinity Elixir", 
                Amount = 1
            };
        end;
    end;
    return {
        LastTrueCost = l_LastCost_0, 
        Requirement = v15:IsRequirementLevel(v41, v59) and l_LastCost_0 or 0, 
        Rewards = {
            Free = v60, 
            Premium = v61
        }
    };
end;
v15.UpdateInfinityTrack = function(_, v68) --[[ Line: 225 ]] --[[ Name: UpdateInfinityTrack ]]
    -- upvalues: v15 (copy)
    local l_v15_CurrentSeason_0 = v15:GetCurrentSeason();
    if not l_v15_CurrentSeason_0 then
        return;
    elseif not v68.Season.IsInfinite then
        return;
    else
        local l_Level_1 = v68.Season.Level;
        local v71 = v68.Season.InfinityTiers or {};
        for v72 = #v71, 1, -1 do
            if v71[v72].Tier < l_Level_1 then
                table.remove(v71, v72);
            end;
        end;
        for v73 = v68.Season.Level, v68.Season.Level + 7 do
            local v74 = false;
            for _, v76 in v71 do
                if v76.Tier == v73 then
                    v74 = true;
                    break;
                end;
            end;
            if not v74 then
                local l_v15_InfiniteSegment_0 = v15:GetInfiniteSegment(v68, l_v15_CurrentSeason_0, v73, v68.FixedInfinityRewards == nil);
                table.insert(v71, {
                    Tier = v73, 
                    Free = l_v15_InfiniteSegment_0.Rewards.Free, 
                    Premium = l_v15_InfiniteSegment_0.Rewards.Premium
                });
            end;
        end;
        v68.Season.InfinityTiers = v71;
        return;
    end;
end;
v15.GetInfinityRewards = function(_, v79, v80) --[[ Line: 262 ]] --[[ Name: GetInfinityRewards ]]
    -- upvalues: v15 (copy)
    local l_v15_CurrentSeason_1 = v15:GetCurrentSeason();
    if not l_v15_CurrentSeason_1 then
        return {
            Free = {
                Type = "Currency", 
                Currency = "Coins", 
                Amount = 100
            }, 
            Premium = {
                Type = "Currency", 
                Currency = "Coins", 
                Amount = 100
            }
        };
    else
        local v82 = v79.Season.InfinityTiers or {};
        for _, v84 in v82 do
            if v84.Tier == v80 then
                return {
                    Free = v84.Free, 
                    Premium = v84.Premium
                };
            end;
        end;
        local l_v15_InfiniteSegment_1 = v15:GetInfiniteSegment(v79, l_v15_CurrentSeason_1, v80, true);
        return {
            Free = l_v15_InfiniteSegment_1.Rewards.Free, 
            Premium = l_v15_InfiniteSegment_1.Rewards.Premium
        };
    end;
end;
v15.GetSkipProduct = function(_, v87, v88) --[[ Line: 290 ]] --[[ Name: GetSkipProduct ]]
    -- upvalues: v15 (copy)
    local l_v15_CurrentSeason_2 = v15:GetCurrentSeason();
    if not l_v15_CurrentSeason_2 then
        return;
    else
        local l_Skips_0 = v15.Skips;
        local v91 = v87.Season.Level + (v88 or 0);
        if v87.Season.IsInfinite then
            return l_Skips_0[math.clamp(math.floor((v87.Season.InfinitySkipsBought or 0) / 5) + 1, 1, #l_Skips_0)];
        else
            local v92 = #l_v15_CurrentSeason_2.Track;
            local v93 = #l_Skips_0 - 3;
            return l_Skips_0[math.clamp(math.floor(v91 / v92 * v93) + 1, 1, v93)];
        end;
    end;
end;
v15.RefreshSeason = function(_, v95) --[[ Line: 315 ]] --[[ Name: RefreshSeason ]]
    -- upvalues: v15 (copy)
    local l_v15_CurrentSeason_3 = v15:GetCurrentSeason();
    if not l_v15_CurrentSeason_3 then
        return;
    elseif v95.Season.ID == l_v15_CurrentSeason_3.ID then
        return;
    else
        v95.Season = v15:NewPlayerSeason(l_v15_CurrentSeason_3.ID or 0);
        v95.Season.Points = v15:GetRequirement(l_v15_CurrentSeason_3, 1);
        return;
    end;
end;
v15.GetRequirement = function(_, v98, v99) --[[ Line: 333 ]] --[[ Name: GetRequirement ]]
    return math.round((v99 / #v98.Track) ^ 2 * 20000 / 50) * 50;
end;
v15.GetRandomChallenges = function(_, v101, v102, v103, v104) --[[ Line: 340 ]] --[[ Name: GetRandomChallenges ]]
    -- upvalues: v3 (copy), v6 (copy), v10 (copy)
    local v105 = false;
    if v101.Stats.Bubbles < 250000 then
        v105 = (v101.Stats.Playtime or 0) < 7200;
    end;
    local v106 = v104 or Random.new();
    local v107 = {};
    for _ = 1, v102 do
        local v109 = nil;
        repeat
            local v110 = v3(v103, v106);
            local v111 = false;
            for _, v113 in v107 do
                if v6:CompareTask(v110.Task, v113.Task) then
                    v111 = true;
                    break;
                end;
            end;
            if not v111 and v110.Task.Type == "Hatch" then
                if v110.Task.Name then
                    local v114 = v10[v110.Task.Name];
                    v111 = not v114.Egg or v101.EggsOpened[v114.Egg] == nil or true;
                elseif v110.Task.Egg then
                    v111 = v101.EggsOpened[v110.Task.Egg] == nil;
                end;
            end;
            if not v111 then
                local l_Amount_0 = v110.Task.Amount;
                if v105 and l_Amount_0 then
                    local v116 = 100;
                    if v110.Task.Type == "Hatch" then
                        v116 = 5;
                    end;
                    local v117 = table.clone(v110.Task);
                    v117.Amount = math.ceil(l_Amount_0 / v116);
                    v109 = {
                        Task = v117, 
                        Reward = v110.Reward
                    };
                else
                    v109 = v110;
                end;
            end;
        until v109 ~= nil;
        table.insert(v107, v109);
    end;
    return v107;
end;
v15.RefreshChallenges = function(_, v119, v120) --[[ Line: 407 ]] --[[ Name: RefreshChallenges ]]
    -- upvalues: v9 (copy), v6 (copy), v1 (copy), v15 (copy), v7 (copy)
    local v121 = v9.now();
    local v122 = v120 == "Hourly" and math.floor(v121 / v9.secondsInHour) or math.floor(v121 / v9.secondsInDay);
    if v122 == v119.Season.Challenges[v120] then
        return false;
    else
        local v123 = ("%*-challenge"):format((string.lower(v120)));
        v6:Remove(v119, function(v124) --[[ Line: 418 ]]
            -- upvalues: v123 (copy)
            return string.sub(v124.Id, 1, (string.len(v123))) == v123;
        end);
        local v125 = Random.new(v122);
        local v126 = v120 == "Daily" and v1.Challenges.Daily or v1.Challenges.Hourly;
        for v127, v128 in v15:GetRandomChallenges(v119, 3, v126, v125) do
            local v129 = v7.new((("%*-%*"):format(v123, v127))):Task(v128.Task):Reward({
                Type = "Currency", 
                Currency = "Points", 
                Amount = v128.Reward
            });
            v6:Add(v119, v129:Build());
        end;
        v119.Season.Challenges[v120] = v122;
        return true;
    end;
end;
local v130 = 0;
local function v136() --[[ Line: 441 ]] --[[ Name: update ]]
    -- upvalues: v1 (copy), v130 (ref), v16 (ref), v15 (copy)
    local v131 = nil;
    local v132 = DateTime.now();
    for _, v134 in v1.Seasons do
        if v132.UnixTimestamp >= v134.Start.UnixTimestamp and v132.UnixTimestamp <= v134.Finish.UnixTimestamp then
            v131 = v134;
            break;
        end;
    end;
    local v135 = v131 and v131.ID or 0;
    if v130 ~= v135 then
        v130 = v135;
        v16 = v131;
        v15.Changed:Fire(v16);
    end;
end;
task.defer(function() --[[ Line: 463 ]]
    -- upvalues: v136 (copy)
    while true do
        v136();
        task.wait(20);
    end;
end);
return v15;
ModuleScript: StatsUtil
-- Saved by UniversalSynSaveInstance (Join to Copy Games) https://discord.gg/wx4ThpAsmw

local l_ReplicatedStorage_0 = game:GetService("ReplicatedStorage");
local l_HttpService_0 = game:GetService("HttpService");
local _ = require(l_ReplicatedStorage_0.Shared.Types);
local v3 = require(l_ReplicatedStorage_0.Shared.Data.Flavors);
local v4 = require(l_ReplicatedStorage_0.Shared.Data.Gum);
local v5 = require(l_ReplicatedStorage_0.Shared.Constants);
local v6 = require(l_ReplicatedStorage_0.Shared.Data.PermanentBuffs);
local v7 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.PetUtil);
local v8 = require(l_ReplicatedStorage_0.Shared.Utils.Stats.BuffUtil);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Buffs);
local v10 = require(l_ReplicatedStorage_0.Shared.GlobalEvent);
local v11 = require(l_ReplicatedStorage_0.Shared.Utils.IndexUtil);
local _ = require(l_ReplicatedStorage_0.Shared.Data.Gamepasses);
local v13 = require(l_ReplicatedStorage_0.Shared.Utils.GetFriendCountInServer);
local v14 = require(l_ReplicatedStorage_0.Shared.Data.Worlds);
local v15 = require(l_ReplicatedStorage_0.Shared.Data.Enchants);
local v16 = require(l_ReplicatedStorage_0.Shared.Data.Currency);
local v17 = {};
local function v26(v18) --[[ Line: 26 ]] --[[ Name: getEquippedPets ]]
    local v19 = {};
    local v20 = {};
    for _, v22 in v18.Pets do
        v20[v22.Id] = v22;
    end;
    for _, v24 in v18.Teams[v18.TeamEquipped].Pets do
        local v25 = v20[v24];
        if v25 then
            table.insert(v19, v25);
        end;
    end;
    return v19;
end;
v17.GetBubblePower = function(_, v28) --[[ Line: 47 ]] --[[ Name: GetBubblePower ]]
    -- upvalues: v3 (copy), v26 (copy), v7 (copy), v8 (copy)
    local l_Bubbles_0 = v3[v28.Bubble.Flavor].Bubbles;
    for _, v31 in v26(v28) do
        l_Bubbles_0 = l_Bubbles_0 + (v7:GetStats(v31, v28).Bubbles or 0);
    end;
    v8:UseBuffs(v28, "Infinity", function() --[[ Line: 55 ]]
        -- upvalues: l_Bubbles_0 (ref)
        l_Bubbles_0 = l_Bubbles_0 * 2;
	end);
	v8:UseBuffs(v28, "Aura", function() --[[ Line: 55 ]]
		-- upvalues: l_Bubbles_0 (ref)
		l_Bubbles_0 = l_Bubbles_0 * 5;
	end);
	if v28.Passes["Double Bubble"] then
		l_Bubbles_0 = l_Bubbles_0 * 2;
	end;
    return l_Bubbles_0;
end;
v17.GetFriendshipLuck = function(_, v33, v34) --[[ Line: 64 ]] --[[ Name: GetFriendshipLuck ]]
    -- upvalues: v13 (copy)
    local v35 = 1;
    local v36 = 0;
    for _, v38 in v34.MasteryUpgrades do
        if v38.Type == "Friendship" then
            v36 = v38.Buff.Value;
            break;
        end;
    end;
    if v36 > 0 then
        v35 = v35 + v13(v33) * v36 / 100;
    end;
    return v35;
end;
v17.GetCurrencyMultiplier = function(_, v40, v41, v42) --[[ Line: 87 ]] --[[ Name: GetCurrencyMultiplier ]]
    -- upvalues: v26 (copy), v7 (copy), v8 (copy), v16 (copy)
    local v43 = 1;
    for _, v45 in v26(v40) do
        local v46 = v7:GetStats(v45, v40)[v41];
        if v46 then
            v43 = v43 + (v46 - 1);
        end;
    end;
    local v47 = 1;
    if v41 == "Gems" and v40.Passes["Double Gems"] then
		v47 = v47 + 1;
    elseif v41 == "Coins" then
        local v48 = 1;
        if v40.Passes.VIP then
            v47 = v47 + 0.15;
        end;
        do
            local l_v48_0 = v48;
            v8:UseBuffs(v40, "Coins", function(v50) --[[ Line: 113 ]]
                -- upvalues: l_v48_0 (ref), v8 (ref)
                l_v48_0 = v8:GetValue(l_v48_0, v50);
            end, v42);
            v43 = v43 * l_v48_0;
        end;
    end;
    local v51 = v16[v41];
    if v51 and v51.CanBeMultiplied then
        if v40.Passes["Double Currency"] and v41 ~= "Gems" then
            v47 = v47 + 2;
		end;
		if v40.Passes["Triple Currency"] and v41 ~= "Gems" then
			v47 = v47 + 6;
		end;
        v8:UseBuffs(v40, "Infinity", function() --[[ Line: 125 ]]
            -- upvalues: v47 (ref)
            v47 = v47 + 1;
		end);
		v8:UseBuffs(v40, "Aura", function() --[[ Line: 125 ]]
			-- upvalues: v47 (ref)
			v47 = v47 + 4;
		end);
    end;
    return (math.ceil(v43 * v47));
end;
v17.GetBubbleStorage = function(_, v53) --[[ Line: 136 ]] --[[ Name: GetBubbleStorage ]]
    -- upvalues: v4 (copy)
    local l_Storage_0 = v4[v53.Bubble.Gum].Storage;
    if v53.OGData.Passes and table.find(v53.OGData.Passes, "Infinite Size") then
        l_Storage_0 = l_Storage_0 * 2;
    end;
    return l_Storage_0;
end;
v17.GetMaxPetTeams = function(_, v56) --[[ Line: 145 ]] --[[ Name: GetMaxPetTeams ]]
    -- upvalues: v5 (copy), v8 (copy)
    local l_BasePetTeams_0 = v5.BasePetTeams;
    for _, v59 in v56.MasteryUpgrades do
        if v59.Type == "Team" then
            return (v8:GetValue(l_BasePetTeams_0, v59.Buff));
        end;
    end;
    return l_BasePetTeams_0;
end;
v17.FixupPetTeamsData = function(_, v61) --[[ Line: 160 ]] --[[ Name: FixupPetTeamsData ]]
    -- upvalues: v17 (copy)
    local l_v17_MaxPetTeams_0 = v17:GetMaxPetTeams(v61);
    local v63 = #v61.Teams;
    for v64 = v63 + 1, l_v17_MaxPetTeams_0 do
        v61.Teams[v64] = {
            Pets = {}
        };
    end;
    return v63 < l_v17_MaxPetTeams_0;
end;
v17.GetMaxPetsEquipped = function(_, v66) --[[ Line: 170 ]] --[[ Name: GetMaxPetsEquipped ]]
    -- upvalues: v5 (copy), v8 (copy), v6 (copy)
    local l_BasePetsEquipped_0 = v5.BasePetsEquipped;
    for _, v69 in v66.MasteryUpgrades do
        if v69.Type == "Equips" then
            l_BasePetsEquipped_0 = v8:GetValue(l_BasePetsEquipped_0, v69.Buff);
            break;
        end;
    end;
    local v70 = v66.PermanentBuffs["Pet Equips"];
    if v70 then
        l_BasePetsEquipped_0 = v8:GetValue(l_BasePetsEquipped_0, v6["Pet Equips"].Buff, v70);
    end;
    if v66.Passes["Extra Equips"] then
        l_BasePetsEquipped_0 = l_BasePetsEquipped_0 + 3;
	end;
	if v66.Passes["Ultra Equips"] then
		l_BasePetsEquipped_0 = l_BasePetsEquipped_0 + 8;
	end;
    return (math.clamp(l_BasePetsEquipped_0, 1, 30));
end;
v17.GetPotionCraftLevel = function(_, v72) --[[ Line: 193 ]] --[[ Name: GetPotionCraftLevel ]]
    -- upvalues: v5 (copy)
    local l_PotionDefaultCraftLevel_0 = v5.PotionDefaultCraftLevel;
    for _, v75 in v72.MasteryUpgrades do
        if v75.Type == "PotionCrafting" then
            return (math.max(v75.Level, l_PotionDefaultCraftLevel_0));
        end;
    end;
    return l_PotionDefaultCraftLevel_0;
end;
v17.HasDigitalStorage = function(_, v77) --[[ Line: 207 ]] --[[ Name: HasDigitalStorage ]]
    -- upvalues: v5 (copy)
    return v77.Passes[v5.DigitalStoragePassName] == true;
end;
v17.GetMaxPetStorage = function(_, v79) --[[ Line: 213 ]] --[[ Name: GetMaxPetStorage ]]
    -- upvalues: v17 (copy), v5 (copy), v8 (copy), v6 (copy)
    if v17:HasDigitalStorage(v79) then
        return 1000000;
    else
        local l_BasePetStorage_0 = v5.BasePetStorage;
        local v81 = v79.PermanentBuffs["More Storage"];
        if v81 then
            l_BasePetStorage_0 = v8:GetValue(l_BasePetStorage_0, v6["More Storage"].Buff, v81);
        end;
        for _, v83 in v79.MasteryUpgrades do
            if v83.Type == "Storage" then
                l_BasePetStorage_0 = v8:GetValue(l_BasePetStorage_0, v83.Buff);
                break;
            end;
        end;
        return (math.clamp(l_BasePetStorage_0, 0, 3000));
    end;
end;
v17.GetUsedPetStorage = function(_, v85) --[[ Line: 235 ]] --[[ Name: GetUsedPetStorage ]]
    -- upvalues: v17 (copy), l_HttpService_0 (copy)
    if v17:HasDigitalStorage(v85) then
        return #l_HttpService_0:JSONEncode(v85.Pets);
    else
        local v86 = 0;
        for _, v88 in v85.Pets do
            v86 = v86 + (v88.Amount or 1);
        end;
        return v86;
    end;
end;
v17.IsInventoryFull = function(_, v90) --[[ Line: 249 ]] --[[ Name: IsInventoryFull ]]
    -- upvalues: v17 (copy)
    return v17:GetUsedPetStorage(v90) >= v17:GetMaxPetStorage(v90);
end;
v17.HasSpaceToTrade = function(_, v92) --[[ Line: 256 ]] --[[ Name: HasSpaceToTrade ]]
    -- upvalues: v17 (copy)
    return not v17:IsInventoryFull(v92);
end;
v17.GetPetXPMultiplier = function(_, v94) --[[ Line: 267 ]] --[[ Name: GetPetXPMultiplier ]]
    -- upvalues: v8 (copy)
    local v95 = 1;
    for _, v97 in v94.MasteryUpgrades do
        if v97.Type == "PetXP" then
            v95 = v8:GetValue(v95, v97.Buff);
        end;
    end;
    v8:UseBuffs(v94, "Infinity", function() --[[ Line: 276 ]]
        -- upvalues: v95 (ref)
        v95 = v95 * 2;
	end);
	v8:UseBuffs(v94, "Aura", function() --[[ Line: 276 ]]
		-- upvalues: v95 (ref)
		v95 = v95 * 5;
	end);
    return 1;
end;
v17.GetShinyChance = function(_, v99, v100, _) --[[ Line: 285 ]] --[[ Name: GetShinyChance ]]
    -- upvalues: v11 (copy), v8 (copy), v5 (copy)
    local v102 = 1;
    if v11:IsFinished(v99, v100) then
        v102 = v8:GetValue(v102, v5.IndexBuffs.Shiny);
    end;
    v8:UseBuffs(v99, "Infinity", function() --[[ Line: 296 ]]
        -- upvalues: v102 (ref)
        v102 = v102 * 2;
	end);
	v8:UseBuffs(v99, "Aura", function() --[[ Line: 296 ]]
		-- upvalues: v102 (ref)
		v102 = v102 * 3;
	end);
    return v5.ShinyChance * v102;
end;
v17.GetMythicChance = function(_, v104, v105, v106) --[[ Line: 305 ]] --[[ Name: GetMythicChance ]]
    -- upvalues: v11 (copy), v8 (copy), v5 (copy)
	local v107 = 1;
	local v108 = 5;
    if v11:IsShinyFinished(v104, v105) then
        v107 = v8:GetValue(v107, v5.IndexBuffs.Mythic);
    end;
    v8:UseBuffs(v104, "Mythic", function(v108) --[[ Line: 312 ]]
        -- upvalues: v107 (ref), v8 (ref)
        v107 = v8:GetValue(v107, v108);
    end, v106);
    v8:UseBuffs(v104, "Infinity", function() --[[ Line: 316 ]]
        -- upvalues: v107 (ref)
        v107 = v107 * 2;
	end);
	v8:UseBuffs(v104, "Aura", function() --[[ Line: 316 ]]
		-- upvalues: v107 (ref)
		v107 = v107 / v108;
	end);
	v8:UseBuffs(v104, "Secret", function() --[[ Line: 316 ]]
		-- upvalues: v107 (ref)
		v107 = v107 / v108;
	end);
    return v5.MythicChance * v107;
end;
v17.GetHatchSpeed = function(_, v110, v111) --[[ Line: 326 ]] --[[ Name: GetHatchSpeed ]]
    -- upvalues: v8 (copy), v10 (copy)
    local v112 = 1;
    for _, v114 in v110.MasteryUpgrades do
        if v114.Type == "HatchSpeed" then
            v112 = v8:GetValue(v112, v114.Buff);
            break;
        end;
    end;
    v8:UseBuffs(v110, "HatchSpeed", function(v115) --[[ Line: 336 ]]
        -- upvalues: v112 (ref), v8 (ref)
        v112 = v8:GetValue(v112, v115);
    end, v111);
    v8:UseBuffs(v110, "Infinity", function() --[[ Line: 340 ]]
        -- upvalues: v112 (ref)
        v112 = v112 * 2;
	end);
	v8:UseBuffs(v110, "Aura", function() --[[ Line: 340 ]]
		-- upvalues: v112 (ref)
		v112 = v112 * 5;
	end);
    if v10:IsActive("Hatching") then
        v112 = v112 + 5;
    end;
    if v110.Passes["Fast Hatch"] then
        v112 = v112 + 0.5;
    end;
    return v112;
end;
v17.GetHatchDuration = function(_, v117, v118) --[[ Line: 356 ]] --[[ Name: GetHatchDuration ]]
    -- upvalues: v17 (copy)
    return 4.5 / v17:GetHatchSpeed(v117, v118);
end;
v17.GetCurrencyCap = function(_, v120) --[[ Line: 364 ]] --[[ Name: GetCurrencyCap ]]
    -- upvalues: v14 (copy)
    local v121 = "The Overworld";
    local v122 = 1;
    for v123 in v120.WorldsUnlocked do
        local v124 = v14[v123];
        if v122 < v124.Order then
            v121 = v123;
            v122 = v124.Order;
        end;
    end;
    return v14[v121].CurrencyCap;
end;
v17.GetLuckMultiplier = function(_, v126, v127, v128, v129, v130) --[[ Line: 383 ]] --[[ Name: GetLuckMultiplier ]]
    -- upvalues: v11 (copy), v8 (copy), v5 (copy), v15 (copy), v10 (copy), v17 (copy)
    local v131 = false;
    local v132 = 1;
    if v11:IsFinished(v127, v128) then
        v132 = v8:GetValue(v132, v5.IndexBuffs.Luck);
    end;
    for _, v134 in v127.MasteryUpgrades do
        if v134.Type == "LuckyEgg" then
            v132 = v8:GetValue(v132, v134.Buff);
            break;
        end;
    end;
    v8:UseBuffs(v127, "Lucky", function(v135) --[[ Line: 403 ]]
        -- upvalues: v132 (ref), v8 (ref)
        v132 = v8:GetValue(v132, v135);
    end, v129);
    for _, v137 in v127.Teams[v127.TeamEquipped].Pets do
        for _, v139 in v127.Pets do
            if v139.Id == v137 then
                if v139.Enchants then
                    for _, v141 in v139.Enchants do
                        if v141.Id == "high-roller" then
                            v132 = v8:GetValue(v132, v15["high-roller"].Buffs[1]);
                            v131 = true;
                        end;
                        if v131 then
                            break;
                        end;
                    end;
                    if not v131 then
                        break;
                    end;
                else
                    break;
                end;
            end;
            if v131 then
                break;
            end;
        end;
        v131 = false;
    end;
    local v142 = 0;
    v8:UseBuffs(v127, "Infinity", function() --[[ Line: 425 ]]
        -- upvalues: v142 (ref)
        v142 = v142 + 2;
	end);
	v8:UseBuffs(v127, "Aura", function() --[[ Line: 425 ]]
		-- upvalues: v142 (ref)
		v142 = v142 + 3000;
	end);
	v8:UseBuffs(v127, "Secret", function() --[[ Line: 425 ]]
		-- upvalues: v142 (ref)
		v142 = v142 * 2;
	end);
    if v127.Passes["Double Luck"] then
        v142 = v142 + 20;
	end;
	if v127.Passes["Blaze Luck"] then
		v142 = v142 + 1200;
	end;	
	if v127.Passes["Omega Luck"] then
		v142 = v142 + 4000;
	end;
    if v10:IsActive("Lucky") then
		v142 = v142 + 1000; -- 450
	end;
    if v142 > 1 then
        v132 = v132 * v142;
    end;
    local v143 = v130 or 0;
    v132 = v132 + v143;
    v143 = v17:GetFriendshipLuck(v126, v127);
    if v143 > 1 then
        v132 = v132 + (v143 - 1);
    end;
    return v132;
end;
v17.GetMaxEggHatches = function(_, v145) --[[ Line: 451 ]] --[[ Name: GetMaxEggHatches ]]
    -- upvalues: v8 (copy), v6 (copy)
	local v146 = 1;
	v8:UseBuffs(v145, "Egg", function() --[[ Line: 425 ]]
		-- upvalues: v142 (ref)
		v146 = v146 + 1;
	end);
    local v147 = v145.PermanentBuffs["Extra Hatch"];
    if v147 then
        v146 = v8:GetValue(v146, v6["Extra Hatch"].Buff, v147);
    end;
    for _, v149 in v145.MasteryUpgrades do
        if v149.Type == "MultiEgg" then
            v146 = v8:GetValue(v146, v149.Buff);
            break;
        end;
    end;
    if v145.Passes["Triple Hatch"] then
        v146 = v146 + 2;
	end;
	if v145.Passes["x10 Hatch"] then
		v146 = v146 + 10;
	end;
	if v145.Passes["x25 Hatch"] then
		v146 = v146 + 25;
	end;
	if v145.Passes["x50 Hatch"] then
		v146 = v146 + 50;
	end;
	if v10:IsActive("Hatching") then
		v146 = v146 + 3;
	end;
    return (math.clamp(v146, 1, 110));
end;
v17.GetPickupRange = function(_, v151) --[[ Line: 475 ]] --[[ Name: GetPickupRange ]]
    -- upvalues: v5 (copy), v8 (copy), v15 (copy), v26 (copy)
    local l_DefaultPickupRadius_0 = v5.DefaultPickupRadius;
    local v153 = 1;
    for _, v155 in v151.MasteryUpgrades do
        if v155.Type == "Magnet" then
            v153 = v8:GetValue(v153, v155.Buff);
            break;
        end;
    end;
    local v156 = v15.magnetism.Buffs[1];
    for _, v158 in v26(v151) do
        if v158.Enchants then
            for _, v160 in v158.Enchants do
                if v160.Id == "magnetism" then
                    v153 = v8:GetValue(v153, v156);
                    break;
                else
                    break;
                end;
            end;
        end;
    end;
    l_DefaultPickupRadius_0 = l_DefaultPickupRadius_0 * v153;
    v8:UseBuffs(v151, "Infinity", function() --[[ Line: 508 ]]
        -- upvalues: l_DefaultPickupRadius_0 (ref)
        l_DefaultPickupRadius_0 = l_DefaultPickupRadius_0 * 2;
    end);
    return l_DefaultPickupRadius_0;
end;
v17.GetWalkspeed = function(_, v162) --[[ Line: 517 ]] --[[ Name: GetWalkspeed ]]
    -- upvalues: v8 (copy)
    local v163 = 32;
    for _, v165 in v162.MasteryUpgrades do
        if v165.Type == "Walkspeed" then
            return (v8:GetValue(v163, v165.Buff));
        end;
    end;
    return v163;
end;
return v17;
ServerScript: ForceLoadFrameWork
for _, service in pairs(game.ServerScriptService.Server:GetDescendants()) do
	if service:IsA("ModuleScript") then
		task.spawn(function()
			require(service)
		end)
		
	end
end

for _, module in pairs(game.ReplicatedStorage.Shared:GetChildren()) do
	if module:IsA("ModuleScript") then
		task.spawn(function()
			require(module)
		end)
	end
end

for _, module in pairs(game.ReplicatedStorage.Shared.Framework:GetDescendants()) do
	if module:IsA("ModuleScript") then
		task.spawn(function()
			require(module)
		end)
	end
end
ModuleScript: chanceLog
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local Constants = require(game.ReplicatedStorage.Shared.Constants)

local module = {}


DataService.DataReady:Connect(function(player)
	local data = DataService:GetData(player)
	if not data.LastUpdate then
		data.LastUpdate = {
			Id = Constants.Update,
			ShouldDisplay = true
		}
	else
		if data.LastUpdate.Id ~= Constants.Update then
			data.LastUpdate.Id = Constants.Update
			data.LastUpdate.ShouldDisplay = true
		end
	end
	
	if data.LastUpdate.ShouldDisplay == true then
		data.LastUpdate.ShouldDisplay = false
	end
end)

return module
ModuleScript: Worlds
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local Stages = game:GetService("ServerStorage"):WaitForChild("Stages")

local module = {}

DataService.DataReady:Connect(function(player)
	player:SetAttribute("World", "The Overworld")
end)

return module
ModuleScript: Stages
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local Stages = game:GetService("ServerStorage"):WaitForChild("Stages")

local Stages = {
	[CFrame.new(2.68405986, 106.187721, 88.2263489, -0.20603776, 0, 0.978543997, 0, 1, 0, -0.978543997, 0, -0.20603776)] = "Zen"
}

local module = {}



return module

ModuleScript: Rifts
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Rifts = require(game.ReplicatedStorage.Shared.Data.Rifts)
local Worlds = require(game.ReplicatedStorage.Shared.Data.Worlds)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local Mastery = require(game.ReplicatedStorage.Shared.Data.Mastery)
local MasteryUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.MasteryUtil)
local CompareTable = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.CompareTable)
local riftSpawnRadius = {
	107.5,
	115,
	125,
	150
}
local riftSpawnMiddle = game.Workspace.Worlds["The Overworld"].Output

local specificMaxRifts = {
	["golden-chest"] = 1,
	["royal-chest"] = 1,
	["gift-rift"] = 1
}

local playersClaimedGiftRift = {}
local module = {}

function module:SpawnRift(riftName, position)
	local newRiftData = Rifts[riftName]
	if not newRiftData then return end
	
	local realRiftName = "Egg1"
	if newRiftData.Type == "Egg" and riftName ~= "man-egg" and not string.find(riftName, "event") then
		realRiftName = "Egg1"
	elseif newRiftData.Type == "Egg" and string.find(riftName, "event") then
		realRiftName = "event-egg-1"
	else
		realRiftName = riftName
	end
	
	local newRift = game.ReplicatedStorage.Assets.Rifts:FindFirstChild(realRiftName):Clone()
	local newRiftType = newRiftData.Type
	
	newRift:SetAttribute("DespawnAt", workspace:GetServerTimeNow() + 600)
	newRift:SetAttribute("Type",newRiftType)
	newRift.Name = riftName
	newRift:PivotTo(position)
	
	if newRiftType == "Egg" and riftName ~= "man-egg" then
		newRift.Template.Name = newRiftData.Egg
	elseif riftName == "man-egg" then
		newRift.Egg.Name = newRiftData.Egg
	elseif newRiftType == "Chest" then
		local newRiftChest = game.ReplicatedStorage.Assets.RiftChest:Clone()
		newRiftChest.Parent = newRift.Chest.Inner
	end
	
	newRift.Parent = game.Workspace.Rendered.Rifts
	
	task.delay(600, function()
		module:DespawnRift(newRift)
	end)
end

function module:DespawnRift(rift)
	if rift.Name == "gift-rift" then
		playersClaimedGiftRift = {}
	end
	rift:Destroy()
end

function module:FromToHeight(areaName)
	local to = workspace.Worlds["The Overworld"].Islands:FindFirstChild(areaName):GetAttribute("Height")
	local from = 0
	for _, island in pairs(game.Workspace.Worlds["The Overworld"].Islands:GetChildren()) do
		if island.Name == areaName then
			from = island:GetAttribute("Height")
		end
	end
	for worldName, world in pairs(Worlds) do
		for islandIndex, islandData in pairs(world.Islands) do
			if islandData.Name == areaName then
				if islandIndex ~= 1 then
					local newIndex = islandIndex-1
					from = workspace.Worlds:FindFirstChild(worldName).Islands:FindFirstChild(world.Islands[newIndex].Name):GetAttribute("Height")
				end
			end
		end
	end
	
	return from, to
end


function module:RandomArea(areas)
	local randomIndex = math.random(1, #areas)
	local selected = areas[randomIndex]
	return selected
end

local function getLootPool()
	local newLoot = {}
	for riftName, rift in pairs(Rifts) do
		table.insert(newLoot, {
			Item = rift,
			Chance = rift.Weight
		})
	end
	return newLoot
end

function module:SpawnRandomRift()
	local randomRift = GetRandomWeightedItem(getLootPool())
	local riftName = "common-egg"
	for opRiftName, opRiftData in pairs(Rifts) do
		if CompareTable(opRiftData, randomRift) then
			riftName = opRiftName
		end
	end
	if specificMaxRifts[riftName] and module:riftsSpawned(riftName) >= specificMaxRifts[riftName] then return end
	local randomArea = module:RandomArea(randomRift.Areas)
	local fromHeight, toHeight = module:FromToHeight(randomArea)

	local height = math.random(fromHeight * 1000, toHeight * 1000) / 1000

	local radius = riftSpawnRadius[math.random(1, #riftSpawnRadius)]
	local angle = math.random() * 2 * math.pi
	local offsetX = math.cos(angle) * radius
	local offsetZ = math.sin(angle) * radius
	local middle = riftSpawnMiddle.Position

	local finalPosition = CFrame.new(middle.X + offsetX, height, middle.Z + offsetZ)
	module:SpawnRift(riftName, finalPosition)
end

function module:GetSpawnedRifts()
	local amount = #workspace.Rendered.Rifts:GetChildren()
	return amount
end

function module:riftsSpawned(riftName)
	local amount = 0
	for _, rift in pairs(workspace.Rendered.Rifts:GetChildren()) do
		if rift.Name == riftName then
			amount += 1
		end
	end
	return amount
end

function module:getRiftModel(riftName)
	return workspace.Rendered.Rifts:FindFirstChild(riftName)
end


task.spawn(function()
	while true do
		local spawnedRifts = module:GetSpawnedRifts()
		if spawnedRifts < 9 then
			module:SpawnRandomRift()
		end
		task.wait()
	end
end)

game.Players.PlayerAdded:Connect(function(player)
	player.Chatted:Connect(function(message)
		if module:riftsSpawned("man-egg") == 0 then
			if message:lower() == "man-egg" then
				local manEgg = game.ReplicatedStorage.Assets.Rifts["man-egg"]:Clone()
				manEgg:SetAttribute("Type", "Egg")
				manEgg:SetAttribute("DespawnAt", workspace:GetServerTimeNow() + 600)
				manEgg.Display.SurfaceGui.Icon.Luck.Text = "25x"
				manEgg:PivotTo(CFrame.new(-117.929153, 12623.7451, 177.913116, -0.802487612, 0, -0.596669436, 0, 1, 0, 0.596669436, 0, -0.802487612))
				manEgg.Egg:SetAttribute("BonusLuck", 10)
				manEgg.Egg.Name = "Aura Egg"
				manEgg.Parent = workspace.Rendered.Rifts
			end
		end
	end)
end)

Remote.Event("UnlockRiftChest"):Connect(function(player, ...)
	local args = {...}
	local riftChestName = args[2]
	local isSingleOpen = args[3]

	local save = DataService:GetData(player)
	if not save then return end
	save.MasteryUpgrades = MasteryUtil:GetUpgrades(save)

	local hasMultiChestMastery = save.MasteryUpgrades["MultiChest"] or false

	if module:riftsSpawned(riftChestName) < 1 then return end
	local riftData = Rifts[riftChestName]
	if not riftData.Cost or not riftData.Pool then return end
	local randomItem = GetRandomWeightedItem(riftData.Pool)
	local riftModel = module:getRiftModel(riftChestName)
	if not riftModel then return end

	if not ItemUtil:CanAfford(save, riftData.Cost) then return end

	ItemUtil:Deduct(save, riftData.Cost)

	local numChestsToOpen = isSingleOpen and 1 or (hasMultiChestMastery and 3 or 1)

	for i = 1, numChestsToOpen do
		for j = 1, 5 do
			VisualItems.CreateVisualItems(player, riftModel.Chest.Inner.Position + Vector3.new(0, 2.5, 0), {randomItem})
		end
	end
end)


Remote.Event("ClaimRiftGift"):Connect(function(player, riftName)
	if module:riftsSpawned(riftName) < 1 then return end
	local riftData = Rifts[riftName]
	if not riftData then return end
	if riftName ~= "gift-rift" then  return end
	local riftModel = module:getRiftModel(riftName)
	if not riftModel then return end
	if playersClaimedGiftRift[player] then return end

	VisualItems.CreateVisualItems(player, riftModel.Gift.Prompt.Position + Vector3.new(0,2.5,0), riftData.Items)
	playersClaimedGiftRift[player] = true
end)


return module

ModuleScript: Races
--!strict

-- RaceUtil.luau
-- This module makes the Island Race system in the game work!!!!
-- torescpt 
-- credits : _letr0 -- very sigma dude btw :D

local module = {}

local HttpService = game:GetService("HttpService")
local Shared = game:GetService("ReplicatedStorage"):WaitForChild("Shared")
local Server = game:GetService("ServerScriptService"):WaitForChild("Server")
local Utils = Shared:WaitForChild("Utils")

-- Server
local Remotes = require(Shared.Framework.Network.Remote)
local DataService = require(Server.Framework.Services.DataService)
local StatsUtil = require(Utils.Stats.StatsUtil)
local ItemUtil = require(Server.Utils.Stats.ItemUtil)
local RaceUtil = require(Utils.RaceUtil)
local Easter = require(Server.Easter)

export type RaceData = {
	Players: { [string]: boolean },
	StartTime: number,
	Started: boolean
}

--------------------------------------------------------------------------------------

local raceData: RaceData = {
	Players = {},
	StartTime = 0,
	Started = false
}

function module:GetModel()
	return workspace:WaitForChild("Worlds"):FindFirstChild("The Overworld"):WaitForChild("Race")
end

function getPlayerByName(name)
	for _, player in ipairs(game.Players:GetPlayers()) do
		if player.Name == name then
			return player
		end
	end
	return nil
end

function module:GetPlayerCount()
	local count = 0
	for _ in raceData.Players do
		count += 1
	end
	return count
end

function module:StartRace()
	for name in raceData.Players do -- name isnt needed -- nvm changes were remembered
		local player = getPlayerByName(name)
		if not player then
			return
		end

		player:SetAttribute("InRace", true)
	end

	raceData.Started = false
	raceData.StartTime = 0
	raceData.Players = {}	
end

function module:EndRace() -- what else supposed to be in end and start?
	for name in raceData.Players do
		local player = getPlayerByName(name)
		if not player then
			return
		end

		player:SetAttribute("InRace", false)
		Remotes:FireClient(player, "IslandRaceFinish")
	end
end

function module:Complete(player)
	if player:GetAttribute("InRace") == false then -- keep this otherwise everytime player touches island this is gonna run!
		return
	end
	local save = DataService:GetData(player)
	if not save then
		return
	end

	local seed = RaceUtil:GetSeed()	
	local rewards = RaceUtil:GetRewards(seed)

	local items = {}
	for _, v in pairs(rewards) do
		if RaceUtil.RaceTime <= v.Time then
			table.insert(items, v.Item)			
			if not ItemUtil:Add(save, v.Item) then
				return
			end
		end
	end
	
	player:SetAttribute("InRace", false)
	Remotes:FireClient(player, "IslandRaceFinish", "Win")
	Remotes:FireClient(player, "ItemsReceived", items)
	Easter:GiveEgg(player, "Race Egg")

end


function module:TrackSignUp(player: Player)
	local character = player.Character
	if not character then
		return
	end

	local model = module:GetModel()
	if not model then
		return
	end

	for _, part in ipairs(character:GetDescendants()) do
		if part:IsA("BasePart") then -- cuz shirts and shit
			part.Touched:Connect(function(hit)
				if hit:IsDescendantOf(model) then
					raceData.Players[player.Name] = true
				else
					raceData.Players[player.Name] = nil
				end
			end)
		end
	end
end

function module:TrackComplete(player: Player)
	local character = player.Character
	if not character then
		return
	end

	local hrp = character:FindFirstChild("HumanoidRootPart")
	if not hrp or not hrp:IsA("BasePart") then -- gotta add this shit cuz !strict errors :d
		return
	end

	hrp.Touched:Connect(function(hit)
		if hit.Name == "UnlockHitbox" then
			local hitParent_1 = hit.Parent -- hitParent_2 never was made :--idkwhattoaddheresoo
			if hitParent_1 and hitParent_1.Parent then
				local island = hitParent_1.Parent.Name
				if island == "Zen" then
					module:Complete(player)
				end
			end
		end
	end)
end

Remotes.Event("RequestRaceLeave"):Connect(function(player)
	if not player:GetAttribute("InRace") then
		return 
	end

	player:SetAttribute("InRace", false)
end)

DataService.DataReady:Connect(function(player: Player)
	local function update()
		module:TrackSignUp(player)
		module:TrackComplete(player)
	end	

	player.CharacterAdded:Connect(function(ch)
		update()		
	end)

	if player.Character then
		task.spawn(function()
			update()
		end)
	end
	player:SetAttribute("InRace", false)
end)

task.spawn(function()
	while true do
		local phase = RaceUtil:GetPhase()
		assert(phase, "No phase??")

		local serverTimeNow = workspace:GetServerTimeNow()

		if phase.Type == "SignUp" then
			raceData.StartTime = serverTimeNow + phase.Time

			local model = module:GetModel()
			assert(model, "Failed to get model!")

			if model and model:FindFirstChild("Pad") and model.Pad:FindFirstChild("Root") then
				local root = model.Pad.Root
				local gui = root:FindFirstChild("BillboardGui")
				if gui and gui:IsA("BillboardGui") then
					local remaining = math.max(0, math.floor(raceData.StartTime - serverTimeNow))--math.round(raceData.StartTime)
					local secondText = remaining == 1 and "second" or "seconds"

					if gui:FindFirstChild("Description") then
						gui.Description.Text = `Race starts in {remaining} {secondText}`
					end

					if gui:FindFirstChild("Title") then
						gui.Title.Text = `{module:GetPlayerCount()} Player{module:GetPlayerCount() == 1 and "" or "s"}`
					end
					if remaining == 0 then
						module:StartRace()
					end
				end
			end
			
			Remotes:FireAllClients("IslandRaceStart", raceData)
		end
		
		if phase.Type == "Countdown" then			
			if phase.Time <= 1 then
				module:EndRace()
			end
		end

		task.wait(1)
	end
end)


return module
ModuleScript: Quests
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local QuestUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.QuestUtil)
local Questlines = require(game.ReplicatedStorage.Shared.Data.Quests.Questlines)
local InitialQuests = require(game.ReplicatedStorage.Shared.Data.Quests.InitialQuests)
local CompareTable = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.CompareTable)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local module = {}

function module:beginQuestLine(save, questLine)
	local chosenQuestLine = nil
	for _, quest in pairs(Questlines) do
		if quest.Id == questLine then
			chosenQuestLine = quest
		end
	end
	
	QuestUtil:Add(save, chosenQuestLine.Quests[1].Quest)
end

function module:skipQuest(player, questName)
	local save = DataService:GetData(player)
	local questData = QuestUtil:FindById(save, questName)
	if not questData then return end
	if questData.Claimed then return end
	
	for taskId, task in pairs(questData.Tasks) do
		questData.Progress[taskId] = (task.Amount or 1)
	end
	
	if QuestUtil:IsComplete(questData) and not questData.Claimed then
		if not save.QuestsCompleted[questData.Id] then
			save.QuestsCompleted[questData.Id] = 1
		else
			save.QuestsCompleted[questData.Id] += 1
		end

		for _, reward in pairs(DeepCopy(questData.Rewards)) do
			if reward.Type == "Currency" then
				reward.Amount = math.floor(reward.Amount * StatsUtil:GetCurrencyMultiplier(save, reward.Currency, true));
			end;
			ItemUtil:Add(save, reward)
			Remote:FireClient(player, "ItemsReceived", {reward})
		end

		if questData.HUD then
			for _, v in pairs(Questlines) do
				for _, q1 in pairs(v.Quests) do
					if q1.Quest.Id == questData.Id then
						if q1.Next then
							QuestUtil:Add(save, q1.Next)
						end
					end
				end
			end

			QuestUtil:Remove(save, function(q)
				return q.Id == questData.Id
			end)
		else
			questData.Claimed = true
		end
	end
end

function module:progressQuests(player, task)
	local save = DataService:GetData(player)
	local taskType = task.Type
	local taskAmount = task.Amount or 1
	
	for _, quest in pairs(save.Quests) do
		for taskId, taskData in pairs(quest.Tasks) do
			if taskData.Type == taskType then
				if taskType == "Bubbles" then
					if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
						quest.Progress[taskId] = taskData.Amount or 1
					else
						quest.Progress[taskId] += taskAmount
					end
				elseif taskType == "Sell" then
					if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
						quest.Progress[taskId] = taskData.Amount or 1
					else
						quest.Progress[taskId] += taskAmount
					end
				elseif taskType == "Hatch" then
					if not taskData.Egg and not taskData.Rarity then
						if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
							quest.Progress[taskId] = taskData.Amount or 1
						else
							quest.Progress[taskId] += taskAmount
						end
					elseif taskData.Egg and taskData.Rarity and task.Egg and task.Rarity then
						if taskData.Egg == task.Egg and taskData.Rarity == task.Rarity then
							if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
								quest.Progress[taskId] = taskData.Amount or 1
							else
								quest.Progress[taskId] += taskAmount
							end
						end
					elseif taskData.Egg and task.Egg then
						if taskData.Egg == task.Egg then
							if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
								quest.Progress[taskId] = taskData.Amount or 1
							else
								quest.Progress[taskId] += taskAmount
							end
						end
					elseif taskData.Rarity and task.Rarity then
						if taskData.Rarity == task.Rarity then
							if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
								quest.Progress[taskId] = taskData.Amount or 1
							else
								quest.Progress[taskId] += taskAmount
							end
						end
					end
				elseif taskType == "Collect" then
					if taskData.Item.Type == task.Item.Type then
						if quest.Progress[taskId] + (task.Item.Amount or 1) > (taskData.Item.Amount or 1) then
							quest.Progress[taskId] = taskData.Item.Amount or 1
						else
							quest.Progress[taskId] += task.Item.Amount or 1
						end
					end
				elseif taskType == "Purchase" then
					if taskData.Purchased.Type == task.Purchased.Type and taskData.Purchased.Name == task.Purchased.Name then
						if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
							quest.Progress[taskId] = taskData.Amount or 1
						else
							quest.Progress[taskId] += task.Amount or 1
						end
					end
				elseif taskType == "Group" then
					if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
						quest.Progress[taskId] = taskData.Amount or 1
					else
						quest.Progress[taskId] += taskAmount
					end
				elseif taskType == "Invite" then
					if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
						quest.Progress[taskId] = taskData.Amount or 1
					else
						quest.Progress[taskId] += taskAmount
					end
				elseif taskType == "AreaUnlock" then
					if task.Area == taskData.Area then
						quest.Progress[taskId] = taskData.Amount or 1
					end
				elseif taskType == "Playtime" then
					if quest.Progress[taskId] + taskAmount > (taskData.Amount or 1) then
						quest.Progress[taskId] = taskData.Amount or 1
					else
						quest.Progress[taskId] += taskAmount
					end
				else
					warn(taskType)
					warn("Has nothing assigned")
				end
			end
		end
		if QuestUtil:IsComplete(quest) and not quest.Claimed then
			if not save.QuestsCompleted[quest.Id] then
				save.QuestsCompleted[quest.Id] = 1
			else
				save.QuestsCompleted[quest.Id] += 1
			end
			
			for _, reward in pairs(DeepCopy(quest.Rewards)) do
				if reward.Type == "Currency" then
					reward.Amount = math.floor(reward.Amount * StatsUtil:GetCurrencyMultiplier(save, reward.Currency, true));
				end;
				ItemUtil:Add(save, reward)
				Remote:FireClient(player, "ItemsReceived", {reward})
			end
			
			if quest.HUD then
				for _, v in pairs(Questlines) do
					for _, q1 in pairs(v.Quests) do
						if q1.Quest.Id == quest.Id then
							if q1.Next then
								QuestUtil:Add(save, q1.Next)
							end
						end
					end
				end
				
				QuestUtil:Remove(save, function(q)
					return q.Id == quest.Id
				end)
			else
				quest.Claimed = true
			end
		end
	end
end

DataService.DataReady:Connect(function(player)
	local save = DataService:GetData(player)
	if not QuestUtil:FindById(save, "group") and not save.QuestsCompleted["group"] then
		for _, initialQuest in pairs(InitialQuests) do
			QuestUtil:Add(save, initialQuest)
		end
		module:beginQuestLine(save, "tutorial")
	end
	
end)

return module
ModuleScript: Potions
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local Pets = require(game.ServerScriptService.Server.Framework.Services.Pets)
local PetsData = require(game.ReplicatedStorage.Shared.Data.Pets);
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local ShopUtil = require(game.ReplicatedStorage.Shared.Utils.ShopUtil)
local Shops = require(game.ReplicatedStorage.Shared.Data.Shops)
local Time = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.Time);
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil);
local PotionsData = require(game.ReplicatedStorage.Shared.Data.Potions);

local module = {}

Remote.Event("CraftPotion"):Connect(function(player, potionName, potionLevel, craftAll)
	local data = DataService:GetData(player)
	if not data then return false end
	if not PotionsData[potionName] then return end
	
	local CraftingCosts = PotionsData[potionName].CraftingCosts[potionLevel-1]
	if not CraftingCosts then
		return
	end
	
	local oldPotion = {
		Type = "Potion",
		Name = potionName,
		Level = potionLevel - 1
	}

	local newPotion = {
		Type = "Potion",
		Name = potionName,
		Level = potionLevel
	}
	
	local hasAmount = ItemUtil:GetOwnedAmount(data, oldPotion) or 0
	local craftingAmount = 1
	if craftAll then
		craftingAmount = hasAmount
		local v65 = math.min(math.floor(data.Gems / CraftingCosts.Gems), (math.floor(hasAmount / CraftingCosts.Potions)));
		craftingAmount = math.max(v65, 1);
	end
	if CraftingCosts.Potions * craftingAmount > hasAmount then
		return 
	end
	if not ItemUtil:CanAfford(data, {Type = "Currency", Currency = "Gems", Amount = CraftingCosts.Gems*craftingAmount}) then
		return
	end
	
	ItemUtil:Deduct(data, {Type = "Potion", Name = potionName, Level = potionLevel-1, Amount = CraftingCosts.Potions*craftingAmount})
	ItemUtil:Deduct(data, {Type = "Currency", Currency = "Gems", Amount = CraftingCosts.Gems*craftingAmount})
	ItemUtil:Add(data, {Type = "Potion", Name = potionName, Level = potionLevel, Amount = craftingAmount})
	Remote:FireClient(player, "ItemsReceived", {{Type = "Potion", Name = potionName, Level = potionLevel, Amount = craftingAmount}})
end)



return module
ModuleScript: ItemShops
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local Pets = require(game.ServerScriptService.Server.Framework.Services.Pets)
local PetsData = require(game.ReplicatedStorage.Shared.Data.Pets);
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local ShopUtil = require(game.ReplicatedStorage.Shared.Utils.ShopUtil)
local Shops = require(game.ReplicatedStorage.Shared.Data.Shops)
local Time = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.Time);
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil);

local module = {}

local rerollingShops = {}

Remote.Event("BuyShopItem"):Connect(function(player, shopName, itemId)
	local data = DataService:GetData(player)
	if not data then return end
	
	if not Shops[shopName] then return end
	if Shops[shopName].IsTemporary then return end
	if Shops[shopName].Unlocked then
		if not Shops[shopName].Unlocked(data) then
			return
		end
	end
	
	local items = ShopUtil:GetItemsData(shopName, player, data)
	local chosenItem = items[itemId]
	if not chosenItem then return end
	if data.Shops[shopName].Bought[itemId] then
		if data.Shops[shopName].Bought[itemId] >= chosenItem.Stock then
			return
		end
	end
	if not ItemUtil:CanAfford(data, chosenItem.Cost) then
		return
	end
	ItemUtil:Deduct(data, chosenItem.Cost)
	ItemUtil:Add(data, chosenItem.Product)
	Remote:FireClient(player, "ItemsReceived", {chosenItem.Product})
	if not data.Shops[shopName].Bought[itemId] then
		data.Shops[shopName].Bought[itemId] = 1
	else
		data.Shops[shopName].Bought[itemId] += 1
	end
end)

function module:RerollShop(player, shopName, isPaid)
	local data = DataService:GetData(player)
	if not data then return end
	
	if isPaid then
		shopName = rerollingShops[player] or "alien-shop"
	end
	
	local shopData = Shops[shopName]
	if not shopData then return end
	
	data.Shops[shopName].Began = workspace:GetServerTimeNow()
	data.Shops[shopName].Period += 1
	data.Shops[shopName].Bought = {}
end

function module:SetupShops(player)
	local data = DataService:GetData(player)
	if not data then return false end
	for shopName, shopData in pairs(Shops) do
		if not data.Shops[shopName] then
			data.Shops[shopName] = {
				Began = Time.now(),
				Period = 0,
				Bought = {}
			}
		end
	end
	return true
end

Remote.Event("ShopFreeReroll"):Connect(function(player, shopName)
	local data = DataService:GetData(player)
	if not data then return false end
	
	local MaxFreeRolls = ShopUtil:GetMaxFreeRerolls(data)
	local usedRerolls = data.ShopFreeRerolls.Used
	if usedRerolls >= MaxFreeRolls then
		return
	end
	data.ShopFreeRerolls.Used += 1
	
	module:RerollShop(player, shopName)
end)


Remote.Event("SetShopRerollTarget"):Connect(function(player, shopName)
	rerollingShops[player] = shopName
end)

DataService.DataReady:Connect(function(player)
	local setup = module:SetupShops(player)
	while DataService:GetData(player) do
		local data = DataService:GetData(player)
		for shopName, shop in pairs(data.Shops) do
			local shopData = Shops[shopName]
			local rerollDuration = shopData.RerollDuration
			
			local v51 = 1
			for _, v53 in data.MasteryUpgrades do
				if v53.Type == "FasterRestock" then
					v51 = BuffUtil:GetValue(1, v53.Buff);
					break;
				end;
			end;
			
			local actualRerollDuration = math.round(rerollDuration / v51);
			local timeLeft = math.max(0, shop.Began + actualRerollDuration - Time.now());
			if timeLeft == 0 then
				module:RerollShop(player, shopName)
			end
		end
		
		if Time.getAbsoluteDay() ~= data.ShopFreeRerolls.Day then
			data.ShopFreeRerolls.Day = Time.getAbsoluteDay()
			data.ShopFreeRerolls.Used = 0
		end
		task.wait(1)
	end
end)

-- ShopsRestocked



return module
ModuleScript: Group
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local QuestUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.QuestUtil)
local Quests = require(game.ServerScriptService.Server.Quests)

local module = {}

local cooldowns = {}

Remote.Function("VerifyGroup", function(player)
	local save = DataService:GetData(player)
	if not save then 
		return "Failed to get save"
	end
	
	if cooldowns[player] then
		if cooldowns[player] > workspace:GetServerTimeNow() then
			return "Please wait "..math.round(cooldowns[player]-workspace:GetServerTimeNow()).." seconds before trying again"
		end
	end
	
	if not player:IsInGroup(15718813) then
		cooldowns[player] = workspace:GetServerTimeNow() + 10
		return "Join the Blaze Games Roblox Group to earn this reward for FREE!"
	end
	
	local quest = QuestUtil:FindById(save, "group")
	if not quest then
		return "Already complete"
	end
	Quests:progressQuests(player, {Type = "Group", Amount = 1})
	
	return
end)

return module
ModuleScript: Group
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local QuestUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.QuestUtil)
local Quests = require(game.ServerScriptService.Server.Quests)

local module = {}

local cooldowns = {}

Remote.Function("VerifyGroup", function(player)
	local save = DataService:GetData(player)
	if not save then 
		return "Failed to get save"
	end
	
	if cooldowns[player] then
		if cooldowns[player] > workspace:GetServerTimeNow() then
			return "Please wait "..math.round(cooldowns[player]-workspace:GetServerTimeNow()).." seconds before trying again"
		end
	end
	
	if not player:IsInGroup(15718813) then
		cooldowns[player] = workspace:GetServerTimeNow() + 10
		return "Join the Blaze Games Roblox Group to earn this reward for FREE!"
	end
	
	local quest = QuestUtil:FindById(save, "group")
	if not quest then
		return "Already complete"
	end
	Quests:progressQuests(player, {Type = "Group", Amount = 1})
	
	return
end)

return module
ModuleScript: GemGenie

local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local QuestUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.QuestUtil)
local Quests = require(game.ServerScriptService.Server.Quests)
local Time = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.Time);
local DoggyJumpUtil = require(game.ReplicatedStorage.Shared.Utils.DoggyJumpUtil)
local GenieQuest = require(game.ReplicatedStorage.Shared.Data.Quests.GenieQuest)
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local module = {}

Remote.Event("StartGenieQuest"):Connect(function(player, quest)
	assert(typeof(quest) == "number" and quest <= 3 and quest > 0)
	local data = DataService:GetData(player)
	if not data then return end
	
	if QuestUtil:FindById(data, "gem-genie") then
		return
	end
	if data.GemGenie.Next > workspace:GetServerTimeNow() then
		return
	end
	
	local questData = GenieQuest(data, data.GemGenie.Seed + (quest - 1))
	data.GemGenie.Next = workspace:GetServerTimeNow() + Constants.GemGenieCooldown
	QuestUtil:Add(data, questData)
end)

Remote.Event("ChangeGenieQuest"):Connect(function(player)
	local data = DataService:GetData(player)
	if not data then return end
	
	QuestUtil:Remove(data, function(quest)
		return quest.Id == "gem-genie"
	end)
end)

Remote.Event("RerollGenie"):Connect(function(player)
	local data = DataService:GetData(player)
	if not data then return end
	
	if not ItemUtil:CanAfford(data, Constants.GemGenieReroll) then
		return
	end
	ItemUtil:Deduct(data, Constants.GemGenieReroll)
	data.GemGenie.Seed = Random.new():NextInteger(0, 10000000)
end)

DataService.DataReady:Connect(function(player)
	local data = DataService:GetData(player)
	if not data.GemGenie or next(data.GemGenie) == nil then
		data.GemGenie = {
			Next = 0,
			Seed = Random.new():NextInteger(0, 10000000)
		}
	end
end)



return module
ModuleScript: Enchants
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local Pets = require(game.ServerScriptService.Server.Framework.Services.Pets)
local PetsData = require(game.ReplicatedStorage.Shared.Data.Pets);
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local MasteryUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.MasteryUtil)

local module = {}

Remote.Event("RerollEnchant"):Connect(function(player, petUID, enchantSlot)
	local save = DataService:GetData(player)
	if not save then
		return
	end
	local rerollItem = {
		Type = "Powerup", 
		Name = "Reroll Orb", 
		Amount = 1
	} 

	if not ItemUtil:CanAfford(save, rerollItem) then
		return
	end

	local efficientOrbs = MasteryUtil:GetUpgrade(save, "EfficientOrbs")
	local savedOrb = false
	if efficientOrbs then
		local chance = efficientOrbs.Buff.Value
		if math.random(1, 100) <= chance then
			Remote:FireClient(player, "RerollOrbSaved")
			savedOrb = true
		end
	end
	if not savedOrb then
		ItemUtil:Deduct(save, rerollItem)
	end

	local pet
	for _, v in pairs(save.Pets) do
		if v.Id == petUID then
			pet = v
			break
		end
	end
	if not pet then return end
	local amountOfPet = pet.Amount or 1
	if amountOfPet > 1 then
		return
	end
	if not pet.Enchants or next(pet.Enchants) == nil then
		return
	end
	local maxEnchantSlots = EnchantUtil:GetMaxEnchantSlots(pet)
	if enchantSlot > maxEnchantSlots then
		return
	end

	pet.Enchants[enchantSlot] = nil

	local randomEnchant = EnchantUtil:GetUnusedEnchant(save, pet.Enchants, pet.Name)
	local randomLevel = EnchantUtil:GetRandomLevel(randomEnchant)

	pet.Enchants[enchantSlot] = EnchantUtil:MakeEnchant(randomEnchant, randomLevel)

	local discovered = EnchantUtil:UpdateDiscoveredEnchants(save)
	Remote:FireClient(player, "DiscoveredEnchants", discovered)
end)

Remote.Function("RerollEnchants", function(player, petUID)
	local save = DataService:GetData(player)
	local pet
	for _, v in pairs(save.Pets) do
		if v.Id == petUID then
			pet = v
			break
		end
	end

	if not pet then
		return
	end


	local v125 = PetsData[pet.Name];
	local l_Rarity_0 = v125.Rarity;
	if l_Rarity_0 == "Legendary" and (v125.Tier or 1) == 1 then
		l_Rarity_0 = "EasyLegendary";
	end;
	local v135 = {
		Type = "Currency", 
		Currency = "Gems", 
		Amount = Constants.EnchantsRerollAllGemCosts[l_Rarity_0] or 0
	};
	if not ItemUtil:CanAfford(save, v135) then return end
	ItemUtil:Deduct(save, v135)



	local amountOfPet = pet.Amount or 1
	local enchantingPet = nil
	if amountOfPet > 1 then
		Pets.DeletePet(player, petUID, 1)
		local newPet = {
			Id = game:GetService("HttpService"):GenerateGUID(false), 
			Name = pet.Name, 
			Shiny = pet.Shiny == true or nil, 
			Mythic = pet.Mythic == true or nil, 
			XP = 0,
		}
		table.insert(save.Pets, newPet)
		if Pets:IsEquipped(save, petUID) then
			Pets.UnequipPet(player, petUID)
			Pets.EquipPet(player, newPet.Id)
		end

		Remote:FireClient(player, "PetIdChanged", pet.Id, newPet.Id)

		EnchantUtil:FillPetEnchants(save, newPet)

		enchantingPet = newPet
	else
		EnchantUtil:FillPetEnchants(save, pet)
		enchantingPet = pet
	end

	local maxEnchantSlots = EnchantUtil:GetMaxEnchantSlots(enchantingPet)
	enchantingPet.Enchants = {}

	for i=1, maxEnchantSlots do
		local randomEnchant = EnchantUtil:GetUnusedEnchant(save, enchantingPet.Enchants, enchantingPet.Name)
		local randomLevel = EnchantUtil:GetRandomLevel(randomEnchant)
		table.insert(enchantingPet.Enchants, EnchantUtil:MakeEnchant(randomEnchant, randomLevel))
	end

	local discovered = EnchantUtil:UpdateDiscoveredEnchants(save)
	Remote:FireClient(player, "DiscoveredEnchants", discovered)
	return enchantingPet.Id
end)

return module
ModuleScript: Easter
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local EasterLeaderboard = game:GetService("DataStoreService"):GetDataStore("EasterLB2")
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local Titles = require(game.ServerScriptService.Server.Framework.Services.Titles)

local module = {}

function module:GiveEgg(player, egg)
	local data = DataService:GetData(player)
	if not data then return end
	if data.Easter.Found[egg] then return end
	data.Easter.Found[egg] = true
	Remote:FireClient(player, "EasterEggFound", egg)
end

function module:IsTop250(player)
	local userId = player.UserId
	local key = tostring(userId)

	local count = 0

	local success, data = pcall(function()
		return EasterLeaderboard:GetAsync("Top250")
	end)

	if success and data then
		count = data.Count or 0
	else
		data = {Count = 0, Users = {}}
	end

	if count >= 250 then
		return false
	end

	data.Count += 1

	local successSet = pcall(function()
		EasterLeaderboard:SetAsync("Top250", data)
	end)

	if not successSet then
		return false, "Error"
	end

	return true, data.Count
end


Remote.Event("EasterNerdEgg"):Connect(function(player, code)
	if code == "0100000000011111111001000000100101000010010100001011111100100001000010100100001010010000101001000000" then
		module:GiveEgg(player, "Nerd Egg")
	end
end)

Remote.Event("ClaimStickerEgg"):Connect(function(player)
	module:GiveEgg(player, "Sticker Egg")
end)

Remote.Event("EasterBrokenEgg"):Connect(function(player)
	module:GiveEgg(player, "Cracked Egg")
end)

Remote.Event("EasterBouncyEgg"):Connect(function(player)
	module:GiveEgg(player, "Bouncy Egg")
end)

Remote.Event("EasterClaimRewards"):Connect(function(player)
	local data = DataService:GetData(player)
	if not data then return end
	if data.Easter.Claimed == true then return end
	local isTop250, Error = module:IsTop250(player)
	if not isTop250 and Error then return end
	
	if isTop250 then
		for _, item in pairs(Constants.EasterRewards.Top250.Items) do
			ItemUtil:Add(data, item)
			Remote:FireClient(player, "ItemsReceived", {item}, false)
		end
		
		Titles:GiveTitle(player, Constants.EasterRewards.Top250.Title)
		
		data.Easter.FinishPosition = Error
	end
	
	for _, item in pairs(Constants.EasterRewards.Everyone.Items) do
		ItemUtil:Add(data, item)
		Remote:FireClient(player, "ItemsReceived", {item}, false)
	end
	
	data.Easter.Claimed = true

	Titles:GiveTitle(player, Constants.EasterRewards.Everyone.Title)
end)

Remote.Event("EggDanceStart"):Connect(function(player)
	
end)

Remote.Event("EggDanceFinish"):Connect(function(player)
	module:GiveEgg(player, "Disco Egg")
end)

workspace.Rendered["Basic Egg"].Hitbox.Touched:Connect(function(hit)
	local char = hit.Parent
	local player = game:GetService("Players"):GetPlayerFromCharacter(char)
	if player then
		module:GiveEgg(player, "Basic Egg")
	end
end)

workspace.Rendered["Tree Egg"].Hitbox.Touched:Connect(function(hit)
	local char = hit.Parent
	local player = game:GetService("Players"):GetPlayerFromCharacter(char)
	if player then
		module:GiveEgg(player, "Tree Egg")
	end
end)


DataService.DataReady:Connect(function(player)
	local data = DataService:GetData(player)
	if not data.Easter then
		data.Easter = {
			Claimed = false,
			Found = {}
		}
	end
end)
return module
ModuleScript: DoggyJump
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local QuestUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.QuestUtil)
local Quests = require(game.ServerScriptService.Server.Quests)
local Time = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.Time);
local DoggyJumpUtil = require(game.ReplicatedStorage.Shared.Utils.DoggyJumpUtil)

local module = {}

local cooldowns = {}

Remote.Event("DoggyJumpWin"):Connect(function(player, score)
	local data = DataService:GetData(player)
	if not data then
		return
	end

	local timeNow = Time.now()
	local timeLeft = data.DoggyJump.Began + DoggyJumpUtil.RefreshPeriod - timeNow
	if timeLeft <= 0 and data.DoggyJump.Claimed >= 3 then
		data.DoggyJump.Claimed = 0
	elseif timeLeft > 0 then
		return
	end

	local prizes = DoggyJumpUtil:GetPrizes()
	local alreadyClaimed = data.DoggyJump.Claimed
	local maxClaim = #DoggyJumpUtil.PrizeScores
	local remaining = math.clamp(score, 1, maxClaim) - alreadyClaimed

	for i = alreadyClaimed + 1, alreadyClaimed + remaining do
		local prize = prizes[i]
		if prize then
			ItemUtil:Add(data, prize)
			Remote:FireClient(player, "ItemsReceived", {prize}, false)
		end
	end

	data.DoggyJump.Claimed = math.clamp(alreadyClaimed + remaining, 1, maxClaim)

	if data.DoggyJump.Claimed >= maxClaim then
		data.DoggyJump.Began = workspace:GetServerTimeNow()
	end
end)

DataService.DataReady:Connect(function(player)
	while task.wait(1) do
		local data = DataService:GetData(player)
		if not data then
			break
		end
		
		local timeNow = Time.now()
		local timeLeft = data.DoggyJump.Began + DoggyJumpUtil.RefreshPeriod - timeNow
		if timeLeft <= 0 and data.DoggyJump.Claimed >= 3 then
			data.DoggyJump.Claimed = 0
		end
	end
end)


return module
ModuleScript: Chat
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local Stages = game:GetService("ServerStorage"):WaitForChild("Stages")

local module = {}

DataService.DataReady:Connect(function(player)
	player:SetAttribute("CanChat", true)
end)

return module
ModuleScript: ChallengePass
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local ChallengePass = require(game.ReplicatedStorage.Shared.Data.ChallengePass)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local ChallengePassChallenges = require(script.ChallengePassChallenges)
local Bindable = require(game.ReplicatedStorage.Shared.Framework.Network.Bindable)
local Stages = game:GetService("ServerStorage"):WaitForChild("Stages")

local QuestUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.QuestUtil);
local QuestBuilder = require(game.ReplicatedStorage.Shared.Data.Builders.QuestBuilder);
local PetData = require(game.ReplicatedStorage.Shared.Data.Pets);
local Quests = require(game.ServerScriptService.Server.Quests)

local defaultChallengeData = {
	GemResets = 0,
	RobuxResets = 0,
	FreeSkips = 0,
	Claimed = {},
	Id = "",
	Points = 0,
	Rewards = {},
}

local finalReward = {
	Type = "Potion",
	Name = "Infinity Elixir",
	Amount = 1
}

local goldenBoxRewards = {
	[2] = 1,
	[4] = 1,
	[6] = 2,
	[8] = 2,
	[10] = 3,
	[12] = 4,
	[14] = 4
}


local module = {}

local function getGoldenBoxItem(tier)
	local goldenBoxReward = DeepCopy(ChallengePass.GoldenBoxReward)
	local boxAmount = goldenBoxRewards[tier]
	goldenBoxReward.Amount = boxAmount
	
	return goldenBoxReward
end

function module:RefreshRewards(save)
	save.ChallengePass.Rewards = {}
	for i = 1, ChallengePass.FinalTier-1 do
		table.insert(save.ChallengePass.Rewards, goldenBoxRewards[i] and getGoldenBoxItem(i) or GetRandomWeightedItem(ChallengePass.RewardsPool))
	end
	table.insert(save.ChallengePass.Rewards, finalReward)
end

function module:GetRandomChallenges(save)
	local rng = Random.new()
	local selectedChallenges = {}
	
	for i = 1, 3 do
		local complete = nil
		repeat
			local challengeSelected = GetRandomWeightedItem(ChallengePassChallenges, rng)
			local v1 = false
			for _, selectedChallenge in selectedChallenges do
				if QuestUtil:CompareTask(challengeSelected.Task, selectedChallenge.Task) then
					v1 = true
					break
				end
			end
			if not v1 and challengeSelected.Task.Type == "Hatch" then
				if challengeSelected.Task.Name then
					local v2 = PetData[challengeSelected.Task.Name];
					v1 = not v2.Egg or save.EggsOpened[v2.Egg] == nil or true;
				elseif challengeSelected.Task.Egg then
					v1 = save.EggsOpened[challengeSelected.Task.Egg] == nil
				end
			end
			if not v1 then
				local Amount = challengeSelected.Task.Amount
				complete = challengeSelected
			end
			
		until complete ~= nil
		table.insert(selectedChallenges, complete)
	end
	return selectedChallenges
end

function module:RefreshChallenges(save)
	local bc1 = QuestUtil:FindById(save, "bubble-challenge-1")
	local bc2 = QuestUtil:FindById(save, "bubble-challenge-2")
	local bc3 = QuestUtil:FindById(save, "bubble-challenge-3")
	if not bc1 or not bc2 or not bc3 then
		
	elseif bc1.Claimed and bc2.Claimed and bc3.Claimed then
		
	else
		return
	end
	
	local randomChallenges = module:GetRandomChallenges(save)
	
	local bubbleString = "bubble-challenge"
	QuestUtil:Remove(save, function(quest)
		return string.sub(quest.Id, 1, (string.len(bubbleString))) == bubbleString
	end)
	
	for challengeId, challenge in pairs(randomChallenges) do
		local newQuest = QuestBuilder.new((("%*-%*"):format(bubbleString, challengeId))):Task(challenge.Task):Reward({
			Type = "Currency", 
			Currency = "ChallengePoints", 
			Amount = challenge.Reward
		});
		QuestUtil:Add(save, newQuest:Build());
	end
end

function module:RefreshChallengePass(player)
	local data = DataService:GetData(player)
	if not data then return end
	
	local defaultData = defaultChallengeData
	defaultChallengeData.Id = ChallengePass.Id
	data.ChallengePass = defaultData
	module:RefreshRewards(data)
end

function module:SkipChallenges(player)
	local save = DataService:GetData(player)
	if not save then return end
	
	Quests:skipQuest(player, "bubble-challenge-1")
	Quests:skipQuest(player, "bubble-challenge-2")
	Quests:skipQuest(player, "bubble-challenge-3")
	
	module:RefreshChallenges(save)
end

function module.ClaimReward(player)
	local data = DataService:GetData(player)
	if not data then return end
	
	local currentClaimed = #data.ChallengePass.Claimed
	if currentClaimed >= ChallengePass.FinalTier then return false end
	local requirement = ChallengePass:GetPointsForTier(currentClaimed+1)
	if data.ChallengePass.Points < requirement then return false end
	
	local reward = data.ChallengePass.Rewards[currentClaimed+1]
	if reward then
		ItemUtil:Add(data, reward)
		Remote:FireClient(player, "ItemsReceived", {reward})
	end
	
	table.insert(data.ChallengePass.Claimed, currentClaimed+1)
	return true
end

function module.FreeSkip(player)
	warn(player)
end

function module.Reset(player, isRobux)
	local data = DataService:GetData(player)
	if not data then return end
	
	if data.ChallengePass.Points < ChallengePass:GetPointsForTier(ChallengePass.FinalTier) then return end
	if not isRobux then
		local resetCost = ChallengePass:GetResetCost(data.ChallengePass.GemResets)
		if not ItemUtil:CanAfford(data, resetCost) then return end
		ItemUtil:Deduct(data, resetCost)
	end
	
	data.ChallengePass.Claimed = {}
	data.ChallengePass[isRobux and "RobuxResets" or "GemResets"] += 1
	data.ChallengePass.Points = 0
	module:RefreshRewards(data)
end

function module.ClaimAll(player)
	local success = true
	repeat success = module.ClaimReward(player) task.wait() until success == false
end

DataService.DataReady:Connect(function(player)
	local data = DataService:GetData(player)
	if not data then return end
	
	if not data.ChallengePass or data.ChallengePass.Id ~= ChallengePass.Id then
		module:RefreshChallengePass(player)
		module:RefreshChallenges(data)
	end
	
	task.spawn(function()
		while task.wait(1) do
			if not DataService:GetData(player) then break end
			module:RefreshChallenges(data)
		end
	end)
end)



Remote.Event("ChallengePassClaimReward"):Connect(module.ClaimReward)
Remote.Event("ChallengePassFreeSkip"):Connect(module.FreeSkip)
Remote.Event("ChallengePassReset"):Connect(function(player)
	module.Reset(player)
end)
Remote.Event("ChallengePassClaimAll"):Connect(module.ClaimAll)
Bindable.Event("ProcessSuccess"):Connect(function(player, productId)
	local data = DataService:GetData(player)
	if not data then return end
	
	if productId == ChallengePass.SkipChallengesProductId then
		module:SkipChallenges(player)
	end
	
	if productId == ChallengePass.UnlockAllProductId then
		data.ChallengePass.Points = ChallengePass:GetPointsForTier(ChallengePass.FinalTier)
	end
	
	if productId == ChallengePass.ResetProductId then
		module.Reset(player, true)
	end
end)
return module
ModuleScript: ChallengePassChallenges
local selectN = select

local function insertValues(target, startIndex, ...)
	local args, count = { ... }, selectN("#", ...)
	for i = 1, count do
		target[startIndex + i - 1] = args[i]
	end
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")

require(ReplicatedStorage.Shared.Types)
require(ReplicatedStorage.Shared.Data.Builders.QuestBuilder)
require(ReplicatedStorage.Shared.Data.Pets)

local Eggs = require(ReplicatedStorage.Shared.Data.Eggs)
local Constants = require(ReplicatedStorage.Shared.Constants)

local function createChallenge(chance, task, reward)
	return {
		Chance = chance,
		Item = {
			Task = task,
			Reward = reward
		}
	}
end

local challenges = {}

insertValues(challenges, 1,
	createChallenge(6, { Type = "Bubbles", Amount = 50000000 }, 400),
	createChallenge(6, { Type = "Bubbles", Amount = 75000000 }, 450),
	createChallenge(6, { Type = "Hatch", Amount = 4000 }, 400),
	createChallenge(6, { Type = "Hatch", Amount = 2500 }, 450),
	createChallenge(6, { Type = "Playtime", Amount = 900 }, 500)
)

local eggHatchAmounts = {
	[250] = 400,
	[450] = 450,
	[650] = 650
}

for eggName, eggData in Eggs do
	if eggData.World then
		for eggAmount, reward in pairs(eggHatchAmounts) do
			table.insert(challenges, createChallenge(1, { Type = "Hatch", Egg = eggName, Amount = eggAmount }, reward))
		end
	end
end

return challenges
ModuleScript: Board
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local EnchantUtil = require(game.ReplicatedStorage.Shared.Utils.EnchantUtil)
local Stages = game:GetService("ServerStorage"):WaitForChild("Stages")

local module = {}

DataService.DataReady:Connect(function(player)
	local data = DataService:GetData(player)
	if not data then return end
	
	if not data.Board then
		data.Board = {
			Piece = -1,
			Tile = 1
		}
	end
end)

return module
ModuleScript: ItemUtil
local ItemUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.ItemUtil)
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local CurrencyUtil = require(game.ReplicatedStorage.Shared.Utils.CurrencyUtil)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
--local Quests = require(game.ServerScriptService.Server.Quests)

local module = {}

function module:Add(save, item, ignoreCap)
	if item.Type == "Currency" then
		local currencyAmount = item.Amount
		local currencyCap = StatsUtil:GetCurrencyCap(save)
		local currencyName = item.Currency
		local actualCap = currencyCap[currencyName] or math.huge
		local currentBalance = CurrencyUtil:GetBalance(save, currencyName)
		if currentBalance + currencyAmount >= actualCap then
			local newCurrencyItem = DeepCopy(item)
			newCurrencyItem.Amount = math.clamp(actualCap - currentBalance, 0, math.huge)
			return ItemUtil:Add(save, newCurrencyItem)
		else
			return ItemUtil:Add(save, item)
		end
	else
		if item.Type == "Pet" then
			if StatsUtil:IsInventoryFull(save) then
				return
			end
		end
		return ItemUtil:Add(save, item)
	end
end


function module:GetRarity(item)
	return ItemUtil:GetRarity(item)
end

function module:GetValue(item)
	return ItemUtil:GetValue(item)
end

function module:GetAmount(item)
	return ItemUtil:GetAmount(item)
end

function module:GetOwnedAmount(save, item)
	return ItemUtil:GetOwnedAmount(save, item)
end

function module:Deduct(save, item)
	if (item.Amount or 1) < 0 or (item.Amount % 1 ~= 0) then 
		return false 
	end
	return ItemUtil:Deduct(save, item)
end

function module:CanAfford(save, item)
	if (item.Amount or 1) < 0 or (item.Amount % 1 ~= 0) then 
		return false 
	end
	return ItemUtil:CanAfford(save, item)
end



function module:UpdateIcon(save, item)
	return ItemUtil:UpdateIcon(save, item)
end

function module:Compare(save, item1, item2)
	return ItemUtil:Compare(save, item1, item2)
end

function module:FormatAmount(save, item)
	return ItemUtil:FormatAmount(save, item)
end

function module:Split(save, item)
	return ItemUtil:Split(save, item)
end

function module:Combine(item)
	return ItemUtil:Combine(item)
end

return module
ModuleScript: Bubbles
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local Quests = require(game.ServerScriptService.Server.Quests)
local Easter = require(game.ServerScriptService.Server.Easter)
local MarketplaceService = game:GetService("MarketplaceService")

local module = {}

function module.updateBubble(player)
	player:SetAttribute("Bubble", game:GetService("HttpService"):JSONEncode(DataService:GetData(player).Bubble))
end

local lastBlown =  {}

Remote.Event("BlowBubble"):Connect(function(player)
	local Save = DataService:GetData(player)
	if not Save then
		warn("returned")
		return false
	end
	if lastBlown[player] and (lastBlown[player]+0.5 > workspace:GetServerTimeNow()) then
		return
	end
	
	local amount = StatsUtil:GetBubblePower(Save)
	
	local maxAmount = StatsUtil:GetBubbleStorage(Save)
	if Save.Passes["Infinity Gum"] then
		maxAmount = math.huge
	end
	
	local currentAmount = Save.Bubble.Amount
	
	if currentAmount > maxAmount then
		warn("uh issue")
		return
	end
	
	if currentAmount + amount > maxAmount then
		Save.Bubble.Amount = maxAmount
	else
		Save.Bubble.Amount += amount
	end
	
	Save.Bubble.Total += amount
	Save.Stats.Bubbles += amount
	
	Quests:progressQuests(player, {Type = "Bubbles", Amount = amount})
	
	module.updateBubble(player)
	lastBlown[player] = workspace:GetServerTimeNow()
end)

Remote.Event("SellBubble"):Connect(function(player)
	local Save = DataService:GetData(player)
	if not Save then
		return false
	end

	--[[local playerPosition = player.Character and player.Character.HumanoidRootPart.Position
	if not playerPosition then
		return false
	end

	local SellZone1 = CFrame.new(77.097, 6.284, -113.065)
	local SellZone2 = CFrame.new(-70.817, 6859.537, 116.498)

	local riftModels = {}
	for _, rift in pairs(Workspace.Rendered.Rifts:GetChildren()) do
		if rift.Name == "bubble-rift" then
			table.insert(riftModels, rift)
		end
	end

	local inSellZone = (playerPosition - SellZone1.Position).Magnitude < 15 or
		(playerPosition - SellZone2.Position).Magnitude < 15

	for _, rift in ipairs(riftModels) do
		if (playerPosition - rift.Position).Magnitude < 15 then
			inSellZone = true
			break
		end
	end

	if not inSellZone then
		return false
	end]]

	local CurrencyMult = StatsUtil:GetCurrencyMultiplier(Save, "Coins")
	local CoinsReward = (2 * Save.Bubble.Amount) * CurrencyMult
	if Save.Bubble.Amount == 777 then
		Easter:GiveEgg(player, "Bubble Egg")
	end

	local Recv = {Currency = "Coins", Type = "Currency", Amount = CoinsReward}
	ItemUtil:Add(Save, Recv)
	Quests:progressQuests(player, {Type = "Collect", Item = Recv})
	Remote:FireClient(player, "ItemsReceived", {Recv})
	Remote:FireAllClients("BubbleSold", player.Name)

	Save.Bubble.Amount = 0
	module.updateBubble(player)

	Quests:progressQuests(player, {Type = "Sell", Amount = 1})
end)

game.Players.PlayerAdded:Connect(function(player)
	repeat task.wait() until DataService:GetData(player)
	module.updateBubble(player)
end)

return module
ModuleScript: Buffs
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)

local module = {}

Remote.Event("UsePotion"):Connect(function(player, potionName, potionTier)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end
	
	local Item = {
		Type = "Potion",
		Name = potionName,
		Level = potionTier,
		Amount = 1
	}
	
	if not ItemUtil:CanAfford(save, Item) then
		return
	end
	
	if not ItemUtil:Deduct(save, Item) then return end
	
	BuffUtil:GivePotion(save, potionName, potionTier)
end)

Remote.Event("UseGoldenOrb"):Connect(function(player)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end
	
	local Item = {
		Type = "Powerup",
		Name = "Golden Orb",
		Amount = 1
	}
	
	if not ItemUtil:CanAfford(save, Item) then
		return
	end

	ItemUtil:Deduct(save, Item)
	
	BuffUtil:GiveBuff(save, "GoldRush", 1, {Type = "Timer", Duration = 900})
end)


ServerData.DataReady:Connect(function(player)
	local save = ServerData:GetData(player)
	BuffUtil:OnJoining(save)
	
	while ServerData:GetData(player) do
		if not game.Players:FindFirstChild(player.Name) then
			break
		end
		local save = ServerData:GetData(player)
		BuffUtil:Update(save)
		task.wait(1)
	end
end)

game.Players.PlayerRemoving:Connect(function(player)
	local save = ServerData:GetData(player)
	if save then
		BuffUtil:OnLeaving(save)
	end
end)

return module
ModuleScript: Chests
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)

local Mastery = require(game.ReplicatedStorage.Shared.Data.Mastery)
local MasteryUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.MasteryUtil)

local Chests = require(game.ReplicatedStorage.Shared.Data.Chests)
local GetInfinityChest = require(game.ReplicatedStorage.Shared.Utils.GetInfinityChest)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local Quests = require(game.ServerScriptService.Server.Quests)


local module = {}

function module.RespawnChest(player, chestName)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end
	
	save.Cooldowns[chestName] = nil
end

Remote.Event("ClaimChest"):Connect(function(player, chestName, instantClaim)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end

	if not Chests[chestName] then return end

	local chestData = DeepCopy(Chests[chestName])
	if chestName == "Infinity Chest" then
		if not save.Passes["VIP"] then
			return
		end
		chestData = DeepCopy(GetInfinityChest(save))
	end

	if save.Cooldowns[chestName] and save.Cooldowns[chestName] > workspace:GetServerTimeNow() then
		return
	end

	save.Cooldowns[chestName] = workspace:GetServerTimeNow() + chestData.Cooldown

	local rolledLoot = {}
	for i = 1, chestData.Rolls do
		local item = DeepCopy(GetRandomWeightedItem(chestData.Pool))
		if item.Type == "Currency" then
			item.Amount = item.Amount * StatsUtil:GetCurrencyMultiplier(save, item.Currency)
		end
		table.insert(rolledLoot, item)
	end

	for _, item in pairs(chestData.Reward) do
		if item.Type == "Currency" then
			item.Amount = item.Amount * StatsUtil:GetCurrencyMultiplier(save, item.Currency)
		end
		ItemUtil:Add(save, item)
		Quests:progressQuests(player, {Type = "Collect", Item = item})
		Remote:FireClient(player, "ItemsReceived", {item})
	end

	if instantClaim then
		for _, item in pairs(rolledLoot) do
			if item.Type == "Currency" then
				item.Amount = item.Amount * StatsUtil:GetCurrencyMultiplier(save, item.Currency)
			end
			ItemUtil:Add(save, item)
			Quests:progressQuests(player, {Type = "Collect", Item = item})
			Remote:FireClient(player, "ItemsReceived", {item})
		end
	else
		VisualItems.CreateVisualItems(player, workspace.Rendered.Chests:FindFirstChild(chestName).Position + Vector3.new(0, 3, 0), rolledLoot)
	end
end)


return module
ModuleScript: Codes
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local Quests = require(game.ServerScriptService.Server.Quests)

local Codes = require(game.ReplicatedStorage.Shared.Data.Codes)
local module = {}

Remote.Function("RedeemCode", function(player, code)
	local save = ServerData:GetData(player)
	local codeData = Codes[string.lower(code)]
	if not codeData then
		return false
	end
	if table.find(save.Redeemed, string.lower(code)) then
		return false
	end
	if game.PlaceId == 138436975122032 then
		if Codes["testing"] and Codes["testing"][string.lower(code)] then
			codeData = Codes["testing"][string.lower(code)]
		end
	end
	for _, item in pairs(codeData) do
		ItemUtil:Add(save, item)
		Remote:FireClient(player, "ItemsReceived", {item})
		Quests:progressQuests(player, {Type = "Collect", Item = item})
	end
	table.insert(save.Redeemed, string.lower(code))
	return true
end)


return module
ModuleScript: DailyRewards
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local ApplyMultiplierToPool = require(game.ReplicatedStorage.Shared.Utils.ApplyMultiplierToPool)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)

local dailyRewards = require(game.ReplicatedStorage.Shared.Data.DailyRewards)
local starsShop = require(game.ReplicatedStorage.Shared.Data.StarsShop)
local Quests = require(game.ServerScriptService.Server.Quests)
local Time = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.Time);


local module = {}

Remote.Event("DailyRewardClaimStars"):Connect(function(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	save.DailyRewards.Claimed = true
	save.DailyRewards.LastStreak += 1
	save.DailyRewards.LastDay = Time.getAbsoluteDay()
	
	if save.DailyRewards.LastStreak > 7 then
		save.DailyRewards.LastStreak = 0
		return
	end
	
	local item = dailyRewards[save.DailyRewards.LastStreak]
	ItemUtil:Add(save, item)
	Quests:progressQuests(player, {Type = "Collect", Item = item})
	Remote:FireClient(player, "ItemsReceived", {item})
	
end)

Remote.Event("DailyRewardsForfeitStreak"):Connect(function(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	save.DailyRewards.LastStreak = 0
	save.DailyRewards.Claimed = false
	save.DailyRewards.LastDay = Time.getAbsoluteDay()
end)


Remote.Event("DailyRewardsBuyItem"):Connect(function(player, item)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	warn(item)
	
	local actualItem = starsShop[item]
	local starsItem = {Type = "Currency", Name = "Stars", Amount = actualItem.Cost}
	if not ItemUtil:CanAfford(save, starsItem) then
		return
	end
	ItemUtil:Deduct(save, starsItem)
	ItemUtil:Add(save, actualItem.Item)
	Quests:progressQuests(player, {Type = "Collect", Item = actualItem.Item})
	Remote:FireClient(player, "ItemsReceived", {actualItem.Item})
	
end)

game.Players.PlayerAdded:Connect(function(player)
	repeat task.wait() until ServerData:GetData(player) ~= nil
	local save = ServerData:GetData(player)
	if Time.getAbsoluteDay() > save.DailyRewards.LastDay then
		save.DailyRewards.Claimed = false
	end
	--ServerData:GetData(player).PlaytimeRewards.Start = game.Workspace:GetServerTimeNow()

end)

return module
ModuleScript: DataService
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local DataStoreService = game:GetService("DataStoreService")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local Types = require(ReplicatedStorage.Shared.Types)
local Remotes = ReplicatedStorage.Remotes
local Bindable = require(game.ReplicatedStorage.Shared.Framework.Network.Bindable)

local oldDatastore = DataStoreService:GetDataStore("Sigma")
local datastore = DataStoreService:GetDataStore("BestofBGSI")
--Change to BGSIBlaze to restore data
local deepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy);
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local defaultStats = require(script.DefaultStats)

local DataService = {}

local playerDatas = {}
local oldPlayerData = {}
local failedLoadPlayers = {}
local dataChangeConnections = {}

local DataReadyRemote = Instance.new("BindableEvent")
DataService.DataReady = DataReadyRemote.Event

function DataService:GetOldData(player)
	return oldPlayerData[player]
end

function DataService:IsReady(player)
	return playerDatas[player] ~= nil
end

function DataService:DidLoadFail(player)
	return failedLoadPlayers[player] == true
end

function DataService:GetData(player)
	return playerDatas[player]
end

function DataService:ConnectDataChanged(dataName, callback)
	local stats = typeof(dataName) == "string" and { dataName } or dataName
	for _, player in pairs(Players:GetPlayers()) do
		for _, statName in stats do
			dataChangeConnections[player] = dataChangeConnections[player] or {}
			dataChangeConnections[player][statName] = dataChangeConnections[player][statName] or {}
			table.insert(dataChangeConnections[player][statName], callback)
		end
	end
	
	local conn = Players.PlayerAdded:Connect(function(player)
		for _, statName in stats do
			dataChangeConnections[player] = dataChangeConnections[player] or {}
			dataChangeConnections[player][statName] = dataChangeConnections[player][statName] or {}
			table.insert(dataChangeConnections[player][statName], callback)
		end
	end)
	
	return function()
		for _, statName in stats do
			for _, map in pairs(dataChangeConnections) do
				if map[statName] then
					for i, cb in ipairs(map[statName]) do
						if cb == callback then
							table.remove(map[statName], i)
							break
						end
					end
				end
			end
		end
		conn:Disconnect()
	end
end

function DataService:Save(player)
	local function clean(data)
		for i, v in pairs(data) do
			if typeof(v) == "table" then
				clean(v)
			elseif typeof(v) == "string" then
				local ok = pcall(function()
					HttpService:JSONEncode(v)
				end)
				if not ok then
					data[i] = nil
				end
			end
		end
	end
	
	if not playerDatas[player] then return false end
	clean(playerDatas[player])
	local ok = pcall(function()
		HttpService:JSONEncode(playerDatas[player])
	end)
	if not ok then return false end

	return pcall(function()
		datastore:UpdateAsync(player.UserId, function()
			return playerDatas[player]
		end)
	end)
end

function DataService:LoadOldData(player)
	local ok, data = pcall(function()
		return oldDatastore:GetAsync(player.UserId)
	end)
	if ok and data then
		oldPlayerData[player] = data
	end
end

function DataService:Load(player)
	if playerDatas[player] then return end
	local success, returned

	pcall(function()
		datastore:UpdateAsync(player.UserId, function(oldData)
			if not oldData then
				returned = deepCopy(defaultStats)
				success = true
				return returned
			end
			for k, v in pairs(defaultStats) do
				if not oldData[k] then oldData[k] = v end
			end
			returned = oldData
			success = true
			return oldData
		end)
	end)

	if not success then
		warn("DATASERVICE CRITICAL FAIL, FAILED TO LOAD DATA FOR: "..player.Name)
		failedLoadPlayers[player] = true
		Remotes.PlayerDataFailed:FireClient(player)
		return false
	end

	playerDatas[player] = returned
	DataReadyRemote:Fire(player)
	task.delay(5, function()
		Remotes.PlayerDataLoaded:FireClient(player, playerDatas[player])
	end)

	task.spawn(function()
		local function equal(a, b)
			if a == b then return true end
			if typeof(a) ~= typeof(b) or typeof(a) ~= "table" then return false end
			for k, v in pairs(a) do
				if not equal(v, b[k]) then return false end
			end
			for k in pairs(b) do
				if a[k] == nil then return false end
			end
			return true
		end

		local function copy(t)
			local r = {}
			for k, v in pairs(t) do
				r[k] = typeof(v) == "table" and copy(v) or v
			end
			return r
		end

		local prev = copy(returned)
		while player.Parent and playerDatas[player] and not failedLoadPlayers[player] do
			if not equal(prev, playerDatas[player]) then
				local changed = {}
				for k, v in pairs(playerDatas[player]) do
					if not equal(prev[k], v) then changed[k] = v end
				end
				prev = copy(playerDatas[player])
				for k, v in pairs(changed) do
					Remotes.PlayerDataChanged:FireClient(player, k, v)
					local c = dataChangeConnections[player] and dataChangeConnections[player][k]
					if c then for _, f in pairs(c) do task.spawn(f, player) end end
				end
			end
			task.wait()
		end
	end)
end

task.spawn(function()
	game:BindToClose(function()
		for p in pairs(playerDatas) do DataService:Save(p) end
	end)
	while task.wait(360) do
		for p in pairs(playerDatas) do DataService:Save(p) end
	end
end)

Players.PlayerAdded:Connect(function(player)
	task.spawn(function() DataService:Load(player) end)
	task.spawn(function() DataService:LoadOldData(player) end)
end)

Players.PlayerRemoving:Connect(function(player)
	local success, attempts = false, 0
	while not success and attempts < 5 do
		success = DataService:Save(player)
		attempts = attempts + 1
		if not success then task.wait(1) end
	end
	if not success then
		warn("DATASERVICE CRITICAL FAIL, FAILED TO SAVE DATA FOR: "..player.Name)
		local backup = DataService.FailedSaves or {}
		DataService.FailedSaves = backup
		backup[player.UserId] = playerDatas[player]
	end
	playerDatas[player] = nil
	oldPlayerData[player] = nil
end)

return DataService
ModuleScript: DeepCopyPure
local function DeepCopyPure(orig, seen)
	if type(orig) ~= "table" then
		return orig
	end
	
	assert(not getmetatable(orig), "Metatables are not allowed")
	seen = seen or {}
	assert(not seen[orig], "Cylic reference detected")
	
	seen[orig] = true
	local copy = {}
	
	for key, value in next, orig do
		copy[DeepCopyPure(key,seen)] = DeepCopyPure(value, seen)
	end
	
	return copy
end

return DeepCopyPure
ModuleScript: DeepEqualsPure
local function DeepEqualsPure(a, b, seen)
	if type(a) ~= "table" or type(b) ~= "table" then
		return rawequal(a,b) or (a ~= a and b ~= b)
	end
	
	if rawequal(a,b) then
		return true
	end
	
	if getmetatable(a) ~= getmetatable(b) or rawlen(a) ~= rawlen(b) then
		return false
	end
	
	seen = seen or {}
	if seen[a] and seen [b] then
		return true
	end
	
	seen[a], seen[b] = true, true
	
	for k, v in next, a do
		if not DeepEqualsPure(v, rawget(b, k), seen) then
			return false
		end
	end
	
	for k in next, b do
		if rawget(a, k) == nil then
			return false
		end
	end
	
	return true
end

return DeepEqualsPure
ModuleScript: DefaultStats
return {
		["Powerups"] = {
		},
		["PolicyInfo"] = {
			["AllowedExternalLinkReferences"] = {
				[1] = "Discord",
				[2] = "YouTube",
				[3] = "Twitch",
				[4] = "Facebook",
				[5] = "X",
				[6] = "Guilded",
			},
			["ArePaidRandomItemsRestricted"] = false,
			["IsPaidItemTradingAllowed"] = true,
			["IsContentSharingAllowed"] = false,
			["AreAdsAllowed"] = true,
			["IsEligibleToPurchaseSubscription"] = true,
			["IsEligibleToPurchaseCommerceProduct"] = false,
			["IsSubjectToChinaPolicies"] = false,
		},
		["MasteryUpgrades"] = {
		},
		["ActiveBuffs"] = {
		},
		["FailedProductPurchases"] = {
		},
		["Coins"] = 0,
		["InvitedUserIds"] = {
		},
		["Settings"] = {
		},
		["PolicyInfoLoaded"] = true,
		["NotifyOptedIn"] = false,
		["Flavors"] = {
			["Bubble Gum"] = true,
		},
		["Potions"] = {
		},
		["DoggyJump"] = {
			["Began"] = 1744448912,
			["Claimed"] = 0,
		},
		["Gems"] = 0,
		["FestivalCoins"] = 0,
		["Tickets"] = 0,
		["Seashells"] = 0,
		
		["Sheckles"] = 0,
		["Candycorn"] = 0,
		["OGData"] = {
			["Claimed"] = false,
			["Passes"] = {
			},
			["IsFirstSuccessfulJoin"] = true,
			["JoinYear"] = -1,
		},
		["PowerOrbLastUsedTime"] = 0,
		["Titles"] = {
		},
		["PlaytimeRewards"] = {
			["Claimed"] = {
			},
			["Start"] = 1744448912.70502,
		},
		["GiftedPasses"] = {
		},
		["TradeHistory"] = {
		},
		["Cooldowns"] = {
		},
		["Gum"] = {
			["Basic Gum"] = true,
		},
		["Quests"] = {},
		["BountySeed"] = 20190,
		["DiscoveredEnchants"] = {
		},
		["Stats"] = {
			["Bubbles"] = 0,
			["WheelSpins"] = 0,
			["RobuxSpent"] = 0,
			["Hatches"] = 0,
			["Playtime"] = 0
		},
		["NextWheelSpin"] = 0,
		["TeamEquipped"] = 1,
		["EggsOpened"] = {
		},
		["ShopFreeRerolls"] = {
			["Used"] = 0,
			["Day"] = 0,
		},
		["ClaimedPrizes"] = {
		},
		["Bubble"] = {
			["Flavor"] = "Bubble Gum",
			["Total"] = 0,
			["Gum"] = "Basic Gum",
			["Amount"] = 0,
		},
		["Pets"] = {
		},
		["LikeGoal"] = 0,
		["AutoDelete"] = {
		},
		["Shards"] = 0,
		["StarterBundle"] = {
			["FinishAt"] = 0,
			["Purchased"] = false,
		},
		["Discovered"] = {
		},
		["ClaimedIndex"] = {
		},
		["EggPrizesClaimed"] = {
		},
		["MasteryLevels"] = {
		},
		["WorldsUnlocked"] = {
			["The Overworld"] = true,
		},
		["AreasUnlocked"] = {
		},
		["QuestsCompleted"] = {},
		["DailyRewards"] = {
			["Stars"] = 0,
			["LastStreak"] = 1,
			["Claimed"] = false,
			["LastDay"] = 20190,
		},
		["TradeModeration"] = {
			["Banned"] = false,
		},
		["ActivePotions"] = {
		},
		["Shops"] = {},
		["Season"] = nil,
		["Passes"] = {
			["Extra Equips"] = true,
		    ["Infinity Gum"] = true,
		    ["Double Gems"] = true,
		    ["VIP"] = true,
		    ["Double Luck"] = true,
		    ["Triple Hatch"] = true,
		    ["Fast Hatch"] = true,
		    ["Digital Storage"] = true,
			["x10 Hatch"] = false,
			["x25 Hatch"] = false,
			["x50 Hatch"] = false,
			["Omega Luck"] = false,
			["Blaze Luck"] = false,
			["Ultra Equips"] = false,
			["Triple Currency"] = false,
		    ["Double Bubble"] = false,
		    ["Double Currency"] = true
		},
		["Teams"] = {
			[1] = {
			["Pets"] = {
				
				},
			},
		},
		["Badges"] = {
		},
		["GemGenie"] = {},
		["Tokens"] = 0,
		["Redeemed"] = {
		},
	["PermanentBuffs"] = {},
	}
ModuleScript: Eggs
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local GetInfinityEgg = require(game.ReplicatedStorage.Shared.Utils.GetInfinityEgg)
local MasteryUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.MasteryUtil)
local Eggs = require(game.ReplicatedStorage.Shared.Data.Eggs)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local ApplyMultiplierToPool = require(game.ReplicatedStorage.Shared.Utils.ApplyMultiplierToPool);
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local SendSystemMessage = require(game.ReplicatedStorage.Shared.Framework.Utilities.SendSystemMessage)

local PetUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.PetUtil);
local GetPetChanceColor = require(game.ReplicatedStorage.Shared.Utils.GetPetChanceColor);
local GetChanceColor = require(game.ReplicatedStorage.Shared.Utils.GetChanceColor);
local FormatCommas = require(game.ReplicatedStorage.Shared.Framework.Utilities.String.FormatCommas)
local Quests = require(game.ServerScriptService.Server.Quests)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)
local WorldUtil = require(game.ReplicatedStorage.Shared.Utils.WorldUtil)
local Pets = require(game.ReplicatedStorage.Shared.Data.Pets)
local RoundFloatingPoint = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.RoundFloatingPoint)
local FormatPercent = require(game.ReplicatedStorage.Shared.Framework.Utilities.String.FormatPercent)
local FindAbsoluteParent = require(game.ReplicatedStorage.Shared.Framework.Utilities.Instances.FindAbsoluteParent)

local HttpService = game:GetService("HttpService")

local rareHatchWebhook = "writeme"

local messagingService = game:GetService("MessagingService")

local module = {}

local hatchCooldowns = {}

local function color3ToHex(color)
	return string.format("#%02X%02X%02X", color.R * 255, color.G * 255, color.B * 255)
end

local function sendMessageGlobally(message)
	messagingService:PublishAsync("GlobalHatch", message)
end

local function hexToDecimal(hex)
	hex = hex:gsub("#", "")
	return tonumber(hex, 16)
end

local function getThumbnailUrl(assetId)
	local url = "https://thumbnails.roproxy.com/v1/assets?assetIds=" .. assetId .. "&size=420x420&format=Png&isCircular=false"
	local success, response = pcall(function()
		return HttpService:GetAsync(url)
	end)
	
	if success then
		local decoded = HttpService:JSONDecode(response)
		if decoded and decoded.data and decoded.data[1] and decoded.data[1].imageUrl then
			return decoded.data[1].imageUrl
		end
	end

	return nil
end

local function sendDiscordHatch(username, pet, rarity, color, petRarity, petImage)
	color = hexToDecimal(color)

	local assetId = petImage:match("rbxassetid://(%d+)")
	local imageUrl = assetId and getThumbnailUrl(assetId) or nil

	local eggLookup = {
		["king doggy"] = "Common Egg",
		["the overlord"] = "Nightmare Egg",
		["man face god"] = "Aura Egg",
		["silly doggy :)"] = "Silly Egg",
		["easter basket"] = "Bunny Egg",
		["giant chocolate chicken"] = "Pastel Egg",
		["dementor"] = "Throwback Egg",
		["godly gem"] = "Throwback Egg",
		["royal trophy"] = "100M Egg",
		["omega dowodle"] = "Blaze Egg",
		["jackpot"] = "Game Egg",
		["mech robot"] = "Cyber Egg",
		["lord shock"] = "Underworld Egg",
		["wolflord"] = "200M Egg",
		["royal guardian"] = "Chance Egg",
		["hyperwave kitty"] = "Neon Egg",
		["mint sundae champion"] = "Icecream Egg",
		["vanilla sundae champion"] = "Icecream Egg",
		["chocolate sundae champion"] = "Icecream Egg",
		["strawberry sundae champion"] = "Icecream Egg",
		["dragonfruit"] = "Fruit Egg",
		["kraken"] = "Fossil Egg",
		["ice basilisk"] = "Fossil Egg",
		["fire basilisk"] = "Fossil Egg",
		["air basilisk"] = "Fossil Egg",
		["electric basilisk"] = "Fossil Egg",
		["gag dragonfly"] = "GAG Exotic Bug Egg",
		["gag queen bee"] = "GAG Bee Egg"
	}

	local function normalizePetName(name)
		name = name:lower()
		name = name:gsub("^(mythic%s+)", "")
		name = name:gsub("^(shiny%s+)", "")
		return name
	end

	local normalizedPet = normalizePetName(pet)
	local eggName = eggLookup[normalizedPet]

	local fields = {
		{
			name = "Pet",
			value = pet,
			inline = true
		},
		{
			name = "Rarity",
			value = rarity,
			inline = true
		}
	}

	if eggName then
		table.insert(fields, {
			name = "Egg",
			value = eggName,
			inline = true
		})
	end

	local data = {
		embeds = {{
			title = username .. " has hatched a " .. petRarity .. " pet!",
			color = color,
			fields = fields,
			timestamp = DateTime.now():ToIsoDate(),
			thumbnail = {
				url = imageUrl
			}
		}}
	}

	local jsonData = HttpService:JSONEncode(data)
	
	pcall(function()
		HttpService:PostAsync(
			rareHatchWebhook,
			jsonData,
			Enum.HttpContentType.ApplicationJson
		)
	end)
end


local function sendMessageForPet(player, pet)
	local petChance = PetUtil:GetChance(pet)
	local save = ServerData:GetData(player)
	if petChance < 1 and (ItemUtil:GetRarity(pet) == "Legendary" or ItemUtil:GetRarity(pet) == "Secret") then
		if save.Settings["Skip Easy Legendary"] and petChance >= Constants.EasyLegendaryThreshold then
			return
		end
		
		local petChanceColor = color3ToHex(GetPetChanceColor(pet))
		
		local prefix = ""
		if pet.Shiny then
			prefix = prefix .. "Shiny "
		end
		if pet.Mythic then
			prefix = prefix .. "Mythic "
		end
		
		local newMessage = ''..'<b><font color="#a2ebff">' .. player.Name ..'</font>'.. ' just hatched a <font color="' .. petChanceColor .. '">' .. prefix .. pet.Name .. ' (' .. FormatPercent(petChance, true) .. ')</font></b>'
		task.delay(StatsUtil:GetHatchDuration(save), function()
			SendSystemMessage(newMessage)
		end)
		
		if ItemUtil:GetRarity(pet) == "Secret" then
			local newGlobalMessage
			if pet.Mythic and pet.Shiny then
				newGlobalMessage = '<b> WTF! SOMEONE JUST HATCHED A <b>1 in '..FormatCommas(math.ceil(100 / petChance))..'</b> <font color="'..petChanceColor..'">'..prefix..pet.Name..'</font></b>!!!'
			elseif pet.Mythic then
				newGlobalMessage = '<b> OMG! SOMEONE JUST HATCHED A <b>1 in '..FormatCommas(math.ceil(100 / petChance))..'</b> <font color="'..petChanceColor..'">'..prefix..pet.Name..'</font></b>!!!'
			else
				newGlobalMessage = '<b> GG! Someone just hatched a <b>1 in '..FormatCommas(math.ceil(100 / petChance))..'</b> <font color="'..petChanceColor..'">'..prefix..pet.Name..'</font></b>!'
			end

			task.delay(StatsUtil:GetHatchDuration(save), function()
				sendMessageGlobally(newGlobalMessage)
			end)
		end
		
		if petChance <= Constants.SecretRarity or ItemUtil:GetRarity(pet) == "Secret" then
			task.spawn(function()
				local imageType = ""
				if pet.Shiny and pet.Mythic then
					imageType = "MythicShiny"
				elseif pet.Shiny then
					imageType = "Shiny"
				elseif pet.Mythic then
					imageType = "Mythic"
				else
					imageType = "Normal"
				end

				sendDiscordHatch(player.Name, prefix..pet.Name, FormatCommas(math.ceil(100/petChance)), petChanceColor, ItemUtil:GetRarity(pet), Pets[pet.Name].Images[imageType] or "rbxassetid://72318360051013")
			end)
		end
	end
end

local function refreshLuckyStreak(Save)
	local luckyStreakMastery = MasteryUtil:GetUpgrade(Save, "LuckyStreak")
	
	if luckyStreakMastery then
		local refreshed = false
		for _, buff in pairs(Save.ActiveBuffs) do
			if buff.Name == luckyStreakMastery.Buff.Name then
				local timeLeft = buff.Expiry.Duration - workspace:GetServerTimeNow()
				local timeNeeded = luckyStreakMastery.Buff.Expiry.Duration - timeLeft
				local newExpiry = DeepCopy(luckyStreakMastery.Buff.Expiry)
				newExpiry.Duration = timeNeeded
				BuffUtil:GiveBuff(Save, luckyStreakMastery.Buff.Name, luckyStreakMastery.Buff.Level, newExpiry)
				refreshed = true
			end
		end
		if not refreshed then
			BuffUtil:GiveBuff(Save, luckyStreakMastery.Buff.Name, luckyStreakMastery.Buff.Level, luckyStreakMastery.Buff.Expiry)
		end
	end
end

local function isPlayerNearEgg(player, eggName)
	local possibleEggs = {}
	
	for _, v212 in (game:GetService("CollectionService"):GetTagged("Egg")) do
		if v212.Name == eggName and v212:IsDescendantOf(workspace) then
			table.insert(possibleEggs, v212)
		end
	end;
	
	local character = player.Character
	if not character then return false end

	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return false end

	local playerPos = root.Position

	for _, egg in possibleEggs do
		local eggPos = egg:IsA("Model") and egg:GetPivot().Position or egg.Position
		if (eggPos - playerPos).Magnitude <= 18 then
			return true, egg:GetAttribute("BonusLuck") or 0
		end
	end

	return false
end

function module.ForcePets(player, pets, eggName)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	local hatchedTable = {
		Speed = 1,
		Name = eggName,
		Pets = {}
	}
	
	for _, pet in pairs(pets) do
		local newPetTable = {
			Deleted = false,
			New = false,
			Pet = pet
		}
		
		local prefix = "";
		if newPetTable.Pet.Shiny then
			prefix = "Shiny "
		end
		if newPetTable.Pet.Mythic then
			prefix = prefix .. "Mythic "
		end
		
		if not Save.Discovered[prefix..newPetTable.Pet.Name] then
			newPetTable.New = true
			Save.Discovered[prefix..newPetTable.Pet.Name] = 1
		else
			Save.Discovered[prefix..newPetTable.Pet.Name] += 1
		end
		
		table.insert(hatchedTable.Pets, newPetTable)
	end
	
	Remote:FireClient(player, "ExclusiveHatch", hatchedTable, false)
end

function module.ForceEgg(player, eggName, eggAmount, isRobux)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end

	local hatchedTable = {
		Speed = 1,
		Name = eggName,
		Pets = {}
	}

	local Pool = GetEggPool(eggName, nil, 1)
	local currentWorld = WorldUtil:GetPlayerWorld(player)

	for i = 1, eggAmount do
		local selectedItem = GetRandomWeightedItem(Pool)

		local newPetTable = {
			Deleted = false,
			New = false,
			Pet = {
				Mythic = false,
				Shiny = false,
				Type = selectedItem.Type,
				Name = selectedItem.Name
			}
		}
		
		
		
		local petRarity = ItemUtil:GetRarity(selectedItem)
		
		if isRobux then
			newPetTable.Pet.Shiny = Random.new():NextNumber(1, 100) <= Constants.RobuxEggShinyChance
		else
			if MasteryUtil:GetUpgrade(Save, "GoldenEgg") then
				newPetTable.Pet.Shiny = Random.new():NextNumber(1,100) <= StatsUtil:GetShinyChance(Save, currentWorld)
			end
		end
		
		if isRobux then
			if petRarity == "Legendary" or petRarity == "Secret" then
				newPetTable.Pet.Mythic = Random.new():NextNumber(1,100) <= Constants.RobuxEggMythicChance
			end
		else
			if MasteryUtil:GetUpgrade(Save, "DarkArts") then
				if petRarity == "Legendary" or petRarity == "Secret" then
					newPetTable.Pet.Mythic = Random.new():NextNumber(1,100) <= StatsUtil:GetMythicChance(Save, currentWorld)
				end
			end
		end
		
		if petRarity == "Legendary" or petRarity == "Secret" then
			refreshLuckyStreak(Save)
		end
		

		sendMessageForPet(player, newPetTable.Pet)
		
		local prefix = "";
		if newPetTable.Pet.Shiny then
			prefix = "Shiny "
		end
		if newPetTable.Pet.Mythic then
			prefix = prefix .. "Mythic "
		end

		if Save.AutoDelete[newPetTable.Pet.Name] and not newPetTable.Pet.Mythic then
			newPetTable.Deleted = true
		end
		if not Save.Discovered[prefix..newPetTable.Pet.Name] then
			newPetTable.New = true
			Save.Discovered[prefix..newPetTable.Pet.Name] = 1
		else
			Save.Discovered[prefix..newPetTable.Pet.Name] += 1
		end

		table.insert(hatchedTable.Pets, newPetTable)

		ItemUtil:Add(Save, newPetTable.Pet)
	end
	
	Remote:FireClient(player, "ExclusiveHatch", hatchedTable, true)
end

Remote.Event("HatchEgg"):Connect(function(player, eggName, eggAmount)

	local Save = ServerData:GetData(player)
	if not Save then 
		return 
	end

	local now = game.Workspace:GetServerTimeNow()

	local hatchDuration = StatsUtil:GetHatchDuration(Save)
	local maxAmount = StatsUtil:GetMaxEggHatches(Save)

	if not Eggs[eggName] and eggName ~= "Infinity Egg" then 
		return 
	end

	local isNearEgg, bonusLuck = isPlayerNearEgg(player, eggName)
	if not isNearEgg then 
		return 
	end

	if eggAmount > maxAmount then 
		return 
	end

	if hatchCooldowns[player] and hatchCooldowns[player] > now then 
		return 
	end

	hatchCooldowns[player] = now + hatchDuration
	player:SetAttribute("NextEggOpenAt", now + hatchDuration)

	if not Save.EggsOpened[eggName] then
		Save.EggsOpened[eggName] = eggAmount
	else
		Save.EggsOpened[eggName] += eggAmount
	end

	local eggData
	if eggName == "Infinity Egg" then
		eggData = GetInfinityEgg(player)
		repeat
			eggData = GetInfinityEgg(player)
			task.wait()
		until eggData ~= nil
	else
		eggData = Eggs[eggName]
	end

	if eggData.Cost then
		local newCost = DeepCopy(eggData.Cost)
		newCost.Amount = newCost.Amount * (eggAmount or 1)

		if not ItemUtil:CanAfford(Save, newCost) then
			return
		end

		if not ItemUtil:Deduct(Save, newCost) then
			return
		end
	end

	local currentWorld = WorldUtil:GetPlayerWorld(player)
	if eggData.World ~= currentWorld then
		currentWorld = "None"
	end

	local Pool
	if eggName == "Infinity Egg" then
		Pool = DeepCopy(GetInfinityEgg(player))
		Pool.Rarities = ApplyMultiplierToPool(Pool.Rarities, StatsUtil:GetLuckMultiplier(player, Save, "None"), function(item)
			local newItem = true
			if item.Item ~= "Legendary" then
				newItem = item.Item == "Secret"
			end
			return newItem
		end)
	else
		Pool = GetEggPool(eggName, currentWorld, StatsUtil:GetLuckMultiplier(player, Save, currentWorld, nil, bonusLuck))
	end

	local hatchedTable = {
		Speed = StatsUtil:GetHatchSpeed(Save),
		Name = eggName,
		Pets = {}
	}

	for i = 1, eggAmount do
		local selectedItem
		if eggName == "Infinity Egg" then
			local selectedRarity = GetRandomWeightedItem(Pool.Rarities)
			selectedItem = GetRandomWeightedItem(Pool.Chances[selectedRarity])
		else
			selectedItem = GetRandomWeightedItem(Pool)
		end

		local newPetTable = {
			Deleted = false,
			New = false,
			Pet = {
				Mythic = false,
				Shiny = false,
				Type = selectedItem.Type,
				Name = selectedItem.Name
			}
		}

		local petRarity = ItemUtil:GetRarity(selectedItem)

		if MasteryUtil:GetUpgrade(Save, "GoldenEgg") then
			newPetTable.Pet.Shiny = Random.new():NextNumber(1, 100) <= StatsUtil:GetShinyChance(Save, currentWorld)

			local Every = MasteryUtil:GetUpgrade(Save, "GoldenEgg").Every
			if Every > 0 then
				local v69 = Every - Save.Stats.Hatches % Every
				if v69 == 75 then
					newPetTable.Pet.Shiny = true
				end
			end
		end

		Save.Stats.Hatches += 1

		if MasteryUtil:GetUpgrade(Save, "DarkArts") then
			if petRarity == "Legendary" or petRarity == "Secret" then
				newPetTable.Pet.Mythic = Random.new():NextNumber(1, 100) <= StatsUtil:GetMythicChance(Save, currentWorld)
			end
		end

		if petRarity == "Legendary" or petRarity == "Secret" then
			refreshLuckyStreak(Save)
		end

		Quests:progressQuests(player, {Type = "Hatch", Egg = eggName, Rarity = petRarity, Amount = 1})
		sendMessageForPet(player, newPetTable.Pet)

		local prefix = ""
		if newPetTable.Pet.Shiny then
			prefix = "Shiny "
		end
		if newPetTable.Pet.Mythic then
			prefix = prefix .. "Mythic "
		end

		if Save.AutoDelete[newPetTable.Pet.Name] and not newPetTable.Pet.Mythic then
			newPetTable.Deleted = true
		else
			ItemUtil:Add(Save, newPetTable.Pet)
		end

		if not Save.Discovered[prefix .. newPetTable.Pet.Name] then
			newPetTable.New = true
			Save.Discovered[prefix .. newPetTable.Pet.Name] = 1
		else
			Save.Discovered[prefix .. newPetTable.Pet.Name] += 1
		end

		table.insert(hatchedTable.Pets, newPetTable)
	end

	Remote:FireClient(player, "HatchEgg", hatchedTable)
end)




Remote.Event("HatchPowerupEgg"):Connect(function(player, eggName, eggAmount)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	local newItem = {
		Type = "Powerup",
		Name = eggName,
		Amount = eggAmount or 1
	}
	
	if not ItemUtil:CanAfford(Save, newItem) then
		return
	end
	if not ItemUtil:Deduct(Save, newItem) then return end

	module.ForceEgg(player, eggName, eggAmount, false)
end)

Remote.Event("ToggleAutoDelete"):Connect(function(player, petName)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end
	
	if not save.AutoDelete[petName] then
		save.AutoDelete[petName] = true
	else
		save.AutoDelete[petName] = nil
	end
end)

messagingService:SubscribeAsync("GlobalHatch", function(recv)
	local players = {}
	for _, player in pairs(game:GetService("Players"):GetPlayers()) do
		local data = ServerData:GetData(player)
		if data then
			if data.Settings["Hide Global Secret Messages"] then
				
			else
				table.insert(players, player)
			end
		else
			table.insert(players, player)
		end
	end
	
	SendSystemMessage(recv.Data, players)
end)

return module
ModuleScript: Gifts
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local Constants = require(game.ReplicatedStorage.Shared.Constants)

local module = {}

local activeGifts = {}

local function getRandomPosition(center, radius)
	local angle = math.random() * 2 * math.pi
	local x = center.X + radius * math.cos(angle)
	local z = center.Z + radius * math.sin(angle)
	return Vector3.new(x, center.Y, z)
end

Remote.Event("UseGift"):Connect(function(player, giftName, giftAmount)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	if activeGifts[player] then
		if #activeGifts[player] + giftAmount > Constants.MaxSpawnableLimit then
			return
		end
	end
	
	giftAmount = tonumber(giftAmount)
	
	local newItem = {
		Type = "Powerup",
		Name = giftName,
		Amount = giftAmount or 1
	}
	if not ItemUtil:CanAfford(Save, newItem) then
		return
	end
	
	ItemUtil:Deduct(Save, newItem)
	
	local giftTable = {}
	
	for i = 1, giftAmount do
		local uid = game:GetService("HttpService"):GenerateGUID(false)
		local giftData = {
			Name = giftName,
			Position = getRandomPosition(player.Character.HumanoidRootPart.Position - Vector3.new(0, 3, 0), 5)
		}
		
		giftTable[uid] = giftData
		
		if not activeGifts[player] then
			activeGifts[player] = {}
		end
		
		activeGifts[player][uid] = giftData
	end
	
	
	Remote:FireClient(player, "RenderGifts", giftTable)
	
end)

Remote.Event("ClaimGift"):Connect(function(player, giftUID)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	local gift = activeGifts[player][giftUID]
	if gift then
		local giftName = gift.Name
		local giftData = Powerups[giftName]
		
		local gottenItems = {}
		
		for i = 1, giftData.Rolls do
			local selectedItem = DeepCopy(GetRandomWeightedItem(giftData.Pool))
			if selectedItem.Type == "Currency" then
				selectedItem.Amount = selectedItem.Amount * StatsUtil:GetCurrencyMultiplier(save, selectedItem.Currency)
				local newItems = ItemUtil:Split(selectedItem, 8)
				for _, item in pairs(newItems) do
					gottenItems[game:GetService("HttpService"):GenerateGUID(false)] = item
				end
			else
				gottenItems[game:GetService("HttpService"):GenerateGUID(false)] = selectedItem
			end
		end
		
		VisualItems.CreateVisualItems(player, gift.Position, gottenItems)
		activeGifts[player][giftUID] = nil
	end
end)

return module
ModuleScript: GumShop
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)

local Flavors = require(game.ReplicatedStorage.Shared.Data.Flavors)
local Gum = require(game.ReplicatedStorage.Shared.Data.Gum)
local Bubbles = require(game.ServerScriptService.Server.Framework.Services.Bubbles)

local Quests = require(game.ServerScriptService.Server.Quests)

local module = {}

function module.UpdateStorage(player, storageName)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	if storageName == "Infinity Gum" then
		if not Save.Passes["Infinity Gum"] then
			return
		end
	elseif storageName == "VIP Gum" then
		if not Save.Passes["VIP"] then
			return
		end
	else
		if not Save.Gum[storageName] then
			return
		end
	end
	
	Quests:progressQuests(player, {Type = "Purchase", Purchased = {Type = "Gum", Name = storageName}})
	Save.Bubble.Gum = storageName
	Bubbles.updateBubble(player)
end

function module.UpdateFlavor(player, flavorName)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	if flavorName == "VIP Flavor" then
		if not Save.Passes["VIP"] then
			return
		end
	else
		if not Save.Flavors[flavorName] then
			return
		end
	end
	
	Quests:progressQuests(player, {Type = "Purchase", Purchased = {Type = "Flavor", Name = flavorName}})
	Save.Bubble.Flavor = flavorName
	Bubbles.updateBubble(player)
end

Remote.Event("GumShopPurchase"):Connect(function(player, Item)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	if Flavors[Item] then
		if typeof(Flavors[Item].Cost) ~= "table" then
			-- GAMEPASS
		else
			local FlavorItem =  Flavors[Item]
			local canAfford = ItemUtil:CanAfford(Save, FlavorItem.Cost)
			if canAfford then
				if not ItemUtil:Deduct(Save, FlavorItem.Cost) then return end
				Save.Flavors[Item] = true
				module.UpdateFlavor(player, Item)
				Quests:progressQuests(player, {Type = "Purchase", Purchased = {Type = "Flavor", Name = Item}})
			end
		end
	elseif Gum[Item] then
		if typeof(Gum[Item].Cost) ~= "table" then
			-- GAMEPASS
		else
			local GumItem =  Gum[Item]
			local canAfford = ItemUtil:CanAfford(Save, GumItem.Cost)
			if canAfford then
				if not ItemUtil:Deduct(Save, GumItem.Cost) then return end
				Save.Gum[Item] = true
				module.UpdateStorage(player, Item)
				Quests:progressQuests(player, {Type = "Purchase", Purchased = {Type = "Gum", Name = Item}})
			end
		end
	else
		return
	end
end)

Remote.Event("UpdateStorage"):Connect(module.UpdateStorage)

Remote.Event("UpdateFlavor"):Connect(module.UpdateFlavor)


return module
ModuleScript: Index
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local ApplyMultiplierToPool = require(game.ReplicatedStorage.Shared.Utils.ApplyMultiplierToPool)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)
local IndexUtil = require(game.ReplicatedStorage.Shared.Utils.IndexUtil)

local dailyRewards = require(game.ReplicatedStorage.Shared.Data.DailyRewards)
local starsShop = require(game.ReplicatedStorage.Shared.Data.StarsShop)
local Time = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.Time);
local Eggs = require(game.ReplicatedStorage.Shared.Data.Eggs)

local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local Quests = require(game.ServerScriptService.Server.Quests)
local Worlds = require(game.ReplicatedStorage.Shared.Data.Worlds)
local Constants = require(game.ReplicatedStorage.Shared.Constants)

local Events = require(game.ReplicatedStorage.Shared.Data.Events)

local module = {}

Remote.Event("ClaimIndex"):Connect(function(player, worldName, indexType)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	local prefix = ""
	
	if indexType == "Normal" then
		if not IndexUtil:IsFinished(save, worldName) then
			return
		end
	else
		if not IndexUtil:IsShinyFinished(save, worldName) then
			return
		end
		prefix = prefix.."Shiny"
	end
	
	if save.ClaimedIndex[prefix..worldName] then return end
	
	if not Worlds[worldName] then return end
	local reward = DeepCopy(Worlds[worldName].Reward)
	if indexType ~= "Normal" then
		if reward.Type == "Pet" then
			reward.Mythic = true
		end
	end
	ItemUtil:Add(save, reward)
	Remote:FireClient(player, "ItemsReceived", {reward})
	save.ClaimedIndex[prefix..worldName] = true
end)

Remote.Event("ClaimEventPrize"):Connect(function(player, eventName, indexType)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	if not Events[eventName] then return end
	local eventData = Events[eventName]
	
	if indexType ~= "Normal" and indexType ~= "Shiny" then return end
	
	for _, egg in pairs(eventData.Eggs) do
		if not IndexUtil:GetEggCompleted(save, nil, indexType, egg) then
			return
		end
	end
	
	if save.EggPrizesClaimed[indexType..eventName] then return end
	
	for _, reward in pairs(eventData.Rewards[indexType]) do
		ItemUtil:Add(save, reward)
		Remote:FireClient(player, "ItemsReceived", {reward})
	end
	save.EggPrizesClaimed[indexType..eventName] = true
end)


Remote.Event("EggPrizeClaim"):Connect(function(player, eggName, isShiny)
	local save = ServerData:GetData(player)
	if not save then
		return
	end

	local newEggName = ("%*%*"):format(isShiny and "S" or "", eggName);

	if not Eggs[eggName] then return end
	if save.EggPrizesClaimed[newEggName] then
		return
	end

	save.EggPrizesClaimed[newEggName] = true

	local reward = DeepCopy(Eggs[eggName].Reward[isShiny and "Shiny" or "Normal"])
	if reward.Type == "Currency" then
		reward.Amount = reward.Amount * StatsUtil:GetCurrencyMultiplier(save, reward.Currency)
	end

	Quests:progressQuests(player, {Type = "Collect", Item = reward})
	ItemUtil:Add(save, reward)
	Remote:FireClient(player, "ItemsReceived", {reward})
end)

return module
ModuleScript: Islands
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)
local Worlds = require(game.ReplicatedStorage.Shared.Data.Worlds)
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local Quests = require(game.ServerScriptService.Server.Quests)
local antiCheat = require(game.ServerScriptService.Server.Utils.AntiCheat)

local module = {}

local worldHubFolder = game.Workspace.Worlds

local function setup()
	for worldName, world in pairs(Worlds) do
		local worldFolder = worldHubFolder:FindFirstChild(worldName)
		local islandsHubFolder = worldFolder.Islands
		for _, island in pairs(world.Islands) do
			local islandFolder = islandsHubFolder:FindFirstChild(island.Name)

			islandFolder.Island.UnlockHitbox.Touched:Connect(function(hit)
				local char = hit.Parent
				local player = game.Players:GetPlayerFromCharacter(char)
				if player then
					local save = ServerData:GetData(player)
					if not save then
						return
					end
					
					Quests:progressQuests(player, {Type = "AreaUnlock", Area = island.Name})
					save.AreasUnlocked[island.Name] = true
				end
			end)
		end
	end
end

local function getInstanceFromPath(path)
	local current = game
	for v in string.gmatch(path, "[^%.]+") do
		current = current:FindFirstChild(v)
		if not current then
			return nil
		end
	end
	return current
end

Remote.Event("Teleport"):Connect(function(player, area)
	local target = getInstanceFromPath(area)
	antiCheat:teleportPlayer(player, target.CFrame)
end)

Remote.Event("UnlockHatchingZone"):Connect(function(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	if ItemUtil:CanAfford(save, Constants.HatchingZoneCost) then
		ItemUtil:Deduct(save, Constants.HatchingZoneCost)
		save.AreasUnlocked["Hatching Zone"] = true
	end
end)

setup()

return module
ModuleScript: Leaderboards
local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local metadataStore = DataStoreService:GetDataStore("LeaderboardMetadata2")
local FormatSuffix = require(game.ReplicatedStorage.Shared.Framework.Utilities.String.FormatSuffix)
local Statue = require(game.ReplicatedStorage.Shared.Framework.Utilities.Statue)

local Leaderboards = game.Workspace.Worlds["The Overworld"].Leaderboards
local RankTemplate = script.RankTemplate
local module = {}

local maxEntries = 100

local leaderboardStores = {}
local leaderboardObjects = {}
local leaderboardStatues = {}

local specialRankIcons = {
	[1] = "rbxassetid://16349181731",
	[2] = "rbxassetid://16349179466",
	[3] = "rbxassetid://16349183706"
}
local specialRankColors = {
	[1] = Color3.new(0.905882, 0.784314, 0.156863),
	[2] = Color3.new(0.905882, 0.905882, 0.905882),
	[3] = Color3.new(1, 0.572549, 0.321569)
}

local function setupStatue(leaderboard: Instance)
	local statName = leaderboard.Name
	leaderboardStatues[statName] = {}
	for _, podium in pairs(leaderboard.Podiums:GetChildren()) do
		leaderboardStatues[statName][tonumber(podium.Name)] = Statue(podium.Spawn.CFrame, podium)
	end
end

local function setupLeaderboard(leaderboard: Instance)
	local statName = leaderboard.Name

	local success, storeOrError = pcall(function()
		return DataStoreService:GetOrderedDataStore("Leaderboard2_" .. statName)
	end)

	if success and storeOrError then
		leaderboardStores[statName] = storeOrError
		leaderboardObjects[statName] = leaderboard
		setupStatue(leaderboard)
	end
end

for _, leaderboard in pairs(Leaderboards:GetChildren()) do
	setupLeaderboard(leaderboard)
end


local function getPlayerLeaderboardRank(statName, userId)
	local dataStore = DataStoreService:GetOrderedDataStore("Leaderboard2_" .. statName)
	local success, pages = pcall(function()
		return dataStore:GetSortedAsync(false, 100)
	end)
	if not success then return nil end

	local rank = 1
	for _, entry in pairs(pages:GetCurrentPage()) do
		if tonumber(entry.key) == userId then
			return rank
		end
		rank += 1
	end

	return nil
end



local function updateLeaderboardStat(player: Player, statName: string)
	local save = ServerData:GetData(player)
	if not save then return end

	local value = save.Stats[statName]
	if typeof(value) ~= "number" then return end

	local store = leaderboardStores[statName]
	if not store then return end

	local userId = player.UserId
	local displayName = player.DisplayName

	pcall(function()
		store:SetAsync(userId, value)
		metadataStore:SetAsync(statName .. "_" .. userId, displayName)
	end)
end

local function clearLeaderboard(leaderboard: Instance)
	for _, v in pairs(leaderboard.Display.Leaderboard.List:GetChildren()) do
		if v:IsA("Frame") then
			v:Destroy()
		end
	end
end

local function updateStatues(leaderboard: Instance, players)
	for _, podium in pairs(leaderboard.Podiums:GetChildren()) do
		local podiumInfo = players[tonumber(podium.Name)]
		if podiumInfo then
			leaderboardStatues[leaderboard.Name][tonumber(podium.Name)].setVisible(true)
			leaderboardStatues[leaderboard.Name][tonumber(podium.Name)].updateAsync(podiumInfo.userId)
			local display = podium.Display.SurfaceGui
			display.DisplayName.Text = podiumInfo.displayName
			display.Period.Text = podiumInfo.value
			display.Username.Text = "@"..podiumInfo.userName
		else
			leaderboardStatues[leaderboard.Name][tonumber(podium.Name)].setVisible(false)
			local display = podium.Display.SurfaceGui
			display.DisplayName.Text = "Nobody"
			display.Period.Text = 0
			display.Username.Text = "@Nobody"
		end
	end
end

function module.getLeaderboardPosition(player: Player, statName: string)
	local store = leaderboardStores[statName]
	if not store then
		return nil
	end

	local userId = player.UserId
	local success, pages = pcall(function()
		return store:GetSortedAsync(false, maxEntries)
	end)

	if not success or not pages then
		return nil
	end

	local topEntries = pages:GetCurrentPage()
	for rank, entry in pairs(topEntries) do
		if tonumber(entry.key) == tonumber(userId) then
			return tonumber(rank)
		end
	end

	return nil
end

local function updateLeaderboard(statName: string)
	local store = leaderboardStores[statName]
	local leaderboard = leaderboardObjects[statName]
	if not store or not leaderboard then return end

	local success, pages = pcall(function()
		return store:GetSortedAsync(false, maxEntries)
	end)

	if not success or not pages then
		return
	end

	local topEntries = pages:GetCurrentPage()
	clearLeaderboard(leaderboard)
	
	local newStatues = {}
	local threads = {}
	local framesByRank = {}

	for rank, entry in pairs(topEntries) do
		local thread = coroutine.create(function()
			local userId = entry.key
			local userName = "Unknown User"
			local successName, resultName = pcall(function()
				return game:GetService("Players"):GetNameFromUserIdAsync(userId)
			end)
			if successName and resultName then
				userName = resultName
			end

			local userDisplayName = userName
			local successDisplay, resultDisplay = pcall(function()
				return metadataStore:GetAsync(statName .. "_" .. userId)
			end)
			if successDisplay and resultDisplay then
				userDisplayName = resultDisplay
			end

			local thumbnail = "rbxthumb://type=AvatarHeadShot&id=1&w=100&h=100"
			local successThumb, resultThumb = pcall(function()
				return game:GetService("Players"):GetUserThumbnailAsync(userId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size100x100)
			end)
			if successThumb and resultThumb then
				thumbnail = resultThumb
			end

			local value = entry.value
			local newRankFrame = RankTemplate:Clone()
			newRankFrame.Name = "Rank" .. tostring(rank)
			newRankFrame.Number.Text = FormatSuffix(value, 1000)
			newRankFrame.Username.Text = "@" .. userName
			newRankFrame.DisplayName.Text = userDisplayName
			newRankFrame.Icon.Image = thumbnail
			newRankFrame.Rank.Label.Text = rank
			newRankFrame.Rank.Label.TextColor3 = specialRankColors[rank] or Color3.new(1, 1, 1)
			newRankFrame.Rank.Icon.Image = specialRankIcons[rank] or ""

			framesByRank[rank] = newRankFrame

			if leaderboardStatues[statName][rank] then
				newStatues[rank] = {
					rank = rank,
					userName = userName,
					displayName = userDisplayName,
					value = FormatSuffix(value, 1000),
					userId = userId
				}
			end
		end)
		table.insert(threads, thread)
		coroutine.resume(thread)
		task.wait()
	end

	while true do
		local allDead = true
		for _, thread in ipairs(threads) do
			if coroutine.status(thread) ~= "dead" then
				allDead = false
				break
			end
		end
		if allDead then break end
		task.wait()
	end
	for rank = 1, #topEntries do
		local frame = framesByRank[rank]
		if frame then
			frame.Parent = leaderboard.Display.Leaderboard.List
		end
	end
	
	updateStatues(leaderboard, newStatues)
end

ServerData.DataReady:Connect(function(player)
	for statName, _ in pairs(leaderboardStores) do
		updateLeaderboardStat(player, statName)
	end
end)

Players.PlayerRemoving:Connect(function(player)
	for statName, _ in pairs(leaderboardStores) do
		updateLeaderboardStat(player, statName)
	end
end)

task.spawn(function()
	while true do
		for _, player in ipairs(Players:GetPlayers()) do
			for statName, _ in pairs(leaderboardStores) do
				updateLeaderboardStat(player, statName)
			end
		end

		for statName, _ in pairs(leaderboardStores) do
			updateLeaderboard(statName)
		end

		task.wait(300)
	end
end)

return module
ModuleScript: LeaderStats
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local SortPetsList = require(game.ReplicatedStorage.Shared.Utils.SortPetsList)

local module = {}

local function setupLeaderstats(player)
	local leaderstats = Instance.new("Folder", player)
	leaderstats.Name = "leaderstats"

	local Hatches = Instance.new("IntValue", leaderstats)
	Hatches.Name = " Hatches"
	
	local Bubbles = Instance.new("IntValue", leaderstats)
	Bubbles.Name = " Bubbles"
	
	local save = ServerData:GetData(player)
	Hatches.Value = save.Stats.Hatches
	Bubbles.Value = save.Stats.Bubbles
end

ServerData:ConnectDataChanged("Stats", function(player)
	local save = ServerData:GetData(player)
	if not save then return end
	player.leaderstats:FindFirstChild(" Bubbles").Value = save.Stats.Bubbles
	player.leaderstats:FindFirstChild(" Hatches").Value = save.Stats.Hatches
end)

ServerData.DataReady:Connect(function(player)
	setupLeaderstats(player)
end)


return module
ModuleScript: Mastery
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)

local Mastery = require(game.ReplicatedStorage.Shared.Data.Mastery)
local MasteryUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.MasteryUtil)

local module = {}

Remote.Event("UpgradeMastery"):Connect(function(player, masteryName)
	local save = ServerData:GetData(player)
	if not save then return false end

	local currentLevel = save.MasteryLevels[masteryName] or 0
	local upgradeData = Mastery.Upgrades[masteryName]
	if not upgradeData or not upgradeData.Levels or not upgradeData.Levels[currentLevel + 1] then
		return false
	end

	local nextLevelData = upgradeData.Levels[currentLevel + 1]
	local cost = nextLevelData.Cost
	if not cost then return false end

	if not ItemUtil:CanAfford(save, cost) then return false end
	if not ItemUtil:Deduct(save, cost) then return false end

	save.MasteryLevels[masteryName] = currentLevel + 1
	save.MasteryUpgrades = MasteryUtil:GetUpgrades(save)
end)


return module
ModuleScript: Monteization
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local Bindable = require(game.ReplicatedStorage.Shared.Framework.Network.Bindable)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Season = require(game.ServerScriptService.Server.Framework.Services.Season)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local Quests = require(game.ServerScriptService.Server.Quests)

local Eggs = require(game.ServerScriptService.Server.Framework.Services.Eggs)

local Gamepasses = require(game.ReplicatedStorage.Shared.Data.Gamepasses)
local Products = require(game.ReplicatedStorage.Shared.Data.Products)
local ChestData = require(game.ReplicatedStorage.Shared.Data.Chests)
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local ItemShops = require(game.ServerScriptService.Server.ItemShops)
local Chests = require(game.ServerScriptService.Server.Framework.Services.Chests)

local MarketplaceService = game:GetService("MarketplaceService")

local module = {}

local item = {
	Type = "Potion",
	Name = "Aura Elixir",
	Level = 1,
	Amount = 1,
}

local item2 = {
	Type = "Potion",
	Name = "Aura Elixir",
	Level = 1,
	Amount = 2,
}

local egg1 = {
	Type = "Powerup",
	Name = "Spongebob Egg",
	Amount = 3,
}

local egg2 = {
	Type = "Powerup",
	Name = "Spongebob Egg",
	Amount = 9,
}

local egg3 = {
	Type = "Powerup",
	Name = "Spongebob Egg",
	Amount = 27,
}

local egg4 = {
	Type = "Powerup",
	Name = "Spongebob Egg",
	Amount = 99,
}

MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(player, gamepassId, purchased)
	local save = ServerData:GetData(player)
	
	if purchased then
		for gamepassName, gamepassData in pairs(Gamepasses) do
			if gamepassData.Id == gamepassId then
				save.Passes[gamepassName] = true
			end
		end
	end
end)

local Skips = {
	3279504870, 
	3279504870, 
	3279504870, 
	3279504870, 
	3279504870, 
	3279504870, 
	3279504870
}

local playerGiftingPlayer = {}

MarketplaceService.ProcessReceipt = function(receipt)
	local player = game:GetService("Players"):GetPlayerByUserId(receipt.PlayerId)
	local save = ServerData:GetData(player)
	local productId = receipt.ProductId
	
	if productId == 3281958661 then
		Eggs.ForceEgg(player, "Holy Egg", 1, true)
	end
	--AURA
	if productId == 3297746974 then
		ItemUtil:Add(save, item)
	end
	
	if productId == 3297747073 then
		ItemUtil:Add(save, item2)
	end
	--AURA
	
	--egg
	if productId == 3304754160 then
		ItemUtil:Add(save, egg1)
	end

	if productId == 3304754417 then
		ItemUtil:Add(save, egg2)
	end
	
	if productId == 3304754534 then
		ItemUtil:Add(save, egg3)
	end

	if productId == 3304754976 then
		ItemUtil:Add(save, egg4)
	end
	--egg
	
	if productId == Constants.ShopRerollProductId then
		ItemShops:RerollShop(player, nil, true)
	end
	
	for gamepassName, gamepassData in pairs(Gamepasses) do
		if gamepassData.GiftProductId == productId then
			if playerGiftingPlayer[player] then
				local otherData = ServerData:GetData(playerGiftingPlayer[player])
				otherData.GiftedPasses[gamepassName] = true
				otherData.Passes[gamepassName] = true
				Remote:FireAllClients("GiftSuccess", player, playerGiftingPlayer[player], gamepassName)
			end
		end
	end
	
	for _, product in pairs(Products) do
		if product.ProductId == productId then
			if product.Type == "Item" then
				ItemUtil:Add(save, product.Item)
				Quests:progressQuests(player, {Type = "Collect", Item = product.Item})
				if product.Item.Type == "Pet" then
					Eggs.ForcePets(player, {product.Item} , "Shop Egg")
				end
			elseif product.Type == "Bundle" then
				local allPets = {}
				
				for _, entry in pairs(product.Items) do
					local roll = math.random(1, 100)
					if roll <= entry.Chance then
						ItemUtil:Add(save, entry.Item)
						Quests:progressQuests(player, {Type = "Collect", Item = entry.Item})
						if entry.Item.Type == "Pet" then
							table.insert(allPets, entry.Item)
						end
					end
				end
				if allPets ~= {} then
					Eggs.ForcePets(player, {product.Item} , "Shop Egg")
				end
				
			end
		end
	end
	
	for chestName, chestData in pairs(ChestData) do
		if chestData.DevProduct == productId then
			Chests.RespawnChest(player, chestName)
		end
	end
	
	if table.find(Skips, productId) then
		Season.SkipToNextLevel(player)
	end
	
	if productId == 3279504629 then
		Season.FinishSeason(player)
	end
	if productId == 3279503200 then
		Season.UnlockPremium(player)
	end
	
	Bindable:Fire("ProcessSuccess", player, productId)
	
	return Enum.ProductPurchaseDecision.PurchaseGranted
end

Remote.Function("TryGiftPlayer", function(player, giftedPlayer, gamepass)
	local data = ServerData:GetData(player)
	local giftedData = ServerData:GetData(giftedPlayer)
	if not data or not giftedData then
		return false
	end
	
	if giftedData.Passes[gamepass] then
		return false, giftedPlayer.Name.." already owns that gamepass!"
	end
	
	if not Gamepasses[gamepass] then
		return false, "This is not a valid gamepass"
	end
	
	playerGiftingPlayer[player] = giftedPlayer
	return true
end)

local freePasses = {
	"Infinity Gum", "Digital Storage", "Triple Hatch"
}

ServerData.DataReady:Connect(function(player)
	local data = ServerData:GetData(player)
	if not data then warn("BRUH") return end
	for _, pass in pairs(freePasses) do
		data.Passes[pass] = true
	end
	
	for gamepassName, gamepassData in pairs(Gamepasses) do
		if not data.Passes[gamepassName] then
			local success, hasGamePass = pcall(function()
				return MarketplaceService:UserOwnsGamePassAsync(player.UserId, gamepassData.Id)
			end)
			
			if success and hasGamePass then
				data.Passes[gamepassName] = true
			end
		end
	end
	
	local oldData = ServerData:GetOldData(player)
	if oldData then
		for _, giftedGamepass in pairs(oldData.GiftedPasses) do
			data.Passes[giftedGamepass] = true
		end
	end
end)

return module
ModuleScript: Pets
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local SortPetsList = require(game.ReplicatedStorage.Shared.Utils.SortPetsList)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local CreatePlayerPet = require(game.ReplicatedStorage.Shared.Utils.CreatePlayerPet)
local PetLevelUtil = require(game.ReplicatedStorage.Shared.Utils.PetLevelUtil)
local ShinyUtil = require(game.ReplicatedStorage.Shared.Utils.ShinyUtil)
local PetStackUtil = require(game.ReplicatedStorage.Shared.Utils.PetStackUtil)


local module = {}

local function addMarker(player, petUID)
	local pet = module.getPetDataByUID(player, petUID)
	local newMarker = Instance.new("Folder")
	newMarker.Name = petUID
	newMarker:SetAttribute("Mythic", pet.Mythic or false)
	newMarker:SetAttribute("Name", pet.Name)
	newMarker:SetAttribute("OwnerId", player.UserId)
	newMarker:SetAttribute("Shiny", pet.Shiny or false)
	newMarker.Parent = game.Workspace.Markers.Pets
end

local function removeMarket(player, petUID)
	local thing = game.Workspace.Markers.Pets:FindFirstChild(petUID)
	if thing then
		thing:Destroy()
	end
end

local function removeAllMarkers(player)
	for _, marker in pairs(game.Workspace.Markers.Pets:GetChildren()) do
		if marker:GetAttribute("OwnerId") == player.UserId then
			marker:Destroy()
		end
	end
end

local function setupMarkers(player)
	local Save = ServerData:GetData(player)
	if not Save then return end
	
	local EquippedTeam = Save.TeamEquipped
	local EquippedPets = DeepCopy(Save.Teams[EquippedTeam].Pets)

	for i, uid in pairs(EquippedPets) do
		if not module.getPetDataByUID(player, uid) then
			table.remove(Save.Teams[EquippedTeam].Pets, i)
		else
			addMarker(player, uid)
		end
	end
end

function module:IsEquipped(save, petUID)
	local equippedTeam = save.TeamEquipped
	local pets = save.Teams[equippedTeam].Pets
	for _, v in pairs(DeepCopy(pets)) do
		if v == petUID then
			return true
		end
	end
	return false
end

function module:MaxXP(player, petUID)
	local data = ServerData:GetData(player)
	if not data then return end
	
	local petData = module.getPetDataByUID(player, petUID)
	if not petData then
		return
	end
	local petAmount = petData.Amount or 1
	local xpUntilMax = PetLevelUtil:CalculateXPUntilMax(petData)
	if petAmount > 1 then
		module.DeletePet(player, petUID, 1)
		local newPet = CreatePlayerPet(data, petData.Name, {XP = xpUntilMax, Shiny = petData.Shiny, Mythic = petData.Mythic})
		table.insert(data.Pets, newPet)

		if module:IsEquipped(data, petUID) then
			module.UnequipPet(player, petUID)
			module.EquipPet(player, newPet.Id)
		end

		Remote:FireClient(player, "PetIdChanged", petData.Id, newPet.Id)
	else
		petData.XP += xpUntilMax
	end
end

function module:ApplyXP(player, xp)
	local data = ServerData:GetData(player)
	if not data then return end
	
	local EquippedTeam = data.TeamEquipped
	for _, petUID in pairs(DeepCopy(data.Teams[EquippedTeam].Pets)) do
		local petData = module.getPetDataByUID(player, petUID)
		if petData then
			local petAmount = petData.Amount or 1
			if petAmount > 1 then
				module.DeletePet(player, petUID, 1)

				local newPet = CreatePlayerPet(data, petData.Name, {XP = xp, Shiny = petData.Shiny, Mythic = petData.Mythic})
				table.insert(data.Pets, newPet)

				if module:IsEquipped(data, petUID) then
					module.UnequipPet(player, petUID)
					module.EquipPet(player, newPet.Id)
				end

				Remote:FireClient(player, "PetIdChanged", petData.Id, newPet.Id)
			else
				local xpUntilMax = PetLevelUtil:CalculateXPUntilMax(petData)
				if xp > xpUntilMax then
					petData.XP += xpUntilMax
				else
					petData.XP += xp
				end
			end
		end
	end

end

function module.getPetDataByUID(player, petUID)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	for _, pet in pairs(Save.Pets) do
		if pet.Id == petUID then
			return pet
		end
	end
	return nil
end

function module.EquipPet(player, petUID)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	if not module.getPetDataByUID(player, petUID) then
		return
	end
	
	local petAmount = module.getPetDataByUID(player, petUID).Amount or 1
	local currentEquippedAmountOfPet = 0
	
	local maxEquipped = StatsUtil:GetMaxPetsEquipped(Save)
	local EquippedTeam = Save.TeamEquipped
	
	local currentEquipped = #Save.Teams[EquippedTeam].Pets
	if currentEquipped >= maxEquipped then
		return
	end
	
	for _, v in pairs(DeepCopy(Save.Teams[EquippedTeam].Pets)) do
		if v == petUID then
			currentEquippedAmountOfPet += 1
		end
	end
	
	if currentEquippedAmountOfPet >= petAmount then
		return
	end
	
	table.insert(Save.Teams[EquippedTeam].Pets, petUID)
	addMarker(player, petUID)
end

function module.UnequipPet(player, petUID)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end

	local EquippedTeam = Save.TeamEquipped
	local pets = Save.Teams[EquippedTeam].Pets

	for i, uid in pairs(pets) do
		if uid == petUID then
			table.remove(pets, i)
			break 
		end
	end
	
	removeMarket(player, petUID)
end

function module.UnequipAllPets(player)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end

	local EquippedTeam = Save.TeamEquipped
	local EquippedPets = DeepCopy(Save.Teams[EquippedTeam].Pets)
	for _, uid in pairs(EquippedPets) do
		module.UnequipPet(player, uid)
	end
	return true
end

Remote.Event("EquipPet"):Connect(module.EquipPet)

Remote.Event("UnequipPet"):Connect(module.UnequipPet)

Remote.Event("UnequipAllPets"):Connect(module.UnequipAllPets)

Remote.Event("EquipBestPets"):Connect(function(player) -- TODO: FIX THIS (Pets Have amounts :sob:)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end
	
	local EquippedTeam = Save.TeamEquipped
	local MaxEquipped = StatsUtil:GetMaxPetsEquipped(Save)
	
	local v177 = {};
	local v178 = {};
	for _, v180 in Save.Pets do
		for i = 1, v180.Amount or 1 do
			table.insert(v177, v180.Id);
		end
		v178[v180.Id] = v180;
	end;
	SortPetsList(v177, v178, "Power");
	module.UnequipAllPets(player)

	for i = 1, MaxEquipped do
		if module.getPetDataByUID(player, v177[i]) then
			module.EquipPet(player, v177[i])
		end
	end
	
end)

Remote.Event("MultiDeletePets"):Connect(function(player, pets)
	local data = ServerData:GetData(player)
	if not data then
		return false
	end
	
	local reconstructed = {}
	for i, v in pairs(pets) do
		local idStrs = v:split("-")
		table.remove(idStrs, 6)
		local petId = table.concat(idStrs, "-")
		
		reconstructed[petId] = (reconstructed[petId] or 0) + 1
	end
	
	for i, v in pairs(reconstructed) do
		module.DeletePet(player, i, v)
	end
end)

function module.UnequipAllByUID(player, petUID)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end

	local EquippedTeam = Save.TeamEquipped
	local EquippedPets = DeepCopy(Save.Teams[EquippedTeam].Pets)
	for _, uid in pairs(EquippedPets) do
		if uid == petUID then
			module.UnequipPet(player, uid)
		end
	end
end

function module.DeletePet(player, petUID, amount, isEquipped)
	local Save = ServerData:GetData(player)
	if not Save then
		return false
	end

	local pet = module.getPetDataByUID(player, petUID)
	if not pet then
		return
	end
	
	if isEquipped then
		module.UnequipPet(player, petUID)
	end
	
	if not pet.Amount then
		for i, petdata in pairs(Save.Pets) do
			if petdata.Id == petUID then
				table.remove(Save.Pets, i)
				module.UnequipAllByUID(player, petUID)
				break 
			end
		end
	else
		if pet.Amount - amount <= 0 then
			for i, petdata in pairs(Save.Pets) do
				if petdata.Id == petUID then
					table.remove(Save.Pets, i)
					module.UnequipAllByUID(player, petUID)
					break 
				end
			end
		else
			pet.Amount = pet.Amount - amount
		end
	end
end

Remote.Event("DeletePet"):Connect(module.DeletePet)

Remote.Event("UnlockPet"):Connect(function(player, petUID, boolean)
	local data = ServerData:GetData(player)
	if not data then
		return false
	end
	
	local petData = module.getPetDataByUID(player, petUID)
	if not petData then return end
	petData.Locked = false
	
	if PetStackUtil:FindMergePet(data, petData) then
			module.DeletePet(player, petUID, 1)
			local mergedInto = PetStackUtil:FindMergePet(data, petData)
			local mergedAmount = mergedInto.Amount or 1
			if mergedAmount > 1 then
				mergedInto.Amount += (petData.Amount or 1)
			else
				mergedInto.Amount = 1 + (petData.Amount or 1)
			end

			Remote:FireClient(player, "PetIdChanged", petData.Id, mergedInto.Id)
		end
end)

Remote.Event("LockPet"):Connect(function(player, petUID, boolean)
	local data = ServerData:GetData(player)
	if not data then
		return false
	end

	local petData = module.getPetDataByUID(player, petUID)
	if not petData then return end
	
	local petAmount = petData.Amount or 1
	if petAmount > 1 then
		module.DeletePet(player, petUID, 1)
		local newPet = CreatePlayerPet(data, petData.Name, {XP = 0, Shiny = petData.Shiny, Mythic = petData.Mythic})
		
		newPet.Locked = true
			table.insert(data.Pets, newPet)

			if module:IsEquipped(data, petUID) then
				module.UnequipPet(player, petUID)
				module.EquipPet(player, newPet.Id)
			end

			Remote:FireClient(player, "PetIdChanged", petData.Id, newPet.Id)
	else
		petData.Locked = true
	end
end)

Remote.Event("UsePowerOrb"):Connect(function(player, petUID)
	local item = {
		Type = "Powerup", 
		Name = "Power Orb", 
		Amount = 1
	}
	local data = ServerData:GetData(player)
	if not data then return end
	if not ItemUtil:CanAfford(data, item) then
		return
	end
	if not ItemUtil:Deduct(data, item) then return end
	module:MaxXP(player, petUID)
end)

Remote.Event("MakePetShiny"):Connect(function(player, petUID)
	local data = ServerData:GetData(player)
	if not data then return end
	local petData = module.getPetDataByUID(player, petUID)
	if not petData then return end

	if petData.Locked then
		petData.Locked = false
	end

	if petData.Shiny then return end

	local newShinyPet = {
		Type = "Pet",
		Shiny = true,
		Name = petData.Name
	}

	if petData.Mythic then
		newShinyPet.Mythic = true
	end
	
	local pets = ShinyUtil:GetPets(data, petData)
	local ownedCount = ShinyUtil:GetOwnedCount(data, petData);
	

	if (ownedCount < ShinyUtil:GetRequiredCount(petData)) then
		return;
	end
	
	for _, pet in pairs(pets) do
		module.DeletePet(player, pet.Id, (pet.Item.Amount or 1))
	end

	ItemUtil:Add(data, newShinyPet)

	local prefix = "Shiny "
	if petData.Mythic then
		prefix = prefix.."Mythic "
	end

	if not data.Discovered[prefix..newShinyPet.Name] then
		data.Discovered[prefix..newShinyPet.Name] = 1
	else
		data.Discovered[prefix..newShinyPet.Name] += 1
	end
end)

Remote.Event("RenameTeam"):Connect(function(player, teamName)
	local Save = ServerData:GetData(player)
	if not Save then return end
	
	local EquippedTeam = Save.TeamEquipped
	local Team = Save.Teams[EquippedTeam]
	
	Team.Name = teamName
end)

Remote.Event("EquipTeam"):Connect(function(player, teamId)
	local save = ServerData:GetData(player)
	teamId = tonumber(teamId)
	if not save then return end
	if not save.Teams[teamId] then return end
	
	save.TeamEquipped = teamId
	removeAllMarkers(player)
	setupMarkers(player)
end)

ServerData:ConnectDataChanged({"MasteryUpgrades", "Stats", "Pets"}, function(player)
	local save = ServerData:GetData(player)
	if not save then return end
	StatsUtil:FixupPetTeamsData(save)
end)

ServerData.DataReady:Connect(function(player)
	setupMarkers(player)
end)

game.Players.PlayerRemoving:Connect(function(player)
	removeAllMarkers(player)
end)

return module
ModuleScript: PickUps
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)
local Worlds = require(game.ReplicatedStorage.Shared.Data.Worlds)
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local GetPickupZones = require(game.ReplicatedStorage.Shared.Utils.GetPickupZones)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)

local Pets = require(game.ServerScriptService.Server.Framework.Services.Pets)
local CollectPickup = game.ReplicatedStorage.Remotes.Pickups.CollectPickup
local SpawnPickups = game.ReplicatedStorage.Remotes.Pickups.SpawnPickups
local Quests = require(game.ServerScriptService.Server.Quests)

local module = {}

local currentPickups = {}
local pickupRespawnTime = Constants.PickupRespawnTime

local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)

local function setupZone(player, zoneRoot, zoneData)
	task.spawn(function()
		while ServerData:GetData(player) do
			local save = ServerData:GetData(player)
			if not save then
				break
			end
			
			local zonePickups = {}
			for uid, pickup in pairs(currentPickups[player]) do
				if pickup.Root == zoneRoot then
					table.insert(zonePickups, uid)
				end
			end

			if #zonePickups < zoneData.Count then
				local neededToSpawn = zoneData.Count - #zonePickups
				local newPickups = {}
				for i = 1, neededToSpawn do
					local uid = game:GetService("HttpService"):GenerateGUID(false)
					local chosenPickup = GetRandomWeightedItem(zoneData.Pickups)

					currentPickups[player][uid] = {
						Root = zoneRoot,
						Id = uid,
						Item = DeepCopy(chosenPickup.Item),
						Visual = chosenPickup.Visual
					}

					table.insert(newPickups, {Root = zoneRoot, Id = uid, Visual = chosenPickup.Visual})
				end


				SpawnPickups:FireClient(player, newPickups)
			end

			local newPickupRespawnTime = pickupRespawnTime
			BuffUtil:UseBuffs(save, "Pickups", function(buff)
				local value = buff.Value / 100
				newPickupRespawnTime = newPickupRespawnTime / value
			end)
			
			task.wait(newPickupRespawnTime)
		end
	end)
end

local function setupPickups(player)
	currentPickups[player] = {}

	local spawnedPickups = {}

	for ZoneModel, ZoneData in pairs(GetPickupZones()) do
		for i = 1, ZoneData.Count do
			local uid = game:GetService("HttpService"):GenerateGUID(false)
			local chosenPickup = GetRandomWeightedItem(ZoneData.Pickups)

			currentPickups[player][uid] = {
				Root = ZoneModel,
				Id = uid,
				Item = DeepCopy(chosenPickup.Item),
				Area = ZoneData.Area
			}

			table.insert(spawnedPickups, {
				Root = ZoneModel,
				Id = uid,
				Visual = chosenPickup.Visual
			})
		end

		setupZone(player, ZoneModel, ZoneData)
	end

	SpawnPickups:FireClient(player, spawnedPickups)
end

ServerData.DataReady:Connect(function(player)
	currentPickups[player] = {}
	task.delay(1, function()
		setupPickups(player)
	end)
end)

CollectPickup.OnServerEvent:Connect(function(player, pickupUID)
	if currentPickups[player][pickupUID] then
		local save = ServerData:GetData(player)
		
		if currentPickups[player][pickupUID].Item.Type == "Currency" then
			currentPickups[player][pickupUID].Item.Amount = math.floor(currentPickups[player][pickupUID].Item.Amount * StatsUtil:GetCurrencyMultiplier(save, currentPickups[player][pickupUID].Item.Currency, true))
		end
		
		Pets:ApplyXP(player, (Constants.PickupXP[currentPickups[player][pickupUID].Visual] or 0))
		ItemUtil:Add(save, currentPickups[player][pickupUID].Item)
		Quests:progressQuests(player, {Type = "Collect", Item = currentPickups[player][pickupUID].Item})
		Remote:FireClient(player, "ItemsReceived", {currentPickups[player][pickupUID].Item})

		currentPickups[player][pickupUID] = nil
	end
end)

return module
ModuleScript: PlayTime
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local ApplyMultiplierToPool = require(game.ReplicatedStorage.Shared.Utils.ApplyMultiplierToPool)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)

local playTime = require(game.ReplicatedStorage.Shared.Data.Playtime)
local Quests = require(game.ServerScriptService.Server.Quests)
local module = {}

local function ResetPlaytimeRewards(player)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end
	
	save.PlaytimeRewards.Claimed = {}
	save.PlaytimeRewards.Start = workspace:GetServerTimeNow()
end

Remote.Function("ClaimPlaytime", function(player, reward)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end
	reward = tostring(reward)
	if save.PlaytimeRewards.Claimed[reward] then
		return false
	end
	if save.PlaytimeRewards.Start + playTime.Gifts[tonumber(reward)].Time > workspace:GetServerTimeNow() then
		return false
	end
	
	local Prizes = playTime.Gifts[tonumber(reward)].Luck > 1 and ApplyMultiplierToPool(playTime.Prizes, playTime.Gifts[tonumber(reward)].Luck, function(item)
			local l_v10_Rarity_0 = ItemUtil:GetRarity(item.Item);
			local v68 = true;
			if l_v10_Rarity_0 ~= "Legendary" then
				v68 = l_v10_Rarity_0 == "Secret";
			end;
			return v68;
		end) or playTime.Prizes
	local prize = GetRandomWeightedItem(Prizes)
	ItemUtil:Add(save, prize)
	Quests:progressQuests(player, {Type = "Collect", Item = prize})
	save.PlaytimeRewards.Claimed[reward] = true
	
	
	local claimedCount = 0
	for _ in pairs(save.PlaytimeRewards.Claimed) do
		claimedCount += 1
	end
	
	if claimedCount >= 9 then
		ResetPlaytimeRewards(player)
	end
	
	return prize
end)

game.Players.PlayerAdded:Connect(function(player)
	repeat task.wait() until ServerData:GetData(player) ~= nil
	ResetPlaytimeRewards(player)
	
	
	while ServerData:GetData(player) do
		task.wait(5)
		local save = ServerData:GetData(player)
		if save then
			if not save.Stats.Playtime then
				save.Stats.Playtime = 0
			end
			save.Stats.Playtime += 5
			Quests:progressQuests(player, {Type = "Playtime", Amount = 5})
		end
	end
end)

return module
ModuleScript: PolicyInfo
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)
local BuffUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.BuffUtil)
local PolicyService = game:GetService("PolicyService")

local module = {}
ServerData.DataReady:Connect(function(player)
	local data = ServerData:GetData(player)
	if not data then
		return
	end
	local newPolicy = PolicyService:GetPolicyInfoForPlayerAsync(player)
	if not newPolicy or newPolicy == {} then
		return
	end
	
	data.PolicyInfo = newPolicy
end)

return module
ModuleScript: Prizes
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)

local Prizes = require(game.ReplicatedStorage.Shared.Data.Prizes)
local Quests = require(game.ServerScriptService.Server.Quests)

local module = {}

Remote.Event("ClaimPrize"):Connect(function(player, prize)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end
	
	local actualPrize = Prizes[prize]
	if not actualPrize then
		return
	end
	
	if save.ClaimedPrizes[actualPrize.Key] then
		return
	end
	
	if actualPrize.Type == "Bubbles" then
		if save.Stats.Bubbles >= actualPrize.Requirement then
			ItemUtil:Add(save, actualPrize.Reward)
			Quests:progressQuests(player, {Type = "Collect", Item = actualPrize.Reward})
			save.ClaimedPrizes[actualPrize.Key] = true
			
			Remote:FireClient(player, "ItemsReceived", {actualPrize.Reward})
		end
	elseif actualPrize.Type == "Eggs" then
		if save.Stats.Hatches >= actualPrize.Requirement then
			ItemUtil:Add(save, actualPrize.Reward)
			Quests:progressQuests(player, {Type = "Collect", Item = actualPrize.Reward})
			save.ClaimedPrizes[actualPrize.Key] = true
			
			Remote:FireClient(player, "ItemsReceived", {actualPrize.Reward})
		end
	end
end)

return module
ModuleScript: RefundHandler
local SendSystemMessage = require(game.ReplicatedStorage.Shared.Framework.Utilities.SendSystemMessage)
local dataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local refundedGamepasses = {}

return function(playerName: string, gamepassesToRefund: {string})
	local player = game:GetService("Players"):FindFirstChild(playerName)
	if not player then
		return false, "Player not found"
	end

	local data = dataService:GetData(player)
	if not data then
		return false, "Player data not found"
	end
	
	local oldData = dataService:GetOldData(player)
	if not oldData then 
		return false, "Old player data not found"
	end

	local giftedGamepasses = oldData.GiftedPasses or {}
	local refundedList = {}

	for _, gamepass in pairs(gamepassesToRefund) do
		if not refundedGamepasses[gamepass] and giftedGamepasses[gamepass] then
			if not data.GiftedPasses[gamepass] then
				data.GiftedPasses[gamepass] = true
				table.insert(refundedList, gamepass)
			end
		end
	end

	if #refundedList == 0 then
		return false, "No gamepasses to refund"
	end

	for _, gamepass in pairs(refundedList) do
		refundedGamepasses[gamepass] = true
	end

	for _, gamepass in pairs(refundedList) do
		SendSystemMessage("You were refunded the " .. gamepass .. " gamepass!", {player})
	end

	return true, "Refund successful for gamepasses: " .. table.concat(refundedList, ", ")
end
ModuleScript: Season
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local DataService = require(game.ServerScriptService.Server.Framework.Services.DataService)
local SeasonUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.SeasonUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local InitialQuests = require(game.ReplicatedStorage.Shared.Data.Quests.InitialQuests)
local QuestUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.QuestUtil)
local Seasons = require(game.ReplicatedStorage.Shared.Data.Seasons)
local Quests = require(game.ServerScriptService.Server.Quests)
local Time = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.Time);

local module = {}

function module.UnlockPremium(player)
	local save = DataService:GetData(player)
	save.Season.Premium = true
end

function module.SkipToNextLevel(player)
	local save = DataService:GetData(player)
	local points = save.Season.Points
	if save.Season.IsInfinite then
		local newLevel = SeasonUtil:GetInfiniteSegment(save, SeasonUtil:GetCurrentSeason(), save.Season.Level + 1, true)
		save.Season.Points = newLevel.LastTrueCost
		save.Season.InfinitySkipsBought += 1
	else
		local newPoints = SeasonUtil:GetRequirement(SeasonUtil:GetCurrentSeason(), save.Season.Level + 1)
		save.Season.Points = newPoints
	end
end

function module.FinishSeason(player)
	local save = DataService:GetData(player)
	save.Season.Points = 20000
end

Remote.Event("BeginSeasonInfinite"):Connect(function(player)
	local Save = DataService:GetData(player)
	if not Save then
		return false
	end

	if Save.Season.Points >= 20000 and Save.Season.Level >= 15 then
		Save.Season.IsInfinite = true
		Save.Season.Points = 0
		Save.Season.Level = 0
	end
	
end)

local function updateChallenges(player)
	local save = DataService:GetData(player)
	if not save then
		return
	end
	
	local v300 = Time.now();
	local v301 = save.Season.Challenges.Daily * Time.secondsInDay;
	local v302 = save.Season.Challenges.Hourly * Time.secondsInHour;
	if Time.secondsInHour - (v300 - v302) <= 0 then
		SeasonUtil:RefreshChallenges(save, "Hourly")
	end
	if Time.secondsInDay - (v300 - v301) <= 0 then
		SeasonUtil:RefreshChallenges(save, "Daily")
	end
end

Remote.Event("ClaimSeason"):Connect(function(player)
	local Save = DataService:GetData(player)
	if not Save then
		return false
	end
	
	if not Save.Season.IsInfinite then
		local requirement = SeasonUtil:GetRequirement(SeasonUtil:GetCurrentSeason(), Save.Season.Level+1)
		if Save.Season.Points < requirement then
			return
		end
		ItemUtil:Add(Save, Seasons.Seasons[Save.Season.ID].Track[Save.Season.Level+1].Free)
		Quests:progressQuests(player, {Type = "Collect", Item = Seasons.Seasons[Save.Season.ID].Track[Save.Season.Level+1].Free})
		Remote:FireClient(player, "ItemsReceived", {Seasons.Seasons[Save.Season.ID].Track[Save.Season.Level+1].Free}, false)
		if Save.Season.Premium then
			ItemUtil:Add(Save, Seasons.Seasons[Save.Season.ID].Track[Save.Season.Level+1].Premium)
			Quests:progressQuests(player, {Type = "Collect", Item = Seasons.Seasons[Save.Season.ID].Track[Save.Season.Level+1].Premium})
			Remote:FireClient(player, "ItemsReceived", {Seasons.Seasons[Save.Season.ID].Track[Save.Season.Level+1].Premium}, false)
		end
	else
		local infiniteSegment = SeasonUtil:GetInfiniteSegment(Save, SeasonUtil:GetCurrentSeason(), Save.Season.Level, true)
		if Save.Season.Points < infiniteSegment.LastTrueCost then return end
		Save.Season.LastTrueCost = infiniteSegment.LastTrueCost
		local reward = SeasonUtil:GetInfinityRewards(Save, Save.Season.Level)
		ItemUtil:Add(Save, reward.Free)
		Quests:progressQuests(player, {Type = "Collect", Item = reward.Free})
		Remote:FireClient(player, "ItemsReceived", {reward.Free}, false)
		if Save.Season.Premium then
			ItemUtil:Add(Save, reward.Premium)
			Quests:progressQuests(player, {Type = "Collect", Item = reward.Premium})
			Remote:FireClient(player, "ItemsReceived", {reward.Premium}, false)
		end
		SeasonUtil:UpdateInfinityTrack(Save)
	end
	
	Save.Season.Level += 1
end)

game.Players.PlayerAdded:Connect(function(player)
	repeat task.wait() until DataService:GetData(player) ~= nil
	local save = DataService:GetData(player)
	if not save.Season then
		save.Season = SeasonUtil:NewPlayerSeason(1)
		SeasonUtil:RefreshChallenges(save, "Daily")
		SeasonUtil:RefreshChallenges(save, "Hourly")
	end
	
	task.spawn(function()
		while DataService:GetData(player) ~= nil do
			updateChallenges(player)
			task.wait(1)
		end
	end)
end)

return module
ModuleScript: Settings
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)

local Mastery = require(game.ReplicatedStorage.Shared.Data.Mastery)
local MasteryUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.MasteryUtil)
local Settings = require(game.ReplicatedStorage.Shared.Data.Settings)

local module = {}

Remote.Event("SetSetting"):Connect(function(player, settingName, value)
	local save = ServerData:GetData(player)
	if not save then
		return false
	end
	
	save.Settings[settingName] = value
end)

ServerData.DataReady:Connect(function(player)
	local data = ServerData:GetData(player)
	for _, settingType in pairs(Settings) do
		for _, setting in pairs(settingType.Settings) do
			if not data.Settings[setting.Name] then
				data.Settings[setting.Name] = setting.Data.Default
			else
				if setting.Data.Type == "Slider" then
					if typeof(data.Settings[setting.Name]) ~= "number" then
						data.Settings[setting.Name] = setting.Data.Default
					end
				end
				if setting.Data.Type == "Toggle" then
					if typeof(data.Settings[setting.Name]) ~= "boolean" then
						data.Settings[setting.Name] = setting.Data.Default
					end
				end
				if setting.Data.Type == "Keybind" then
					if typeof(data.Settings[setting.Name]) ~= "string" then
						data.Settings[setting.Name] = setting.Data.Default
					end
				end
			end
		end
	end
	
end)

return module
ModuleScript: Titles
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local SortPetsList = require(game.ReplicatedStorage.Shared.Utils.SortPetsList)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local Bindable = require(game.ReplicatedStorage.Shared.Framework.Network.Bindable)
local Leaderboards = require(game.ServerScriptService.Server.Framework.Services.Leaderboards)
local DataStoreService = game:GetService("DataStoreService")

local Titles = require(game.ReplicatedStorage.Shared.Data.Titles)

local module = {}

local function getPlayerTitleDisplay(titleId, player)
	local title = Titles[titleId]

	if titleId == "Global Hatcher" or titleId == "Global Bubbler" then
		local statType = titleId == "Global Hatcher" and "Hatches" or "Bubbles"
		local rank = Leaderboards.getLeaderboardPosition(player, statType)
		if rank then
			return string.format(" #%d %s ", rank, titleId)
		else
			module:SetTitleUnlocked(player, titleId, false)
			return
		end
	end

	return title and title.Display or titleId
end


Remote.Event("UnequipTitle"):Connect(function(player, title)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	save.TitleEquipped = ""
	module.UpdateChatTags(player)
	module.UpdatePlayerTag(player)
end)

Remote.Event("EquipTitle"):Connect(function(player, title)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	if not save.Titles[title] then
		return
	end
	
	save.TitleEquipped = title
	module.UpdateChatTags(player)
	module.UpdatePlayerTag(player)
end)

function module.UpdateChatTags(player)
	local save = ServerData:GetData(player)
	if not save then return end

	local EquippedTitle = save.TitleEquipped or ""
	if EquippedTitle == "" then
		player:SetAttribute("ChatTags", nil)
		return
	end

	local titleData = Titles[EquippedTitle]
	if not (titleData.Special or titleData.ChatTag) then
		player:SetAttribute("ChatTags", nil)
		return
	end

	local fullDisplayText = getPlayerTitleDisplay(EquippedTitle, player)
	if not fullDisplayText then return end
	
	local rankPart, titlePart = fullDisplayText:match("^ (#%d+) (Global [^ ]+) $")

	local displayText
	if rankPart and titlePart then
		displayText = string.format("[ <font color='#ffffff'>%s</font> %s ]", rankPart, titlePart)
	else
		displayText = "[" .. fullDisplayText .. "]"
	end

	local colorValue = titleData.Color
	local tagString = ""

	local function color3ToHex(color)
		return string.format("#%02x%02x%02x",
			math.floor(color.R * 255),
			math.floor(color.G * 255),
			math.floor(color.B * 255)
		)
	end

	local function lerpColor3(a, b, t)
		return Color3.new(
			a.R + (b.R - a.R) * t,
			a.G + (b.G - a.G) * t,
			a.B + (b.B - a.B) * t
		)
	end

	local function evaluateColorSequence(seq, t)
		local keypoints = seq.Keypoints

		if t <= keypoints[1].Time then
			return keypoints[1].Value
		end

		for i = 1, #keypoints - 1 do
			local a = keypoints[i]
			local b = keypoints[i + 1]
			if t <= b.Time then
				local alpha = (t - a.Time) / (b.Time - a.Time)
				return lerpColor3(a.Value, b.Value, alpha)
			end
		end

		return keypoints[#keypoints].Value
	end
	
	if typeof(colorValue) == "ColorSequence" then
		local length = #displayText
		for i = 0, length - 1 do
			local t = i / (length - 1)
			local color = evaluateColorSequence(colorValue, t)
			local hex = color3ToHex(color)
			local char = displayText:sub(i + 1, i + 1)
			tagString ..= string.format("<font color='%s'>%s</font>", hex, char)
		end
	elseif typeof(colorValue) == "Color3" then
		local hex = color3ToHex(colorValue)
		tagString = string.format("<font color='%s'>%s</font>", hex, displayText)
	else
		tagString = displayText
	end

	player:SetAttribute("ChatTags", tagString)
end

local newPlayerTagClone = game.ReplicatedStorage.Assets.PlayerTag

function module.UpdatePlayerTag(player)
	repeat task.wait() until ServerData:GetData(player) ~= nil
	local save = ServerData:GetData(player)
	
	local playerTag = player.Character:WaitForChild("Head"):FindFirstChild("PlayerTag")
	
	local EquippedTitle = save.TitleEquipped or ""
	if EquippedTitle == "" then
		playerTag.Title.Text = ""
		return
	end
	
	local titleData = Titles[EquippedTitle]
	
	local displayText = getPlayerTitleDisplay(EquippedTitle, player)
	if not displayText then return end
	playerTag.Title.Text = displayText
	local color = titleData.Color

	if typeof(color) == "ColorSequence" then
		playerTag.Title.UIGradient.Color = color
	elseif typeof(color) == "Color3" then
		playerTag.Title.UIGradient.Color = ColorSequence.new(color)
	end
end



function module:GiveTitle(player, title)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	if not save.Titles[title] then
		save.Titles[title] = true
	end
end

function module:SetTitleUnlocked(player, title, unlocked)
	local save = ServerData:GetData(player)
	if not save then
		return
	end

	save.Titles[title] = unlocked
	
	if unlocked	== false then
		if (save.TitleEquipped or "") == title then
			save.TitledEquipped = ""
		end
	end
end

task.spawn(function()
	game.Players.PlayerAdded:Connect(function(player)
		player.CharacterAdded:Connect(function(char)
			local newPlayerTag = newPlayerTagClone:Clone()
			newPlayerTag.Parent = char:WaitForChild("Head")
			newPlayerTag.Username.Text = player.DisplayName
			char:WaitForChild("Humanoid").NameDisplayDistance = 0

			module.UpdatePlayerTag(player)
		end)
	end)
end)


task.spawn(function()
	ServerData.DataReady:Connect(function(player)
		local save = ServerData:GetData(player)
		if not save then
			return
		end
		
		module.UpdateChatTags(player)

		if Leaderboards.getLeaderboardPosition(player, "Bubbles") then
			module:SetTitleUnlocked(player, "Global Bubbler", true)
		else
			module:SetTitleUnlocked(player, "Global Bubbler", false)
		end
		
		if Leaderboards.getLeaderboardPosition(player, "Hatches") then
			module:SetTitleUnlocked(player, "Global Hatcher", true)
		else
			module:SetTitleUnlocked(player, "Global Hatcher", false)
		end
	end)
end)

ServerData:ConnectDataChanged("Stats", function(player)
	local save = ServerData:GetData(player)
	for titleName, title in pairs(Titles) do
		if title.Requirement then
			local progress, needed = title.Requirement.GetProgress(save)
			if progress >= needed then
				module:GiveTitle(player, titleName)
			end
		end
	end

	if save.Passes["VIP"] then
		module:GiveTitle(player, "VIP")
	end

	if save.Passes["Extra Equips"] and save.Passes["Infinity Gum"] and save.Passes["Double Gems"] and save.Passes["VIP"] and save.Passes["Double Luck"] and save.Passes["Triple Hatch"] and save.Passes["Fast Hatch"] and save.Passes["Digital Storage"] then
		module:GiveTitle(player, "Money Bags")
	end
end)


return module
ModuleScript: Trading
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local SortPetsList = require(game.ReplicatedStorage.Shared.Utils.SortPetsList)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local Bindable = require(game.ReplicatedStorage.Shared.Framework.Network.Bindable)
local Pets = require(game.ServerScriptService.Server.Framework.Services.Pets)


local module = {}

local tradeRequests = {}
local currentTrades = {}

-- TradeStarted
-- TradeUpdated
-- TradeEnded

local HttpService = game:GetService("HttpService")

local function sendTradeLog(player, otherPlayer, tradeData)
	local webhookUrl = "https://discord.com/api/webhooks/1374072717032165396/G2-7Xi_SXRmYmG6yRT-sA26QGQ7Ot4ejnUaoJ4i7SO4frGMXl7Eys0oWz6d4FuVqS12V"

	local tradeLog = {
		content = "A trade has happend!",
		embeds = {
			{
				title = "Trade Log",
				description = "Trade Log",
				fields = {
					{
						name = "Player 1",
						value = player.Name,
						inline = true
					},
					{
						name = "Player 2",
						value = otherPlayer.Name,
						inline = true
					},
					{
						name = "Trade Data",
						value = HttpService:JSONEncode(tradeData),
						inline = false
					}
				},
				color = 3447003  
			}
		}
	}

	local jsonData = HttpService:JSONEncode(tradeLog)

	local success, response = pcall(function()
		return HttpService:PostAsync(webhookUrl, jsonData, Enum.HttpContentType.ApplicationJson)
	end)

	if not success then
		warn("Failed to send trade log: " .. tostring(response))
	end
end


function module.StartTrade(player, otherPlayer)
	local playerData = ServerData:GetData(player)
	local otherPlayerData = ServerData:GetData(otherPlayer)
	if not playerData or not otherPlayerData then
		return
	end
	player:SetAttribute("Trading", true)
	otherPlayer:SetAttribute("Trading", true)
	
	local newTrade = {
		Party0 = {
			Inventory = {
				Powerups = playerData.Powerups,
				Potions = playerData.Potions,
				Pets = playerData.Pets
			},
			Player = player,
			Offer = {},
			Confirmed = false,
			Accepted = false
		},
		Processing = false,
		Party1 = {
			Inventory = {
				Powerups = otherPlayerData.Powerups,
				Potions = otherPlayerData.Potions,
				Pets = otherPlayerData.Pets
			},
			Player = otherPlayer,
			Offer = {},
			Confirmed = false,
			Accepted = false
		},
		Id = game:GetService("HttpService"):GenerateGUID(false),
		Timer = 0
	}
	
	table.insert(currentTrades, newTrade)
	Remote:FireClient(player, "TradeStarted", newTrade)
	Remote:FireClient(otherPlayer, "TradeStarted", newTrade)
	return true
end


Remote.Event("TradeRequest"):Connect(function(player, otherPlayer)
	if not tradeRequests[player] then
		tradeRequests[player] = {}
	end
	if not tradeRequests[otherPlayer] then
		tradeRequests[otherPlayer] = {}
	end
	
	if tradeRequests[player][otherPlayer] then
		return
	end
	
	if module:IsInTrade(player) or module:IsInTrade(otherPlayer) then
		return
	end
	
	tradeRequests[player][otherPlayer] = true
	Remote:FireClient(otherPlayer, "TradeRequest", player)
	
	task.delay(Constants.TradeRequestExpiry, function()
		if tradeRequests[player][otherPlayer] then
			tradeRequests[player][otherPlayer] = nil
		end
	end)
end)

Remote.Event("TradeAcceptRequest"):Connect(function(player, otherPlayer)
	if not tradeRequests[player] then
		tradeRequests[player] = {}
	end
	if not tradeRequests[otherPlayer] then
		tradeRequests[otherPlayer] = {}
	end
	
	if module:IsInTrade(player) or module:IsInTrade(otherPlayer) then
		return
	end
	
	if tradeRequests[otherPlayer][player] then
		module.StartTrade(player, otherPlayer)
		tradeRequests[otherPlayer][player] = nil
		return
	end
end)

function module:IsInTrade(player)
	for _, trade in pairs(currentTrades) do
		for _, party in pairs(trade) do
			if typeof(party) == "table" then
				if party.Player then
					if party.Player == player then
						return true
					end
				end
			end
		end
	end
	return false
end

function module:UpdateTrade(tradeId)
	local trade = module:GetTradeById(tradeId)
	if not trade then return end
	Remote:FireClient(trade.Party0.Player, "TradeUpdated", trade)
	Remote:FireClient(trade.Party1.Player, "TradeUpdated", trade)
end

function module:GetTradeFromPlayer(player)
	for _, trade in pairs(currentTrades) do
		for _, party in pairs(trade) do
			if typeof(party) == "table" then
				if party.Player then
					if party.Player == player then
						return trade
					end
				end
			end
		end
	end
	return nil
end

function module:GetPartyFromPlayer(player)
	local trade = module:GetTradeFromPlayer(player)
	if not trade then return end
	for _, party in pairs(trade) do
		if typeof(party) == "table" then
			if party.Player then
				if party.Player == player then
					return party
				end
			end
		end
	end
end

function module:GetTradeById(tradeID)
	for _, trade in pairs(currentTrades) do
		if trade.Id == tradeID then
			return trade
		end
	end
	return nil
end

function module:RemoveTrade(tradeID)
	for tradeIndex, trade in pairs(currentTrades) do
		if trade.Id == tradeID then
			table.remove(currentTrades, tradeIndex)
		end
	end
end

function module:EndTrade(trade, result)
	Remote:FireClient(trade.Party0.Player, "TradeEnded", result)
	Remote:FireClient(trade.Party1.Player, "TradeEnded", result)
	trade.Party0.Player:SetAttribute("Trading", false)
	trade.Party1.Player:SetAttribute("Trading", false)
	module:RemoveTrade(trade.Id)
end

function module:ProcessTrade(tradeID)
	local trade = module:GetTradeById(tradeID)
	if not trade then return end
	
	local party0save = ServerData:GetData(trade.Party0.Player)
	local party1save = ServerData:GetData(trade.Party1.Player)
	
	trade.Processing = true
	module:UpdateTrade(trade.Id)

	if not module:GetTradeById(tradeID) then return end
	
	for _, item in pairs(trade.Party0.Offer) do
		if item.Type == "Pet" then
			local petUID = string.split(item.Id, ":")[1]
			local petData = Pets.getPetDataByUID(trade.Party0.Player, petUID)
			if petData then
				if petData.Enchants then
					local newPet = {
						Id = game:GetService("HttpService"):GenerateGUID(false),
						Name = petData.Name,
						Shiny = petData.Shiny == true or nil,
						Mythic = petData.Mythic == true or nil,
						XP = petData.XP,
						Enchants = petData.Enchants
					}
					table.insert(party1save.Pets, newPet)
				else
					local newPet = {
						Type = "Pet",
						Name = petData.Name,
						Shiny = petData.Shiny,
						Mythic = petData.Mythic,
						XP = petData.XP
					}
					ItemUtil:Add(party1save, newPet)
				end
				
				Pets.DeletePet(trade.Party0.Player, petUID, 1)
			end
		end
	end
	
	for _, item in pairs(trade.Party1.Offer) do
		if item.Type == "Pet" then
			local petUID = string.split(item.Id, ":")[1]
			local petData = Pets.getPetDataByUID(trade.Party1.Player, petUID)
			if petData then
				if petData.Enchants then
					local newPet = {
						Id = game:GetService("HttpService"):GenerateGUID(false),
						Name = petData.Name,
						Shiny = petData.Shiny == true or nil,
						Mythic = petData.Mythic == true or nil,
						XP = petData.XP,
						Enchants = petData.Enchants
					}
					table.insert(party0save.Pets, newPet)
				else
					local newPet = {
						Type = "Pet",
						Name = petData.Name,
						Shiny = petData.Shiny,
						Mythic = petData.Mythic,
						XP = petData.XP
					}
					ItemUtil:Add(party0save, newPet)
				end

				Pets.DeletePet(trade.Party1.Player, petUID, 1)
			end
		end
	end
	
	task.spawn(function()
		sendTradeLog(trade.Party0.Player, trade.Party1.Player, trade)
	end)
	
	module:EndTrade(trade, "success")
end

function module:AmountOfPetInTrade(currentParty, petUID)
	local amount = 0
	for _, pet in pairs(currentParty.Offer) do
		if string.split(pet.Id, ":")[1] == petUID then
			amount += 1
		end
	end
	return amount
end

function module:isPetInTrade(currentParty, petUIDindex)
	for _, pet in pairs(currentParty.Offer) do
		if pet.Id == petUIDindex then
			return true
		end
	end
	return false
end

function module:removePetFromTrade(currentParty, petUIDindex)
	for petIndex, pet in pairs(currentParty.Offer) do
		if pet.Id == petUIDindex then
			table.remove(currentParty.Offer, petIndex)
			return true
		end
	end
	return false
end

function module:UnreadyAll(trade)
	trade.Party0.Accepted = false
	trade.Party1.Accepted = false
	trade.Party0.Confirmed = false
	trade.Party1.Confirmed = false
	module:UpdateTrade(trade.Id)
end

function module:isConfirmed(trade)
	return trade.Party0.Confirmed or trade.Party1.Confirmed
end

Remote.Event("TradeAddPet"):Connect(function(player, petUIDindex)
	local trade = module:GetTradeFromPlayer(player)
	local currentParty = module:GetPartyFromPlayer(player)
	if not trade or not currentParty then return end
	
	local data = ServerData:GetData(player)
	if not data then return end
	if module:isConfirmed(trade) then return end
	
	
	module:UnreadyAll(trade)
	
	local petUID = string.split(petUIDindex, ":")[1]
	
	local petData = Pets.getPetDataByUID(player, petUID)
	if not petData then return end
	local petAmount = petData.Amount or 1
	if module:AmountOfPetInTrade(currentParty, petUID)+1 > petAmount then
		return
	end
	if module:isPetInTrade(currentParty, petUIDindex) then return end
	
	table.insert(currentParty.Offer, {Id = petUIDindex, Type = "Pet"})
	
	module:UpdateTrade(trade.Id)
end)

Remote.Event("TradeRemovePet"):Connect(function(player, petUIDindex)
	local trade = module:GetTradeFromPlayer(player)
	local currentParty = module:GetPartyFromPlayer(player)
	if not trade or not currentParty then return end
	
	local data = ServerData:GetData(player)
	if not data then return end
	if module:isConfirmed(trade) then return end
	
	module:UnreadyAll(trade)
	
	if not module:isPetInTrade(currentParty, petUIDindex) then return end
	
	module:removePetFromTrade(currentParty, petUIDindex)
	module:UpdateTrade(trade.Id)
end)

Remote.Event("TradeAccept"):Connect(function(player)
	local trade = module:GetTradeFromPlayer(player)
	local currentParty = module:GetPartyFromPlayer(player)
	if not trade or not currentParty then return end
	currentParty.Accepted = true
	
	if trade.Party0.Accepted and trade.Party1.Accepted then
		trade.Timer = workspace:GetServerTimeNow() + Constants.TradeConfirmTimer
	end
	module:UpdateTrade(trade.Id)
end)

Remote.Event("TradeConfirm"):Connect(function(player)
	local trade = module:GetTradeFromPlayer(player)
	local currentParty = module:GetPartyFromPlayer(player)
	if not trade or not currentParty then return end
	if not trade.Party0.Accepted or not trade.Party1.Accepted then return end
	
	currentParty.Confirmed = true
	
	module:UpdateTrade(trade.Id)

	if trade.Party0.Confirmed and trade.Party1.Confirmed then
		module:ProcessTrade(trade.Id)
	end
	
end)

Remote.Event("TradeDecline"):Connect(function(player)
	local trade = module:GetTradeFromPlayer(player)
	if trade then
		module:EndTrade(trade, "cancelled")
	end
end)

Remote.Event("TradeSetRequestsAllowed"):Connect(function(player, value)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	save.Settings["Trade Requests"] = value
	player:SetAttribute("TradeRequestsAllowed", value)
end)

function module.isTradingUnlocked(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	local requiredHatchesforTrading = Constants.TradeEggsRequirement
	return requiredHatchesforTrading <= save.Stats.Hatches
end

function module:isTradeBanned(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	return save.TradeModeration.Banned
end

function module:setTradeBanned(player, value)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	save.TradeModeration.Banned = value
end

ServerData.DataReady:Connect(function(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end

	player:SetAttribute("Trading", false)
	player:SetAttribute("TradingAllowed", not module:isTradeBanned(player))
	player:SetAttribute("TradingUnlocked", module.isTradingUnlocked(player))
	player:SetAttribute("TradeRequestsAllowed", save.Settings["Trade Requests"])
end)

ServerData:ConnectDataChanged("Stats", function(player)
	local save = ServerData:GetData(player)
	if not save then return end
	player:SetAttribute("TradingUnlocked", module.isTradingUnlocked(player))
end)

game.Players.PlayerRemoving:Connect(function(player)
	local trade = module:GetTradeFromPlayer(player)
	if trade then
		module:EndTrade(trade, "cancelled")
	end
end)



return module
ModuleScript: VisualItems
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local CurrencyUtil = require(game.ReplicatedStorage.Shared.Utils.CurrencyUtil)
local Quests = require(game.ServerScriptService.Server.Quests)
local DeepCopy = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.DeepCopy)

local module = {}

local activeVisualItems = {}

function module.CreateVisualItems(player, position, items)
	local save = ServerData:GetData(player)
	
	local newVisualItems = {}
	for _, item in pairs(items) do
		local uid = game:GetService("HttpService"):GenerateGUID(false)
		newVisualItems[uid] = item 
		
		
		if not activeVisualItems[player] then
			activeVisualItems[player] = {}
		end
		activeVisualItems[player][uid] = item
	end
	
	Remote:FireClient(player, "RenderVisualItems", position, newVisualItems)
end

local claimedItemsTable = {}

Remote.Event("GrabVisualItem"):Connect(function(player, visualItems)
	local save = ServerData:GetData(player)

	if not claimedItemsTable[player.UserId] then
		claimedItemsTable[player.UserId] = {}
	end

	local claimedItems = claimedItemsTable[player.UserId]

	for _, visualItemUID in pairs(visualItems) do
		if claimedItems[visualItemUID] then
			continue
		end

		local item = activeVisualItems[player][visualItemUID]
		if item then
			ItemUtil:Add(save, item)
			Quests:progressQuests(player, {Type = "Collect", Item = item})

			claimedItems[visualItemUID] = true

			Remote:FireClient(player, "ItemsReceived", {item})
		end
	end
end)



return module
ModuleScript: WheelSpin
local Remote = require(game.ReplicatedStorage.Shared.Framework.Network.Remote)
local ServerData = require(game.ServerScriptService.Server.Framework.Services.DataService)
local StatsUtil = require(game.ReplicatedStorage.Shared.Utils.Stats.StatsUtil)
local ItemUtil = require(game.ServerScriptService.Server.Utils.Stats.ItemUtil)
local GetEggPool = require(game.ReplicatedStorage.Shared.Utils.GetEggPool)
local GetRandomWeightedItem = require(game.ReplicatedStorage.Shared.Framework.Utilities.Math.GetRandomWeightedItem)
local Powerups = require(game.ReplicatedStorage.Shared.Data.Powerups)
local VisualItems = require(game.ServerScriptService.Server.Framework.Services.VisualItems)

local CompareTable = require(game.ReplicatedStorage.Shared.Framework.Utilities.Table.CompareTable)
local Constants = require(game.ReplicatedStorage.Shared.Constants)
local Quests = require(game.ServerScriptService.Server.Quests)




local WheelSpin = require(game.ReplicatedStorage.Shared.Data.WheelSpin)
local module = {}

local SpinItem = {
	Type = "Powerup", 
	Name = "Spin Ticket", 
	Amount = 1
}

local WheelSpinQueue = {}

Remote.Function("WheelSpin", function(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	if not ItemUtil:CanAfford(save, SpinItem) then
		return false
	end
	ItemUtil:Deduct(save, SpinItem)
	
	local ChosenItem = GetRandomWeightedItem(WheelSpin)
	if not WheelSpinQueue[player] then
		WheelSpinQueue[player] = {}
	end
	
	table.insert(WheelSpinQueue[player], ChosenItem)
	local chosenIndex
	
	for index, data in pairs(WheelSpin) do
		if CompareTable(data.Item, ChosenItem) then
			chosenIndex = index
		end
	end
	save.Stats.WheelSpins += 1
	
	return chosenIndex
end)

Remote.Event("ClaimFreeWheelSpin"):Connect(function(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	
	if workspace:GetServerTimeNow() < save.NextWheelSpin then
		return
	end
	save.NextWheelSpin = workspace:GetServerTimeNow() + Constants.FreeWheelSpinCooldown
	
	ItemUtil:Add(save, SpinItem)
	Quests:progressQuests(player, {Type = "Collect", Item = SpinItem})
	Remote:FireClient(player, "ItemsReceived", {SpinItem})
end)

Remote.Event("ClaimWheelSpinQueue"):Connect(function(player)
	local save = ServerData:GetData(player)
	if not save then
		return
	end
	if not WheelSpinQueue[player] then return end
	
	for _, item in pairs(WheelSpinQueue[player]) do
		ItemUtil:Add(save, item)
		Quests:progressQuests(player, {Type = "Collect", Item = item})
		Remote:FireClient(player, "ItemsReceived", {item}, false)
	end
	
	WheelSpinQueue[player] = {}
end)

return module





